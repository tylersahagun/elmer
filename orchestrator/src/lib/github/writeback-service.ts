/**
 * GitHub Writeback Service
 *
 * Core service layer for committing documents and prototypes to GitHub repositories.
 * Provides atomic commit capabilities with operation tracking in the database.
 */

import type {
  WritebackConfig,
  WritebackFile,
  WritebackResult,
  CommitMetadata,
} from "./types";
import { db } from "@/lib/db";
import { githubWriteOps, projects, workspaces, workspaceMembers } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";
import { getGitHubClient } from "./auth";

/**
 * Slugifies a project name for use in commit messages.
 */
function slugifyForCommit(projectName: string): string {
  return projectName
    .toLowerCase()
    .replace(/\s+/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}

/**
 * Generates an atomic commit message with project context.
 *
 * Pattern: docs({project-slug}): {action} {document-type}
 * Example: "docs(feature-alpha): add prd"
 *
 * @param metadata - Commit metadata with project and document info
 * @param action - The action being performed ("add" or "update")
 * @returns Formatted commit message
 */
export function generateCommitMessage(
  metadata: CommitMetadata,
  action: "add" | "update" = "add"
): string {
  const slug = slugifyForCommit(metadata.projectName);
  const docType = metadata.documentType?.replace(/_/g, "-") || "document";

  const lines = [
    `docs(${slug}): ${action} ${docType}`,
    "",
    `Project: ${metadata.projectName}`,
    `Generated by: Elmer${metadata.triggeredBy ? ` (${metadata.triggeredBy})` : ""}`,
  ];

  if (metadata.stageRunId) {
    lines.push(`Stage run: ${metadata.stageRunId}`);
  }

  return lines.join("\n").trim();
}

/**
 * Creates a writeback operation record in the database.
 *
 * @param config - Writeback configuration
 * @param files - Files to be committed
 * @param message - Commit message
 * @param metadata - Commit metadata
 * @returns The operation ID
 */
async function createWritebackOperation(
  config: WritebackConfig,
  files: WritebackFile[],
  message: string,
  metadata: CommitMetadata
): Promise<string> {
  const opId = `ghop_${nanoid()}`;

  await db.insert(githubWriteOps).values({
    id: opId,
    workspaceId: config.workspaceId,
    repoFullName: `${config.owner}/${config.repo}`,
    baseBranch: config.branch,
    writeBranch: config.branch, // Direct commit to branch
    status: "prepared",
    proposedChanges: {
      files: files.map((f) => ({ path: f.path, action: "add" })),
      message,
      metadata,
    },
    createdAt: new Date(),
  });

  return opId;
}

/**
 * Updates the status of a writeback operation.
 *
 * @param opId - Operation ID
 * @param status - New status
 * @param commitSha - Optional commit SHA (for successful commits)
 */
async function updateOperationStatus(
  opId: string,
  status: "committed" | "failed",
  commitSha?: string
): Promise<void> {
  await db
    .update(githubWriteOps)
    .set({
      status,
      ...(commitSha ? { commitSha } : {}),
    })
    .where(eq(githubWriteOps.id, opId));
}

/**
 * Commits files to GitHub using authenticated Octokit client.
 * Records the operation in githubWriteOps for tracking and audit.
 *
 * @param config - Writeback configuration (workspace, project, repo details)
 * @param files - Array of files to commit
 * @param metadata - Commit metadata for message generation
 * @param userId - User ID for GitHub authentication
 * @param action - Whether adding or updating files
 * @returns WritebackResult with success status and commit details
 *
 * @example
 * const result = await commitToGitHub(
 *   { workspaceId, projectId, projectName, owner, repo, branch },
 *   [{ path: "initiatives/feature-a/prd.md", content: "# PRD..." }],
 *   { projectId, projectName, documentType: "prd", triggeredBy: "automation" },
 *   "user_123"
 * );
 */
export async function commitToGitHub(
  config: WritebackConfig,
  files: WritebackFile[],
  metadata: CommitMetadata,
  userId: string,
  action: "add" | "update" = "add"
): Promise<WritebackResult> {
  const message = generateCommitMessage(metadata, action);
  const opId = `ghop_${nanoid()}`;

  try {
    // Get authenticated GitHub client
    const octokit = await getGitHubClient(userId);
    if (!octokit) {
      return {
        success: false,
        error: "GitHub not connected. Please reconnect your GitHub account.",
      };
    }

    // Record the operation as "prepared"
    await db.insert(githubWriteOps).values({
      id: opId,
      workspaceId: config.workspaceId,
      repoFullName: `${config.owner}/${config.repo}`,
      baseBranch: config.branch,
      writeBranch: config.branch,
      status: "prepared",
      proposedChanges: {
        files: files.map((f) => ({ path: f.path, action })),
        message,
        metadata,
      },
      createdBy: userId,
      createdAt: new Date(),
    });

    // Get current branch ref
    const { data: refData } = await octokit.git.getRef({
      owner: config.owner,
      repo: config.repo,
      ref: `heads/${config.branch}`,
    });

    const parentSha = refData.object.sha;
    const { data: commitData } = await octokit.git.getCommit({
      owner: config.owner,
      repo: config.repo,
      commit_sha: parentSha,
    });

    // Create tree entries for files
    const tree = files.map((file) => ({
      path: file.path,
      mode: "100644" as const,
      type: "blob" as const,
      content: file.content,
    }));

    // Create new tree
    const { data: newTree } = await octokit.git.createTree({
      owner: config.owner,
      repo: config.repo,
      base_tree: commitData.tree.sha,
      tree,
    });

    // Create commit
    const { data: newCommit } = await octokit.git.createCommit({
      owner: config.owner,
      repo: config.repo,
      message,
      tree: newTree.sha,
      parents: [parentSha],
    });

    // Update branch ref
    await octokit.git.updateRef({
      owner: config.owner,
      repo: config.repo,
      ref: `heads/${config.branch}`,
      sha: newCommit.sha,
    });

    // Update operation status to committed
    await db.update(githubWriteOps)
      .set({
        status: "committed",
        commitSha: newCommit.sha,
      })
      .where(eq(githubWriteOps.id, opId));

    return {
      success: true,
      commitSha: newCommit.sha,
      commitUrl: `https://github.com/${config.owner}/${config.repo}/commit/${newCommit.sha}`,
      filesWritten: files.map((f) => f.path),
    };
  } catch (error) {
    console.error("[writeback-service] Commit failed:", error);

    // Try to update operation status to failed
    try {
      await db.update(githubWriteOps)
        .set({ status: "failed" })
        .where(eq(githubWriteOps.id, opId));
    } catch {
      // Ignore cleanup errors
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to commit to GitHub",
    };
  }
}

/**
 * Gets the writeback configuration for a project from workspace settings.
 * Extracts GitHub repo info and branch configuration from the workspace.
 *
 * @param workspaceId - The workspace ID
 * @param projectId - The project ID
 * @returns WritebackConfig if workspace has GitHub connected, null otherwise
 *
 * @example
 * const config = await getWritebackConfig("ws_123", "proj_456");
 * if (config) {
 *   // Ready to commit
 * }
 */
export async function getWritebackConfig(
  workspaceId: string,
  projectId: string
): Promise<WritebackConfig | null> {
  // Get project with workspace via relation
  const project = await db.query.projects.findFirst({
    where: eq(projects.id, projectId),
    with: { workspace: true },
  });

  if (!project || !project.workspace) {
    return null;
  }

  const workspace = project.workspace;
  const settings = workspace.settings || {};

  // Parse repo from githubRepo (format: "owner/repo")
  if (!workspace.githubRepo) {
    return null;
  }

  const [owner, repo] = workspace.githubRepo.split("/");
  if (!owner || !repo) {
    return null;
  }

  return {
    workspaceId,
    projectId,
    projectName: project.name,
    owner,
    repo,
    branch: settings.baseBranch || "main",
    basePath: "initiatives", // Could make this configurable later via settings
  };
}

/**
 * Checks if a workspace has writeback enabled (GitHub connected with valid repo).
 *
 * @param workspaceId - The workspace ID
 * @returns True if writeback is available
 */
export async function isWritebackEnabled(workspaceId: string): Promise<boolean> {
  const workspace = await db.query.workspaces.findFirst({
    where: eq(workspaces.id, workspaceId),
  });

  if (!workspace?.githubRepo) {
    return false;
  }

  const [owner, repo] = workspace.githubRepo.split("/");
  return Boolean(owner && repo);
}

/**
 * Gets the first admin user ID for a workspace (for automated operations).
 * In production, this should use the actual user context from the stage run.
 *
 * @param workspaceId - The workspace ID
 * @returns User ID if found, null otherwise
 */
export async function getWorkspaceUserId(workspaceId: string): Promise<string | null> {
  const member = await db.query.workspaceMembers.findFirst({
    where: eq(workspaceMembers.workspaceId, workspaceId),
    orderBy: (members, { asc }) => [asc(members.joinedAt)],
  });
  return member?.userId || null;
}
