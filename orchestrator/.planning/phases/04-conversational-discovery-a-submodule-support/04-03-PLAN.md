---
phase: 04-conversational-discovery-a-submodule-support
plan: 03
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - src/lib/stores/conversation-store.ts
  - src/lib/stores/discovery-store.ts
autonomous: true

must_haves:
  truths:
    - "Conversation state tracks current question and user answers"
    - "User can answer questions and see history of answers"
    - "User can go back and revise previous answers"
    - "Discovery adapts based on conversation answers"
  artifacts:
    - path: "src/lib/stores/conversation-store.ts"
      provides: "Conversation state management"
      exports: ["useConversationStore"]
    - path: "src/lib/stores/discovery-store.ts"
      provides: "Extended discovery store with conversation integration"
      contains: "setAmbiguities"
  key_links:
    - from: "src/lib/stores/conversation-store.ts"
      to: "src/lib/discovery/types.ts"
      via: "type imports"
      pattern: "import.*DiscoveryAmbiguity"
---

<objective>
Create Zustand stores for managing conversational discovery state including Q&A flow, answer history, and revision capability.

Purpose: The conversation flow needs persistent state management for tracking questions asked, answers given, and allowing users to revise previous answers. This follows the existing Zustand pattern used for onboarding and discovery stores.

Output: Conversation store with question/answer tracking and discovery store extensions for ambiguity integration.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/stores/discovery-store.ts
@src/lib/stores/onboarding-store.ts
@src/lib/discovery/types.ts
@src/lib/discovery/ambiguity-detector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation store</name>
  <files>src/lib/stores/conversation-store.ts</files>
  <action>
Create a new Zustand store for managing conversation state:

```typescript
/**
 * Conversation Store
 *
 * Manages the conversational discovery Q&A flow.
 * Implements CONV-02 (chat-like interface), CONV-04 (deterministic flow),
 * CONV-05 (revise previous answers).
 */

import { create } from 'zustand';
import type {
  DiscoveryAmbiguity,
  AmbiguityOption,
} from '@/lib/discovery/types';

/**
 * A message in the conversation
 */
export interface ConversationMessage {
  id: string;
  type: 'system' | 'question' | 'answer' | 'info';
  content: string;
  timestamp: Date;

  // For question messages
  ambiguityId?: string;
  options?: AmbiguityOption[];

  // For answer messages
  selectedOptionId?: string;
  selectedOptionLabel?: string;

  // UI state
  canRevise?: boolean;
}

/**
 * Answer record for tracking user's choices
 */
export interface AnswerRecord {
  ambiguityId: string;
  selectedOptionId: string;
  selectedOptionValue: unknown;
  answeredAt: Date;
  revised: boolean;
}

interface ConversationState {
  // Message history
  messages: ConversationMessage[];

  // Answer tracking
  answers: Map<string, AnswerRecord>;

  // Current state
  currentAmbiguityId: string | null;
  isWaitingForAnswer: boolean;
  isComplete: boolean;

  // Actions
  startConversation: () => void;
  askQuestion: (ambiguity: DiscoveryAmbiguity) => void;
  answerQuestion: (ambiguityId: string, option: AmbiguityOption) => void;
  reviseAnswer: (ambiguityId: string) => void;
  addInfoMessage: (content: string) => void;
  markComplete: () => void;

  // Getters
  getAnswer: (ambiguityId: string) => AnswerRecord | undefined;
  getAllAnswers: () => AnswerRecord[];
  canRevise: (ambiguityId: string) => boolean;

  // Reset
  reset: () => void;
}

/**
 * Generate unique message ID
 */
function generateMessageId(): string {
  return `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
}

export const useConversationStore = create<ConversationState>((set, get) => ({
  messages: [],
  answers: new Map(),
  currentAmbiguityId: null,
  isWaitingForAnswer: false,
  isComplete: false,

  startConversation: () => {
    set({
      messages: [{
        id: generateMessageId(),
        type: 'system',
        content: "I'm analyzing your repository structure. Let me ask a few questions to make sure I understand it correctly.",
        timestamp: new Date(),
      }],
      answers: new Map(),
      currentAmbiguityId: null,
      isWaitingForAnswer: false,
      isComplete: false,
    });
  },

  askQuestion: (ambiguity) => {
    const message: ConversationMessage = {
      id: generateMessageId(),
      type: 'question',
      content: ambiguity.question,
      timestamp: new Date(),
      ambiguityId: ambiguity.id,
      options: ambiguity.options,
    };

    set((state) => ({
      messages: [...state.messages, message],
      currentAmbiguityId: ambiguity.id,
      isWaitingForAnswer: true,
    }));
  },

  answerQuestion: (ambiguityId, option) => {
    const { currentAmbiguityId, answers } = get();

    // Verify this is the current question
    if (currentAmbiguityId !== ambiguityId) {
      console.warn('Answering non-current question:', ambiguityId);
    }

    // Create answer message
    const answerMessage: ConversationMessage = {
      id: generateMessageId(),
      type: 'answer',
      content: option.label,
      timestamp: new Date(),
      selectedOptionId: option.id,
      selectedOptionLabel: option.label,
      canRevise: true,
    };

    // Record the answer
    const answerRecord: AnswerRecord = {
      ambiguityId,
      selectedOptionId: option.id,
      selectedOptionValue: option.value,
      answeredAt: new Date(),
      revised: answers.has(ambiguityId), // Mark as revised if we had a previous answer
    };

    const newAnswers = new Map(answers);
    newAnswers.set(ambiguityId, answerRecord);

    set((state) => ({
      messages: [...state.messages, answerMessage],
      answers: newAnswers,
      currentAmbiguityId: null,
      isWaitingForAnswer: false,
    }));
  },

  reviseAnswer: (ambiguityId) => {
    const { messages, answers } = get();

    // Find the original question for this ambiguity
    const questionMessage = messages.find(
      m => m.type === 'question' && m.ambiguityId === ambiguityId
    );

    if (!questionMessage || !questionMessage.options) {
      console.warn('Cannot revise - question not found:', ambiguityId);
      return;
    }

    // Add info message about revision
    const infoMessage: ConversationMessage = {
      id: generateMessageId(),
      type: 'info',
      content: 'Revising previous answer...',
      timestamp: new Date(),
    };

    // Re-ask the question
    const newQuestionMessage: ConversationMessage = {
      id: generateMessageId(),
      type: 'question',
      content: questionMessage.content,
      timestamp: new Date(),
      ambiguityId,
      options: questionMessage.options,
    };

    // Mark previous answer as revised
    const previousAnswer = answers.get(ambiguityId);
    if (previousAnswer) {
      const newAnswers = new Map(answers);
      newAnswers.set(ambiguityId, { ...previousAnswer, revised: true });
      set({ answers: newAnswers });
    }

    set((state) => ({
      messages: [...state.messages, infoMessage, newQuestionMessage],
      currentAmbiguityId: ambiguityId,
      isWaitingForAnswer: true,
    }));
  },

  addInfoMessage: (content) => {
    const message: ConversationMessage = {
      id: generateMessageId(),
      type: 'info',
      content,
      timestamp: new Date(),
    };

    set((state) => ({
      messages: [...state.messages, message],
    }));
  },

  markComplete: () => {
    const completeMessage: ConversationMessage = {
      id: generateMessageId(),
      type: 'system',
      content: "Great! I now have enough information to complete the discovery. You can review the results below.",
      timestamp: new Date(),
    };

    set((state) => ({
      messages: [...state.messages, completeMessage],
      isComplete: true,
      isWaitingForAnswer: false,
      currentAmbiguityId: null,
    }));
  },

  getAnswer: (ambiguityId) => {
    return get().answers.get(ambiguityId);
  },

  getAllAnswers: () => {
    return Array.from(get().answers.values());
  },

  canRevise: (ambiguityId) => {
    // Can revise if we have an answer and conversation is not complete
    const { answers, isComplete } = get();
    return answers.has(ambiguityId) && !isComplete;
  },

  reset: () => {
    set({
      messages: [],
      answers: new Map(),
      currentAmbiguityId: null,
      isWaitingForAnswer: false,
      isComplete: false,
    });
  },
}));
```
  </action>
  <verify>Run `npx tsc --noEmit` - store should compile without errors</verify>
  <done>Conversation store created with Q&A tracking</done>
</task>

<task type="auto">
  <name>Task 2: Extend discovery store with ambiguity support</name>
  <files>src/lib/stores/discovery-store.ts</files>
  <action>
Extend the existing discovery store to integrate with ambiguities. Add the following to the existing store:

1. Add new state fields:
```typescript
// Add to DiscoveryState interface
ambiguities: DiscoveryAmbiguity[];
hasUnresolvedAmbiguities: boolean;
```

2. Add new actions:
```typescript
// Add to actions section
setAmbiguities: (ambiguities: DiscoveryAmbiguity[]) => void;
resolveAmbiguity: (ambiguityId: string, optionId: string) => void;
applyAmbiguityResolutions: () => void;
```

3. Add imports at top of file:
```typescript
import type { DiscoveryAmbiguity } from '@/lib/discovery/types';
```

4. Initialize new state in the store:
```typescript
ambiguities: [],
hasUnresolvedAmbiguities: false,
```

5. Implement the new actions:

```typescript
setAmbiguities: (ambiguities) => {
  set({
    ambiguities,
    hasUnresolvedAmbiguities: ambiguities.some(a => !a.resolved),
  });
},

resolveAmbiguity: (ambiguityId, optionId) => {
  set((state) => {
    const newAmbiguities = state.ambiguities.map(a =>
      a.id === ambiguityId
        ? { ...a, resolved: true, selectedOptionId: optionId }
        : a
    );
    return {
      ambiguities: newAmbiguities,
      hasUnresolvedAmbiguities: newAmbiguities.some(a => !a.resolved),
    };
  });
},

applyAmbiguityResolutions: () => {
  // Apply resolved ambiguities to filter discovery results
  const { result, ambiguities } = get();
  if (!result) return;

  // Find folder selection ambiguity
  const folderAmbiguity = ambiguities.find(
    a => a.type === 'multiple_initiative_folders' && a.resolved
  );

  if (folderAmbiguity && folderAmbiguity.selectedOptionId !== 'use_all') {
    // Filter initiatives to only include selected folder
    const selectedFolder = folderAmbiguity.options.find(
      o => o.id === folderAmbiguity.selectedOptionId
    )?.value as string | undefined;

    if (selectedFolder) {
      const filteredInitiatives = result.initiatives.filter(
        i => i.sourceFolder === selectedFolder
      );

      // Update selection to only include filtered initiatives
      const newSelectedIds = new Set(
        filteredInitiatives.map(i => i.id)
      );

      set({ selectedInitiatives: newSelectedIds });
    }
  }

  // Find status mapping ambiguities and apply column overrides
  const statusAmbiguities = ambiguities.filter(
    a => a.type === 'ambiguous_status_mapping' && a.resolved
  );

  if (statusAmbiguities.length > 0) {
    // Create a map of status -> column from resolutions
    const columnOverrides = new Map<string, string>();
    for (const amb of statusAmbiguities) {
      const selectedColumn = amb.options.find(
        o => o.id === amb.selectedOptionId
      )?.value as string | undefined;

      if (selectedColumn && amb.context.paths) {
        for (const path of amb.context.paths) {
          const init = result.initiatives.find(i => i.sourcePath === path);
          if (init?.status) {
            columnOverrides.set(init.status, selectedColumn);
          }
        }
      }
    }

    // Note: We don't modify result directly - UI should use these overrides
    // when displaying mapped columns
  }
},
```

6. Update reset() to clear ambiguity state:
```typescript
// In reset function, add:
ambiguities: [],
hasUnresolvedAmbiguities: false,
```
  </action>
  <verify>Run `npx tsc --noEmit` - store should compile without errors</verify>
  <done>Discovery store extended with ambiguity integration</done>
</task>

<task type="auto">
  <name>Task 3: Add store tests</name>
  <files>src/lib/stores/__tests__/conversation-store.test.ts</files>
  <action>
Create test file for conversation store:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { act, renderHook } from '@testing-library/react';
import { useConversationStore } from '../conversation-store';
import type { DiscoveryAmbiguity } from '@/lib/discovery/types';

describe('useConversationStore', () => {
  beforeEach(() => {
    const { result } = renderHook(() => useConversationStore());
    act(() => {
      result.current.reset();
    });
  });

  describe('startConversation', () => {
    it('initializes with system message', () => {
      const { result } = renderHook(() => useConversationStore());

      act(() => {
        result.current.startConversation();
      });

      expect(result.current.messages).toHaveLength(1);
      expect(result.current.messages[0].type).toBe('system');
      expect(result.current.isComplete).toBe(false);
    });
  });

  describe('askQuestion', () => {
    it('adds question message and sets waiting state', () => {
      const { result } = renderHook(() => useConversationStore());

      const ambiguity: DiscoveryAmbiguity = {
        id: 'amb_1',
        type: 'multiple_initiative_folders',
        question: 'Which folder?',
        options: [
          { id: 'opt_1', label: '/features/', value: 'features' },
          { id: 'opt_2', label: '/work/', value: 'work' },
        ],
        context: { paths: ['features', 'work'] },
        resolved: false,
      };

      act(() => {
        result.current.startConversation();
        result.current.askQuestion(ambiguity);
      });

      expect(result.current.messages).toHaveLength(2);
      expect(result.current.messages[1].type).toBe('question');
      expect(result.current.messages[1].ambiguityId).toBe('amb_1');
      expect(result.current.currentAmbiguityId).toBe('amb_1');
      expect(result.current.isWaitingForAnswer).toBe(true);
    });
  });

  describe('answerQuestion', () => {
    it('records answer and clears waiting state', () => {
      const { result } = renderHook(() => useConversationStore());

      const ambiguity: DiscoveryAmbiguity = {
        id: 'amb_1',
        type: 'multiple_initiative_folders',
        question: 'Which folder?',
        options: [
          { id: 'opt_1', label: '/features/', value: 'features' },
        ],
        context: {},
        resolved: false,
      };

      act(() => {
        result.current.startConversation();
        result.current.askQuestion(ambiguity);
        result.current.answerQuestion('amb_1', ambiguity.options[0]);
      });

      expect(result.current.messages).toHaveLength(3);
      expect(result.current.messages[2].type).toBe('answer');
      expect(result.current.messages[2].selectedOptionId).toBe('opt_1');
      expect(result.current.isWaitingForAnswer).toBe(false);

      const answer = result.current.getAnswer('amb_1');
      expect(answer).toBeDefined();
      expect(answer?.selectedOptionId).toBe('opt_1');
      expect(answer?.selectedOptionValue).toBe('features');
    });
  });

  describe('reviseAnswer', () => {
    it('allows revising previous answer', () => {
      const { result } = renderHook(() => useConversationStore());

      const ambiguity: DiscoveryAmbiguity = {
        id: 'amb_1',
        type: 'multiple_initiative_folders',
        question: 'Which folder?',
        options: [
          { id: 'opt_1', label: '/features/', value: 'features' },
          { id: 'opt_2', label: '/work/', value: 'work' },
        ],
        context: {},
        resolved: false,
      };

      act(() => {
        result.current.startConversation();
        result.current.askQuestion(ambiguity);
        result.current.answerQuestion('amb_1', ambiguity.options[0]);
      });

      // Now revise
      act(() => {
        result.current.reviseAnswer('amb_1');
      });

      // Should have info message + re-asked question
      expect(result.current.messages.length).toBeGreaterThan(3);
      expect(result.current.isWaitingForAnswer).toBe(true);
      expect(result.current.currentAmbiguityId).toBe('amb_1');

      // Previous answer should be marked as revised
      const answer = result.current.getAnswer('amb_1');
      expect(answer?.revised).toBe(true);
    });

    it('canRevise returns correct value', () => {
      const { result } = renderHook(() => useConversationStore());

      const ambiguity: DiscoveryAmbiguity = {
        id: 'amb_1',
        type: 'multiple_initiative_folders',
        question: 'Which folder?',
        options: [{ id: 'opt_1', label: '/features/', value: 'features' }],
        context: {},
        resolved: false,
      };

      // No answer yet
      expect(result.current.canRevise('amb_1')).toBe(false);

      act(() => {
        result.current.startConversation();
        result.current.askQuestion(ambiguity);
        result.current.answerQuestion('amb_1', ambiguity.options[0]);
      });

      // Has answer, not complete
      expect(result.current.canRevise('amb_1')).toBe(true);

      act(() => {
        result.current.markComplete();
      });

      // Complete, cannot revise
      expect(result.current.canRevise('amb_1')).toBe(false);
    });
  });

  describe('markComplete', () => {
    it('adds completion message and sets complete state', () => {
      const { result } = renderHook(() => useConversationStore());

      act(() => {
        result.current.startConversation();
        result.current.markComplete();
      });

      expect(result.current.isComplete).toBe(true);
      expect(result.current.isWaitingForAnswer).toBe(false);
      expect(result.current.messages[result.current.messages.length - 1].type).toBe('system');
    });
  });

  describe('getAllAnswers', () => {
    it('returns all recorded answers', () => {
      const { result } = renderHook(() => useConversationStore());

      const ambiguity1: DiscoveryAmbiguity = {
        id: 'amb_1',
        type: 'multiple_initiative_folders',
        question: 'Q1?',
        options: [{ id: 'opt_1', label: 'A1', value: 'v1' }],
        context: {},
        resolved: false,
      };

      const ambiguity2: DiscoveryAmbiguity = {
        id: 'amb_2',
        type: 'multiple_context_paths',
        question: 'Q2?',
        options: [{ id: 'opt_2', label: 'A2', value: 'v2' }],
        context: {},
        resolved: false,
      };

      act(() => {
        result.current.startConversation();
        result.current.askQuestion(ambiguity1);
        result.current.answerQuestion('amb_1', ambiguity1.options[0]);
        result.current.askQuestion(ambiguity2);
        result.current.answerQuestion('amb_2', ambiguity2.options[0]);
      });

      const answers = result.current.getAllAnswers();
      expect(answers).toHaveLength(2);
    });
  });

  describe('reset', () => {
    it('clears all state', () => {
      const { result } = renderHook(() => useConversationStore());

      act(() => {
        result.current.startConversation();
        result.current.addInfoMessage('test');
      });

      act(() => {
        result.current.reset();
      });

      expect(result.current.messages).toHaveLength(0);
      expect(result.current.isComplete).toBe(false);
      expect(result.current.answers.size).toBe(0);
    });
  });
});
```
  </action>
  <verify>Run `npm test -- conversation-store` - all tests should pass</verify>
  <done>Store tests pass</done>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit`
- Tests pass: `npm test -- conversation-store`
- Stores importable: `import { useConversationStore } from '@/lib/stores/conversation-store'`
</verification>

<success_criteria>
- Conversation store manages message history
- Users can answer questions and answers are recorded
- Revision of previous answers works
- Discovery store integrates with ambiguity resolution
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversational-discovery-a-submodule-support/04-03-SUMMARY.md`
</output>
