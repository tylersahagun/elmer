---
phase: 04-conversational-discovery-a-submodule-support
plan: 04
type: execute
wave: 2
depends_on: [04-02]
files_modified:
  - src/lib/discovery/streaming-scanner.ts
  - src/lib/discovery/streaming.ts
  - src/app/api/discovery/stream/route.ts
autonomous: true

must_haves:
  truths:
    - "Scanner detects and scans submodules for prototype paths"
    - "Submodule scan results included in discovery result"
    - "Streaming events emitted for submodule scanning progress"
  artifacts:
    - path: "src/lib/discovery/streaming-scanner.ts"
      provides: "Extended scanner with submodule support"
      contains: "scanSubmodules"
    - path: "src/lib/discovery/streaming.ts"
      provides: "New submodule streaming event types"
      contains: "submodule_found"
  key_links:
    - from: "src/lib/discovery/streaming-scanner.ts"
      to: "src/lib/discovery/submodule-detector.ts"
      via: "function imports"
      pattern: "import.*detectSubmodules"
---

<objective>
Extend the streaming scanner to detect and scan Git submodules for prototype paths and additional initiatives.

Purpose: Repositories often store prototypes in submodules (e.g., elephant-ai/web/src/components/prototypes/). The scanner needs to identify these submodules and scan them for relevant content.

Output: Extended streaming scanner that detects submodules and scans them for prototype paths, emitting streaming events during the process.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/discovery/streaming-scanner.ts
@src/lib/discovery/streaming.ts
@src/lib/discovery/submodule-detector.ts
@src/lib/discovery/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add submodule streaming event types</name>
  <files>src/lib/discovery/streaming.ts</files>
  <action>
Extend the streaming types file to include submodule-related events.

Add to the DiscoveryStreamEvent union type (look for the existing event types and add these):

```typescript
// Add these event types to the existing union
| { type: 'submodule_detected'; data: { submodule: DiscoveredSubmodule; elapsedMs: number } }
| { type: 'submodule_scanning'; data: { submodulePath: string; elapsedMs: number } }
| { type: 'submodule_scanned'; data: { submodule: DiscoveredSubmodule; prototypePath?: string; elapsedMs: number } }
| { type: 'submodule_error'; data: { submodulePath: string; error: string; elapsedMs: number } }
```

Also add import for the type:
```typescript
import type { DiscoveredSubmodule } from './types';
```

Update createStreamEvent function to handle the new event types - it should already work since it's generic, but verify it can handle these types.
  </action>
  <verify>Run `npx tsc --noEmit` - types should compile without errors</verify>
  <done>Submodule streaming event types added</done>
</task>

<task type="auto">
  <name>Task 2: Extend streaming scanner with submodule support</name>
  <files>src/lib/discovery/streaming-scanner.ts</files>
  <action>
Extend the streaming scanner to detect and scan submodules. Make these changes:

1. Add imports at top:
```typescript
import {
  detectSubmodules,
  parseGitHubUrl,
  isPathInSubmodule,
} from './submodule-detector';
import type { DiscoveredSubmodule } from './types';
```

2. Add submodules to the return result. Find where DiscoveryResult is built at the end and add:
```typescript
// Add to result compilation section
const result: DiscoveryResult = {
  // ... existing fields ...
  submodules,  // Add this field
};
```

3. Add submodule detection after tree fetching (after Step 2 where folders/files are built). Insert this new section:

```typescript
// Step 2.5: Detect submodules
const submodules: DiscoveredSubmodule[] = [];
const treeEntriesForSubmoduleCheck = treeEntries.map(e => ({
  path: e.path,
  type: e.type as string,
}));

const detectedSubmodules = await detectSubmodules({
  owner,
  repo,
  branch,
  octokit,
  treeEntries: treeEntriesForSubmoduleCheck,
});

for (const submodule of detectedSubmodules) {
  // Check for cancellation
  if (checkAborted(signal)) {
    onProgress(createStreamEvent('cancelled', { elapsedMs: Date.now() - startTime }));
    return createEmptyResult(owner, repo, branch, stats, warnings);
  }

  // Emit detection event
  onProgress(createStreamEvent('submodule_detected', {
    submodule,
    elapsedMs: Date.now() - startTime,
  }));

  submodules.push(submodule);
}
```

4. Add submodule scanning after agent detection (before Step 7). Insert this section:

```typescript
// Step 6.5: Scan submodules for prototype paths
for (const submodule of submodules) {
  // Check for cancellation
  if (checkAborted(signal)) {
    onProgress(createStreamEvent('cancelled', { elapsedMs: Date.now() - startTime }));
    return createEmptyResult(owner, repo, branch, stats, warnings);
  }

  // Skip submodules requiring auth (for now - SUBM-05 will handle this)
  if (submodule.requiresAuth) {
    submodule.scanError = 'Submodule requires separate authentication';
    submodule.canScan = false;
    continue;
  }

  // Parse submodule URL to get owner/repo
  const submoduleRepo = parseGitHubUrl(submodule.url);
  if (!submoduleRepo) {
    submodule.scanError = 'Unable to parse submodule URL';
    submodule.canScan = false;
    continue;
  }

  // Emit scanning event
  onProgress(createStreamEvent('submodule_scanning', {
    submodulePath: submodule.path,
    elapsedMs: Date.now() - startTime,
  }));

  try {
    // Fetch submodule tree
    const { data: submoduleTree } = await octokit.git.getTree({
      owner: submoduleRepo.owner,
      repo: submoduleRepo.repo,
      tree_sha: submodule.branch || 'main',
      recursive: 'true',
    });

    const submoduleFolders = new Map<string, TreeEntry>();
    const submoduleFiles = new Map<string, TreeEntry>();

    for (const entry of submoduleTree.tree) {
      if (entry.type === 'tree') {
        submoduleFolders.set(entry.path, entry as TreeEntry);
      } else if (entry.type === 'blob') {
        submoduleFiles.set(entry.path, entry as TreeEntry);
      }
    }

    // Look for prototype paths
    for (const [folderPath] of submoduleFolders) {
      const folderName = getFolderName(folderPath);
      if (
        folderName.toLowerCase() === 'prototypes' ||
        folderName.toLowerCase() === 'prototype'
      ) {
        const fullPath = `${submodule.path}/${folderPath}`;
        submodule.prototypePath = fullPath;

        // Add as context path
        const fileCount = Array.from(submoduleFiles.keys()).filter(
          f => f.startsWith(folderPath + '/')
        ).length;

        const contextPath = {
          type: 'prototypes' as const,
          path: fullPath,
          confidence: 1.0,
          fileCount,
          selected: true,
        };

        if (!contextPaths.some(cp => cp.path === fullPath)) {
          contextPaths.push(contextPath);
          stats.contextPathsFound++;

          onProgress(createStreamEvent('context_path_found', {
            contextPath,
            elapsedMs: Date.now() - startTime,
          }));
        }
      }
    }

    // Mark as scanned
    submodule.scanned = true;

    // Emit scanned event
    onProgress(createStreamEvent('submodule_scanned', {
      submodule,
      prototypePath: submodule.prototypePath,
      elapsedMs: Date.now() - startTime,
    }));

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    submodule.scanError = errorMessage;
    submodule.canScan = false;

    onProgress(createStreamEvent('submodule_error', {
      submodulePath: submodule.path,
      error: errorMessage,
      elapsedMs: Date.now() - startTime,
    }));

    warnings.push({
      type: 'api_error',
      path: submodule.path,
      message: `Failed to scan submodule: ${errorMessage}`,
    });
  }
}
```

5. Update DiscoveryStats type usage if needed (or add comment that submodules are tracked via the submodules array).

Note: Keep the existing code structure intact. Only add the new submodule-related code at the specified insertion points.
  </action>
  <verify>Run `npx tsc --noEmit` - scanner should compile without errors</verify>
  <done>Streaming scanner extended with submodule support</done>
</task>

<task type="auto">
  <name>Task 3: Update API route to include submodules in response</name>
  <files>src/app/api/discovery/stream/route.ts</files>
  <action>
The API route should already work since it passes the DiscoveryResult directly from the scanner. However, verify that:

1. The route properly handles the new submodule-related events
2. The SSE stream correctly serializes submodule data

Check the route file and ensure:
- The sendStreamEvent function can handle all event types
- No type errors with the new event types
- Submodule data is included in the final 'completed' event

If changes are needed, make minimal modifications to support the new events. The existing infrastructure should handle this since createStreamEvent is generic.

Also add submodule detection for the case when .gitmodules is present but the scanner hasn't been updated to handle it - this ensures backward compatibility.
  </action>
  <verify>Run `npx tsc --noEmit` - API route should compile without errors</verify>
  <done>API route supports submodule events</done>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit`
- Streaming events include submodule types
- Scanner detects submodules when .gitmodules present
- Prototype paths in submodules discovered
</verification>

<success_criteria>
- New streaming event types (submodule_detected, submodule_scanning, submodule_scanned, submodule_error) defined
- Scanner detects submodules via detectSubmodules()
- Scanner scans accessible submodules for prototype paths
- Prototype paths from submodules added to contextPaths
- Cross-org submodules flagged as requiring auth (not scanned yet)
- Streaming events emitted during submodule processing
- Result includes submodules array
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversational-discovery-a-submodule-support/04-04-SUMMARY.md`
</output>
