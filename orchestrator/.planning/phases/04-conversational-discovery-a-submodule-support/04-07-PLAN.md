---
phase: 04-conversational-discovery-a-submodule-support
plan: 07
type: execute
wave: 4
depends_on: [04-03, 04-04, 04-05, 04-06]
files_modified:
  - src/components/onboarding/steps/DiscoveryStep.tsx
  - src/hooks/useStreamingDiscovery.ts
autonomous: false

must_haves:
  truths:
    - "Conversational Q&A appears when ambiguities detected"
    - "Submodule preview appears when submodules detected"
    - "Discovery results adapt based on user answers"
    - "Full flow works end-to-end"
  artifacts:
    - path: "src/components/onboarding/steps/DiscoveryStep.tsx"
      provides: "Integrated discovery step with conversation and submodules"
      contains: "ConversationPanel"
    - path: "src/hooks/useStreamingDiscovery.ts"
      provides: "Extended hook with submodule events"
      contains: "submodules"
  key_links:
    - from: "src/components/onboarding/steps/DiscoveryStep.tsx"
      to: "src/components/discovery/ConversationPanel.tsx"
      via: "component import"
      pattern: "import.*ConversationPanel"
---

<objective>
Integrate conversational discovery and submodule preview into the main discovery step, completing the Phase 4 feature set.

Purpose: Connect all the pieces built in previous plans - ambiguity detection, conversation UI, submodule detection, and submodule preview - into the existing DiscoveryStep workflow.

Output: Fully integrated discovery flow with conversational Q&A and submodule support.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/onboarding/steps/DiscoveryStep.tsx
@src/hooks/useStreamingDiscovery.ts
@src/lib/stores/discovery-store.ts
@src/lib/stores/conversation-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useStreamingDiscovery hook for submodules</name>
  <files>src/hooks/useStreamingDiscovery.ts</files>
  <action>
Extend the streaming discovery hook to handle submodule events and track submodule state.

1. Add new state for submodules:
```typescript
// Add to the hook's state
const [submodules, setSubmodules] = useState<DiscoveredSubmodule[]>([]);
const [scanningSubmodules, setScanningSubmodules] = useState<Set<string>>(new Set());
```

2. Add type import:
```typescript
import type { DiscoveredSubmodule } from '@/lib/discovery/types';
```

3. Handle new event types in the event handler (find the switch or if-else handling events):
```typescript
case 'submodule_detected':
  setSubmodules(prev => [...prev, event.data.submodule]);
  break;

case 'submodule_scanning':
  setScanningSubmodules(prev => new Set([...prev, event.data.submodulePath]));
  break;

case 'submodule_scanned':
  setScanningSubmodules(prev => {
    const next = new Set(prev);
    next.delete(event.data.submodulePath);
    return next;
  });
  // Update the submodule in the list
  setSubmodules(prev => prev.map(s =>
    s.path === event.data.submodule.path ? event.data.submodule : s
  ));
  break;

case 'submodule_error':
  setScanningSubmodules(prev => {
    const next = new Set(prev);
    next.delete(event.data.submodulePath);
    return next;
  });
  // Update submodule with error
  setSubmodules(prev => prev.map(s =>
    s.path === event.data.submodulePath
      ? { ...s, scanError: event.data.error, canScan: false }
      : s
  ));
  break;
```

4. Reset submodule state when starting discovery:
```typescript
// In startDiscovery function
setSubmodules([]);
setScanningSubmodules(new Set());
```

5. Return submodule state from hook:
```typescript
return {
  // ... existing returns ...
  submodules,
  scanningSubmodules,
};
```
  </action>
  <verify>Run `npx tsc --noEmit` - hook should compile without errors</verify>
  <done>Hook extended with submodule support</done>
</task>

<task type="auto">
  <name>Task 2: Integrate conversation and submodules into DiscoveryStep</name>
  <files>src/components/onboarding/steps/DiscoveryStep.tsx</files>
  <action>
Update DiscoveryStep to include ConversationPanel and SubmodulePreview.

1. Add imports at top of file:
```typescript
import { ConversationPanel, SubmodulePreview } from "@/components/discovery";
import { useConversationStore } from "@/lib/stores/conversation-store";
import { detectAmbiguities, hasUnresolvedAmbiguities } from "@/lib/discovery";
```

2. Add conversation store access:
```typescript
// Inside the component, add:
const {
  isComplete: conversationComplete,
  reset: resetConversation,
} = useConversationStore();

// From discovery store, also access:
const { ambiguities, hasUnresolvedAmbiguities: hasUnresolved, setAmbiguities } = useDiscoveryStore();
```

3. Get submodule state from streaming hook:
```typescript
// Extend the useStreamingDiscovery destructuring to include:
const {
  // ... existing ...
  submodules,
  scanningSubmodules,
} = useStreamingDiscovery({ ... });
```

4. After discovery completes, detect ambiguities:
```typescript
// In the onComplete callback of useStreamingDiscovery:
onComplete: (discoveryResult) => {
  setResult(discoveryResult);
  // Detect ambiguities for conversational flow
  const detected = detectAmbiguities(discoveryResult);
  setAmbiguities(detected);
},
```

5. Update handleSkip to reset conversation:
```typescript
const handleSkip = () => {
  cancelDiscovery();
  resetDiscovery();
  resetConversation();  // Add this
  resetImport();
  onSkip();
};
```

6. In the main discovery preview section (after "Main discovery preview" comment), add the ConversationPanel BEFORE the ValidationSummary if there are unresolved ambiguities:

```typescript
{/* Conversational Q&A for ambiguities - shows before main preview */}
{result && ambiguities.length > 0 && !conversationComplete && (
  <ConversationPanel
    onComplete={() => {
      // Conversation complete - ambiguities resolved
    }}
    className="mb-6"
  />
)}
```

7. Add SubmodulePreview section after the Agent Architecture section (before the Import Progress Modal):

```typescript
{/* Submodule Section */}
{(submodules.length > 0 || (result && result.submodules?.length > 0)) && (
  <div className="space-y-4 pt-4 border-t">
    <SubmodulePreview
      submodules={result?.submodules || submodules}
      scanningSubmodulePaths={scanningSubmodules}
    />
  </div>
)}
```

8. Update the import button to be disabled while conversation is incomplete:
```typescript
// In the button's disabled check, add:
disabled={
  totalSelectedCount === 0 ||
  isImporting ||
  (ambiguities.length > 0 && !conversationComplete)  // Add this condition
}
```

9. Add a message when waiting for conversation:
```typescript
{/* Show message if waiting for conversation */}
{ambiguities.length > 0 && !conversationComplete && (
  <p className="text-sm text-muted-foreground">
    Please answer the questions above before importing.
  </p>
)}
```
  </action>
  <verify>Run `npx tsc --noEmit` - component should compile without errors</verify>
  <done>DiscoveryStep integrated with conversation and submodules</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end verification</name>
  <what-built>
Complete conversational discovery and submodule support:
- Ambiguity detection when multiple initiative folders exist
- Chat-like Q&A interface for clarifying questions
- Submodule detection via .gitmodules
- Submodule scanning for prototype paths
- Integrated discovery flow
  </what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`
2. Navigate to a workspace's onboarding flow that has BOTH:
   - Multiple initiative folders (features/ and work/)
   - Git submodules

   If you don't have such a repo, test with a simpler case:
   - A repo with just multiple initiative folders to test conversation
   - A repo with submodules to test submodule detection

3. **Test Conversational Flow (CONV-01 through CONV-05):**
   - Verify system asks clarifying question when multiple folders found
   - Verify question appears in chat-like format
   - Verify you can select an option
   - Verify you can revise your answer
   - Verify discovery adapts based on your answer

4. **Test Submodule Support (SUBM-01 through SUBM-04):**
   - Verify submodules are detected (shown in preview)
   - Verify submodules are scanned for prototypes
   - Verify prototype paths from submodules appear
   - Verify cross-org submodules show "Auth required" badge

5. **Test Full Integration:**
   - Verify import button is disabled until conversation complete
   - Verify import works after answering questions
   - Verify workspace correctly configured with submodule paths
  </how-to-verify>
  <resume-signal>Type "approved" if all flows work, or describe specific issues found</resume-signal>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit`
- Dev server runs: `npm run dev`
- All Phase 4 requirements verified via checkpoint
</verification>

<success_criteria>
**Conversational Discovery (CONV-01 through CONV-05):**
- CONV-01: System asks clarifying questions when structure is ambiguous
- CONV-02: User answers in chat-like interface
- CONV-03: System adapts discovery based on responses
- CONV-04: Conversation flow is deterministic (based on detected ambiguities)
- CONV-05: User can revise previous answers

**Submodule Support (SUBM-01 through SUBM-05):**
- SUBM-01: Detect Git submodules via .gitmodules
- SUBM-02: Scan submodules for prototype paths
- SUBM-03: Show submodule structure in preview
- SUBM-04: Configure workspace for submodule prototype generation
- SUBM-05: Handle submodules requiring separate auth (flagged, not scanned)

**Integration:**
- Full flow works end-to-end
- Import disabled until conversation complete
- Results reflect user's answers
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversational-discovery-a-submodule-support/04-07-SUMMARY.md`
</output>
