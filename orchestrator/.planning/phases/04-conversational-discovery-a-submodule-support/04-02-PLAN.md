---
phase: 04-conversational-discovery-a-submodule-support
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/discovery/submodule-detector.ts
  - src/lib/discovery/types.ts
  - src/lib/discovery/index.ts
autonomous: true

must_haves:
  truths:
    - "System detects .gitmodules file in repository"
    - "System parses submodule paths and URLs from .gitmodules"
    - "Submodule information is available for scanner to use"
  artifacts:
    - path: "src/lib/discovery/submodule-detector.ts"
      provides: "Submodule detection and parsing"
      exports: ["detectSubmodules", "parseGitmodules", "Submodule"]
    - path: "src/lib/discovery/types.ts"
      provides: "Submodule type definitions"
      contains: "DiscoveredSubmodule"
  key_links:
    - from: "src/lib/discovery/submodule-detector.ts"
      to: "src/lib/discovery/types.ts"
      via: "type imports"
      pattern: "import.*DiscoveredSubmodule"
---

<objective>
Implement submodule detection for repository scanning that identifies Git submodules via .gitmodules file.

Purpose: Many repositories use submodules for prototypes or shared code (like elephant-ai/web/src/components/prototypes/). The scanner needs to detect these submodules so it can optionally scan them for additional content.

Output: Submodule detector module that parses .gitmodules and returns structured submodule information.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/discovery/types.ts
@src/lib/discovery/scanner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add submodule types to types.ts</name>
  <files>src/lib/discovery/types.ts</files>
  <action>
Add new types for submodule support to the existing types file. Add after the existing type definitions:

```typescript
/**
 * A detected Git submodule
 */
export interface DiscoveredSubmodule {
  name: string;                    // Submodule name from .gitmodules
  path: string;                    // Local path in repo (e.g., "elephant-ai")
  url: string;                     // Remote URL of submodule
  branch?: string;                 // Optional branch specification

  // Scan state
  canScan: boolean;                // Whether we can scan this submodule
  scanError?: string;              // Error if we can't scan
  requiresAuth: boolean;           // Needs separate authentication

  // Discovery results (populated after scanning)
  scanned: boolean;                // Has this been scanned?
  initiatives: DiscoveredInitiative[];
  contextPaths: DiscoveredContextPath[];
  prototypePath?: string;          // If prototypes folder found
}

/**
 * Extended discovery result with submodule support
 */
export interface DiscoveryResultWithSubmodules extends DiscoveryResult {
  submodules: DiscoveredSubmodule[];
  hasSubmodules: boolean;
}
```

Do NOT remove any existing types. Add these after the existing type definitions but before any re-exports.
  </action>
  <verify>Run `npx tsc --noEmit` - types should compile without errors</verify>
  <done>Submodule types added to types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create submodule detector module</name>
  <files>src/lib/discovery/submodule-detector.ts</files>
  <action>
Create a new module that detects and parses Git submodules:

```typescript
/**
 * Submodule Detector Module
 *
 * Detects Git submodules via .gitmodules file and parses their configuration.
 * Implements SUBM-01 (detect submodules via .gitmodules).
 */

import type { Octokit } from "@octokit/rest";
import type {
  DiscoveredSubmodule,
  DiscoveredInitiative,
  DiscoveredContextPath,
} from './types';

/**
 * Parsed entry from .gitmodules file
 */
interface GitmoduleEntry {
  name: string;
  path: string;
  url: string;
  branch?: string;
}

/**
 * Parse .gitmodules file content into structured entries
 *
 * .gitmodules format:
 * [submodule "name"]
 *   path = local/path
 *   url = https://github.com/org/repo.git
 *   branch = main
 */
export function parseGitmodules(content: string): GitmoduleEntry[] {
  const entries: GitmoduleEntry[] = [];
  const lines = content.split('\n');

  let currentEntry: Partial<GitmoduleEntry> | null = null;

  for (const line of lines) {
    const trimmed = line.trim();

    // Start of new submodule section
    const sectionMatch = trimmed.match(/^\[submodule\s+"([^"]+)"\]$/);
    if (sectionMatch) {
      // Save previous entry if exists
      if (currentEntry && currentEntry.name && currentEntry.path && currentEntry.url) {
        entries.push(currentEntry as GitmoduleEntry);
      }
      currentEntry = { name: sectionMatch[1] };
      continue;
    }

    // Skip if no current entry
    if (!currentEntry) continue;

    // Parse key-value pairs
    const kvMatch = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
    if (kvMatch) {
      const [, key, value] = kvMatch;
      switch (key.toLowerCase()) {
        case 'path':
          currentEntry.path = value.trim();
          break;
        case 'url':
          currentEntry.url = value.trim();
          break;
        case 'branch':
          currentEntry.branch = value.trim();
          break;
      }
    }
  }

  // Don't forget the last entry
  if (currentEntry && currentEntry.name && currentEntry.path && currentEntry.url) {
    entries.push(currentEntry as GitmoduleEntry);
  }

  return entries;
}

/**
 * Check if a URL requires authentication (private repo)
 * This is a heuristic - we check if it's a github.com URL
 * that isn't the same org as the parent repo
 */
function checkRequiresAuth(
  submoduleUrl: string,
  parentOwner: string
): boolean {
  try {
    const url = new URL(submoduleUrl.replace(/\.git$/, ''));

    // Extract owner from GitHub URL
    if (url.hostname === 'github.com') {
      const pathParts = url.pathname.split('/').filter(Boolean);
      const submoduleOwner = pathParts[0];

      // Same org = probably has access
      // Different org = might need separate auth
      return submoduleOwner.toLowerCase() !== parentOwner.toLowerCase();
    }

    // Non-GitHub URLs likely need auth
    return true;
  } catch {
    // Can't parse URL, assume needs auth
    return true;
  }
}

/**
 * Extract GitHub owner/repo from a URL
 */
export function parseGitHubUrl(url: string): { owner: string; repo: string } | null {
  try {
    // Handle various GitHub URL formats
    // https://github.com/owner/repo.git
    // git@github.com:owner/repo.git
    // https://github.com/owner/repo

    let normalized = url.replace(/\.git$/, '');

    // SSH format
    if (normalized.startsWith('git@github.com:')) {
      normalized = normalized.replace('git@github.com:', 'https://github.com/');
    }

    const parsed = new URL(normalized);
    if (parsed.hostname !== 'github.com') {
      return null;
    }

    const parts = parsed.pathname.split('/').filter(Boolean);
    if (parts.length >= 2) {
      return { owner: parts[0], repo: parts[1] };
    }

    return null;
  } catch {
    return null;
  }
}

/**
 * Detect submodules in a repository
 *
 * @param options - Detection options
 * @returns Array of detected submodules (not yet scanned)
 */
export async function detectSubmodules(options: {
  owner: string;
  repo: string;
  branch: string;
  octokit: Octokit;
  treeEntries?: Array<{ path: string; type: string }>;  // Reuse existing tree data
}): Promise<DiscoveredSubmodule[]> {
  const { owner, repo, branch, octokit, treeEntries } = options;

  // Check if .gitmodules exists
  let hasGitmodules = false;

  if (treeEntries) {
    // Use existing tree data
    hasGitmodules = treeEntries.some(
      entry => entry.path === '.gitmodules' && entry.type === 'blob'
    );
  } else {
    // Check via API
    try {
      await octokit.repos.getContent({
        owner,
        repo,
        path: '.gitmodules',
        ref: branch,
      });
      hasGitmodules = true;
    } catch (error) {
      // 404 = no .gitmodules, which is fine
      if ((error as { status?: number }).status !== 404) {
        console.error('Error checking for .gitmodules:', error);
      }
      hasGitmodules = false;
    }
  }

  if (!hasGitmodules) {
    return [];
  }

  // Fetch and parse .gitmodules
  try {
    const { data } = await octokit.repos.getContent({
      owner,
      repo,
      path: '.gitmodules',
      ref: branch,
    });

    if (!('content' in data) || !data.content) {
      return [];
    }

    const content = Buffer.from(data.content, 'base64').toString('utf8');
    const entries = parseGitmodules(content);

    // Convert to DiscoveredSubmodule format
    return entries.map(entry => ({
      name: entry.name,
      path: entry.path,
      url: entry.url,
      branch: entry.branch,
      canScan: true, // Will be validated during actual scanning
      requiresAuth: checkRequiresAuth(entry.url, owner),
      scanned: false,
      initiatives: [],
      contextPaths: [],
    }));

  } catch (error) {
    console.error('Error parsing .gitmodules:', error);
    return [];
  }
}

/**
 * Check if a path is inside a submodule
 */
export function isPathInSubmodule(
  path: string,
  submodules: DiscoveredSubmodule[]
): DiscoveredSubmodule | null {
  for (const submodule of submodules) {
    if (path.startsWith(submodule.path + '/') || path === submodule.path) {
      return submodule;
    }
  }
  return null;
}

/**
 * Get the relative path within a submodule
 */
export function getSubmoduleRelativePath(
  fullPath: string,
  submodule: DiscoveredSubmodule
): string {
  if (fullPath === submodule.path) {
    return '';
  }
  return fullPath.slice(submodule.path.length + 1);
}

// Re-export types for consumers
export type { DiscoveredSubmodule, GitmoduleEntry };
```
  </action>
  <verify>Run `npx tsc --noEmit` - module should compile without errors</verify>
  <done>Submodule detector module created</done>
</task>

<task type="auto">
  <name>Task 3: Export from barrel file and add tests</name>
  <files>src/lib/discovery/index.ts, src/lib/discovery/__tests__/submodule-detector.test.ts</files>
  <action>
1. Update barrel file to export new module:

Add to `src/lib/discovery/index.ts`:
```typescript
export * from './submodule-detector';
```

2. Create test file `src/lib/discovery/__tests__/submodule-detector.test.ts`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import {
  parseGitmodules,
  parseGitHubUrl,
  detectSubmodules,
  isPathInSubmodule,
  getSubmoduleRelativePath,
} from '../submodule-detector';
import type { DiscoveredSubmodule } from '../types';

describe('parseGitmodules', () => {
  it('parses single submodule entry', () => {
    const content = `[submodule "elephant-ai"]
	path = elephant-ai
	url = https://github.com/org/elephant-ai.git`;

    const entries = parseGitmodules(content);

    expect(entries).toHaveLength(1);
    expect(entries[0]).toEqual({
      name: 'elephant-ai',
      path: 'elephant-ai',
      url: 'https://github.com/org/elephant-ai.git',
    });
  });

  it('parses multiple submodule entries', () => {
    const content = `[submodule "frontend"]
	path = packages/frontend
	url = https://github.com/org/frontend.git
	branch = main

[submodule "backend"]
	path = packages/backend
	url = git@github.com:org/backend.git`;

    const entries = parseGitmodules(content);

    expect(entries).toHaveLength(2);
    expect(entries[0].name).toBe('frontend');
    expect(entries[0].path).toBe('packages/frontend');
    expect(entries[0].branch).toBe('main');
    expect(entries[1].name).toBe('backend');
    expect(entries[1].path).toBe('packages/backend');
  });

  it('handles empty content', () => {
    expect(parseGitmodules('')).toHaveLength(0);
  });

  it('handles malformed content gracefully', () => {
    const content = `not a valid gitmodules file
some random text`;

    expect(parseGitmodules(content)).toHaveLength(0);
  });

  it('handles partial entries (missing required fields)', () => {
    const content = `[submodule "incomplete"]
	path = some/path`;

    // Should not include entries missing url
    expect(parseGitmodules(content)).toHaveLength(0);
  });
});

describe('parseGitHubUrl', () => {
  it('parses HTTPS URL', () => {
    const result = parseGitHubUrl('https://github.com/owner/repo.git');
    expect(result).toEqual({ owner: 'owner', repo: 'repo' });
  });

  it('parses HTTPS URL without .git suffix', () => {
    const result = parseGitHubUrl('https://github.com/owner/repo');
    expect(result).toEqual({ owner: 'owner', repo: 'repo' });
  });

  it('parses SSH URL', () => {
    const result = parseGitHubUrl('git@github.com:owner/repo.git');
    expect(result).toEqual({ owner: 'owner', repo: 'repo' });
  });

  it('returns null for non-GitHub URL', () => {
    expect(parseGitHubUrl('https://gitlab.com/owner/repo.git')).toBeNull();
  });

  it('returns null for invalid URL', () => {
    expect(parseGitHubUrl('not a url')).toBeNull();
  });
});

describe('isPathInSubmodule', () => {
  const submodules: DiscoveredSubmodule[] = [
    {
      name: 'frontend',
      path: 'packages/frontend',
      url: 'https://github.com/org/frontend.git',
      canScan: true,
      requiresAuth: false,
      scanned: false,
      initiatives: [],
      contextPaths: [],
    },
    {
      name: 'shared',
      path: 'shared',
      url: 'https://github.com/org/shared.git',
      canScan: true,
      requiresAuth: false,
      scanned: false,
      initiatives: [],
      contextPaths: [],
    },
  ];

  it('detects path inside submodule', () => {
    const result = isPathInSubmodule('packages/frontend/src/index.ts', submodules);
    expect(result?.name).toBe('frontend');
  });

  it('detects exact submodule path', () => {
    const result = isPathInSubmodule('shared', submodules);
    expect(result?.name).toBe('shared');
  });

  it('returns null for path outside submodules', () => {
    const result = isPathInSubmodule('src/app/page.tsx', submodules);
    expect(result).toBeNull();
  });

  it('handles empty submodules array', () => {
    const result = isPathInSubmodule('any/path', []);
    expect(result).toBeNull();
  });
});

describe('getSubmoduleRelativePath', () => {
  const submodule: DiscoveredSubmodule = {
    name: 'frontend',
    path: 'packages/frontend',
    url: 'https://github.com/org/frontend.git',
    canScan: true,
    requiresAuth: false,
    scanned: false,
    initiatives: [],
    contextPaths: [],
  };

  it('returns relative path within submodule', () => {
    const result = getSubmoduleRelativePath('packages/frontend/src/index.ts', submodule);
    expect(result).toBe('src/index.ts');
  });

  it('returns empty string for exact submodule path', () => {
    const result = getSubmoduleRelativePath('packages/frontend', submodule);
    expect(result).toBe('');
  });

  it('handles nested paths', () => {
    const result = getSubmoduleRelativePath(
      'packages/frontend/src/components/prototypes/Feature.tsx',
      submodule
    );
    expect(result).toBe('src/components/prototypes/Feature.tsx');
  });
});

describe('detectSubmodules', () => {
  it('returns empty array when .gitmodules not in tree', async () => {
    const mockOctokit = {} as any;

    const result = await detectSubmodules({
      owner: 'test',
      repo: 'repo',
      branch: 'main',
      octokit: mockOctokit,
      treeEntries: [
        { path: 'src', type: 'tree' },
        { path: 'README.md', type: 'blob' },
      ],
    });

    expect(result).toHaveLength(0);
  });

  it('parses submodules when .gitmodules exists', async () => {
    const gitmodulesContent = Buffer.from(
      `[submodule "frontend"]
	path = frontend
	url = https://github.com/org/frontend.git`
    ).toString('base64');

    const mockOctokit = {
      repos: {
        getContent: vi.fn().mockResolvedValue({
          data: { content: gitmodulesContent },
        }),
      },
    } as any;

    const result = await detectSubmodules({
      owner: 'org',
      repo: 'repo',
      branch: 'main',
      octokit: mockOctokit,
      treeEntries: [
        { path: '.gitmodules', type: 'blob' },
        { path: 'frontend', type: 'tree' },
      ],
    });

    expect(result).toHaveLength(1);
    expect(result[0].name).toBe('frontend');
    expect(result[0].path).toBe('frontend');
    expect(result[0].requiresAuth).toBe(false); // Same org
    expect(result[0].scanned).toBe(false);
  });

  it('marks cross-org submodules as requiring auth', async () => {
    const gitmodulesContent = Buffer.from(
      `[submodule "external"]
	path = external
	url = https://github.com/other-org/external.git`
    ).toString('base64');

    const mockOctokit = {
      repos: {
        getContent: vi.fn().mockResolvedValue({
          data: { content: gitmodulesContent },
        }),
      },
    } as any;

    const result = await detectSubmodules({
      owner: 'my-org',
      repo: 'repo',
      branch: 'main',
      octokit: mockOctokit,
      treeEntries: [{ path: '.gitmodules', type: 'blob' }],
    });

    expect(result).toHaveLength(1);
    expect(result[0].requiresAuth).toBe(true); // Different org
  });
});
```
  </action>
  <verify>Run `npm test -- submodule-detector` - all tests should pass</verify>
  <done>Barrel file exports submodule detector, tests pass</done>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit`
- Tests pass: `npm test -- submodule-detector`
- Exports available: `import { detectSubmodules, parseGitmodules } from '@/lib/discovery'`
</verification>

<success_criteria>
- Submodule types defined in types.ts
- parseGitmodules() correctly parses .gitmodules format
- detectSubmodules() identifies submodules via tree API and .gitmodules
- Helper functions (isPathInSubmodule, getSubmoduleRelativePath, parseGitHubUrl) work
- Cross-org submodules flagged as requiresAuth
- All tests pass
- Module exported from barrel file
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversational-discovery-a-submodule-support/04-02-SUMMARY.md`
</output>
