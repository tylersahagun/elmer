---
phase: 04-conversational-discovery-a-submodule-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/discovery/ambiguity-detector.ts
  - src/lib/discovery/types.ts
  - src/lib/discovery/index.ts
autonomous: true

must_haves:
  truths:
    - "Scanner detects when multiple initiative folders exist at same level"
    - "Scanner identifies ambiguous status mappings that need user input"
    - "Ambiguity information is included in discovery result"
  artifacts:
    - path: "src/lib/discovery/ambiguity-detector.ts"
      provides: "Ambiguity detection logic"
      exports: ["detectAmbiguities", "AmbiguityType", "DiscoveryAmbiguity"]
    - path: "src/lib/discovery/types.ts"
      provides: "Extended types for ambiguity"
      contains: "DiscoveryAmbiguity"
  key_links:
    - from: "src/lib/discovery/ambiguity-detector.ts"
      to: "src/lib/discovery/types.ts"
      via: "type imports"
      pattern: "import.*DiscoveryAmbiguity"
---

<objective>
Implement ambiguity detection for repository scanning that identifies situations requiring user clarification.

Purpose: When a repository has multiple potential initiative folders (e.g., both /features/ and /work/), the system needs to detect this ambiguity so it can ask the user which one to use.

Output: Ambiguity detector module that analyzes discovery results and identifies situations needing user input.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/discovery/types.ts
@src/lib/discovery/scanner.ts
@src/lib/discovery/patterns.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ambiguity type definitions</name>
  <files>src/lib/discovery/types.ts</files>
  <action>
Add new types for ambiguity detection to the existing types file:

```typescript
/**
 * Types of ambiguities that require user clarification
 */
export type AmbiguityType =
  | 'multiple_initiative_folders'  // Found /features/ AND /work/
  | 'multiple_context_paths'       // Found /docs/ AND /knowledge/
  | 'ambiguous_status_mapping'     // Status could map to multiple columns
  | 'nested_structure'             // Found initiatives inside initiatives
  | 'submodule_detected';          // Submodule found, need to confirm scan

/**
 * A detected ambiguity requiring user input
 */
export interface DiscoveryAmbiguity {
  id: string;                      // Unique ID for this ambiguity
  type: AmbiguityType;
  question: string;                // Human-readable question to ask
  options: AmbiguityOption[];      // Possible answers
  context: {                       // Additional context for UI
    paths?: string[];              // Relevant file paths
    confidence?: number;           // How confident we are in our guess
  };
  resolved: boolean;               // Has user answered?
  selectedOptionId?: string;       // User's choice
}

/**
 * An option for resolving an ambiguity
 */
export interface AmbiguityOption {
  id: string;
  label: string;                   // Display text
  description?: string;            // Additional explanation
  value: unknown;                  // The value to use if selected
  recommended?: boolean;           // Is this the suggested option?
}

/**
 * Extended discovery result with ambiguities
 */
export interface DiscoveryResultWithAmbiguities extends DiscoveryResult {
  ambiguities: DiscoveryAmbiguity[];
}
```

Do NOT remove any existing types. Add these new types at the end of the file.
  </action>
  <verify>Run `npx tsc --noEmit` - types should compile without errors</verify>
  <done>New ambiguity types exported from types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create ambiguity detector module</name>
  <files>src/lib/discovery/ambiguity-detector.ts</files>
  <action>
Create a new module that analyzes discovery results and identifies ambiguities:

```typescript
/**
 * Ambiguity Detector Module
 *
 * Analyzes discovery results to identify situations requiring user clarification.
 * Implements CONV-01 (system asks clarifying questions when structure is ambiguous).
 */

import type {
  DiscoveryResult,
  DiscoveredInitiative,
  DiscoveredContextPath,
  DiscoveryAmbiguity,
  AmbiguityType,
  AmbiguityOption,
} from './types';
import { INITIATIVE_PATTERNS } from './patterns';

/**
 * Generate a unique ID for an ambiguity
 */
function generateAmbiguityId(type: AmbiguityType, paths: string[]): string {
  const hash = paths.sort().join('|');
  return `amb_${type}_${hash.slice(0, 16)}`;
}

/**
 * Detect multiple initiative folder ambiguity
 *
 * Triggered when repo has multiple top-level folders matching initiative patterns
 * (e.g., both /features/ and /work/)
 */
function detectMultipleInitiativeFolders(
  result: DiscoveryResult
): DiscoveryAmbiguity | null {
  // Group initiatives by their source folder
  const sourceFolders = new Set(
    result.initiatives.map(i => i.sourceFolder)
  );

  if (sourceFolders.size <= 1) {
    return null;
  }

  const folders = Array.from(sourceFolders);

  // Build options for each folder
  const options: AmbiguityOption[] = folders.map(folder => {
    const count = result.initiatives.filter(i => i.sourceFolder === folder).length;
    return {
      id: folder.replace(/\//g, '_'),
      label: `/${folder}/`,
      description: `Contains ${count} initiative${count === 1 ? '' : 's'}`,
      value: folder,
      recommended: folder.toLowerCase() === 'initiatives', // Recommend canonical name
    };
  });

  // Add "use both" option
  options.push({
    id: 'use_all',
    label: 'Use all folders',
    description: `Import from all ${folders.length} folders`,
    value: folders,
    recommended: false,
  });

  return {
    id: generateAmbiguityId('multiple_initiative_folders', folders),
    type: 'multiple_initiative_folders',
    question: `I found multiple folders that could contain your initiatives: ${folders.map(f => '/' + f + '/').join(' and ')}. Which one contains your main work?`,
    options,
    context: {
      paths: folders,
      confidence: 0.5,
    },
    resolved: false,
  };
}

/**
 * Detect multiple context path ambiguity for the same type
 *
 * Triggered when repo has multiple folders for the same context type
 * (e.g., both /docs/ and /knowledge/ for knowledge base)
 */
function detectMultipleContextPaths(
  result: DiscoveryResult
): DiscoveryAmbiguity[] {
  const ambiguities: DiscoveryAmbiguity[] = [];

  // Group by type
  const byType = new Map<string, DiscoveredContextPath[]>();
  for (const cp of result.contextPaths) {
    const existing = byType.get(cp.type) || [];
    existing.push(cp);
    byType.set(cp.type, existing);
  }

  for (const [type, paths] of byType) {
    if (paths.length <= 1) continue;

    const pathStrings = paths.map(p => p.path);
    const options: AmbiguityOption[] = paths.map(p => ({
      id: p.path.replace(/\//g, '_'),
      label: `/${p.path}/`,
      description: `${p.fileCount} file${p.fileCount === 1 ? '' : 's'} found`,
      value: p.path,
      recommended: p.confidence > 0.8,
    }));

    // Add "use primary" option with highest confidence
    const primary = paths.reduce((a, b) => a.confidence > b.confidence ? a : b);

    ambiguities.push({
      id: generateAmbiguityId('multiple_context_paths', pathStrings),
      type: 'multiple_context_paths',
      question: `I found multiple ${type} folders: ${pathStrings.map(p => '/' + p + '/').join(' and ')}. Which one should I use?`,
      options,
      context: {
        paths: pathStrings,
        confidence: primary.confidence,
      },
      resolved: false,
    });
  }

  return ambiguities;
}

/**
 * Detect ambiguous status mappings in initiatives
 *
 * Collects all initiatives with isStatusAmbiguous flag
 */
function detectAmbiguousStatuses(
  result: DiscoveryResult
): DiscoveryAmbiguity[] {
  const ambiguous = result.initiatives.filter(i => i.isStatusAmbiguous);

  if (ambiguous.length === 0) {
    return [];
  }

  // Group by similar status values
  const byStatus = new Map<string, DiscoveredInitiative[]>();
  for (const init of ambiguous) {
    const status = init.status || 'unknown';
    const existing = byStatus.get(status) || [];
    existing.push(init);
    byStatus.set(status, existing);
  }

  const ambiguities: DiscoveryAmbiguity[] = [];

  for (const [status, initiatives] of byStatus) {
    const paths = initiatives.map(i => i.sourcePath);

    // Create column options based on common mappings
    const columnOptions: AmbiguityOption[] = [
      { id: 'inbox', label: 'Inbox', description: 'New/incoming items', value: 'inbox' },
      { id: 'discovery', label: 'Discovery', description: 'Being researched', value: 'discovery' },
      { id: 'prd', label: 'PRD', description: 'Writing requirements', value: 'prd' },
      { id: 'design', label: 'Design', description: 'In design phase', value: 'design' },
      { id: 'prototype', label: 'Prototype', description: 'Building prototype', value: 'prototype' },
      { id: 'validate', label: 'Validate', description: 'User testing', value: 'validate' },
      { id: 'tickets', label: 'Tickets', description: 'Ready for engineering', value: 'tickets' },
      { id: 'shipped', label: 'Shipped', description: 'Released', value: 'shipped' },
    ];

    ambiguities.push({
      id: generateAmbiguityId('ambiguous_status_mapping', paths),
      type: 'ambiguous_status_mapping',
      question: `The status "${status}" could map to multiple columns. Where should ${initiatives.length === 1 ? `"${initiatives[0].name}"` : `these ${initiatives.length} items`} go?`,
      options: columnOptions,
      context: {
        paths,
        confidence: 0.3,
      },
      resolved: false,
    });
  }

  return ambiguities;
}

/**
 * Main entry point: analyze discovery result and return all ambiguities
 */
export function detectAmbiguities(
  result: DiscoveryResult
): DiscoveryAmbiguity[] {
  const ambiguities: DiscoveryAmbiguity[] = [];

  // Check for multiple initiative folders
  const multipleInitiatives = detectMultipleInitiativeFolders(result);
  if (multipleInitiatives) {
    ambiguities.push(multipleInitiatives);
  }

  // Check for multiple context paths of same type
  ambiguities.push(...detectMultipleContextPaths(result));

  // Check for ambiguous status mappings
  ambiguities.push(...detectAmbiguousStatuses(result));

  return ambiguities;
}

/**
 * Check if discovery result has any unresolved ambiguities
 */
export function hasUnresolvedAmbiguities(
  ambiguities: DiscoveryAmbiguity[]
): boolean {
  return ambiguities.some(a => !a.resolved);
}

/**
 * Get the next unresolved ambiguity (for conversation flow)
 */
export function getNextAmbiguity(
  ambiguities: DiscoveryAmbiguity[]
): DiscoveryAmbiguity | null {
  return ambiguities.find(a => !a.resolved) || null;
}

/**
 * Apply a user's resolution to an ambiguity
 * Returns updated ambiguity with resolved=true
 */
export function resolveAmbiguity(
  ambiguity: DiscoveryAmbiguity,
  selectedOptionId: string
): DiscoveryAmbiguity {
  return {
    ...ambiguity,
    resolved: true,
    selectedOptionId,
  };
}

// Re-export types for consumers
export type { DiscoveryAmbiguity, AmbiguityType, AmbiguityOption };
```
  </action>
  <verify>Run `npx tsc --noEmit` - module should compile without errors</verify>
  <done>Ambiguity detector module created with detectAmbiguities function</done>
</task>

<task type="auto">
  <name>Task 3: Export from barrel file and add tests</name>
  <files>src/lib/discovery/index.ts, src/lib/discovery/__tests__/ambiguity-detector.test.ts</files>
  <action>
1. Update barrel file to export new module:

Add to `src/lib/discovery/index.ts`:
```typescript
export * from './ambiguity-detector';
```

2. Create test file `src/lib/discovery/__tests__/ambiguity-detector.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  detectAmbiguities,
  hasUnresolvedAmbiguities,
  getNextAmbiguity,
  resolveAmbiguity,
} from '../ambiguity-detector';
import type { DiscoveryResult } from '../types';

function createMockResult(overrides: Partial<DiscoveryResult> = {}): DiscoveryResult {
  return {
    repoOwner: 'test',
    repoName: 'repo',
    branch: 'main',
    scannedAt: new Date().toISOString(),
    initiatives: [],
    contextPaths: [],
    agents: [],
    stats: {
      foldersScanned: 0,
      initiativesFound: 0,
      contextPathsFound: 0,
      agentsFound: 0,
      metaJsonParsed: 0,
      metaJsonErrors: 0,
    },
    warnings: [],
    ...overrides,
  };
}

describe('detectAmbiguities', () => {
  it('returns empty array when no ambiguities', () => {
    const result = createMockResult({
      initiatives: [{
        id: 'proj_1',
        sourcePath: 'initiatives/feature-a',
        sourceFolder: 'initiatives',
        name: 'Feature A',
        status: 'active',
        mappedColumn: 'discovery',
        statusConfidence: 1,
        isStatusAmbiguous: false,
        description: null,
        archived: false,
        tags: [],
        rawMeta: null,
        patternMatch: { pattern: 'initiatives', matchType: 'exact', confidence: 1 },
        selected: true,
      }],
    });

    const ambiguities = detectAmbiguities(result);
    expect(ambiguities).toHaveLength(0);
  });

  it('detects multiple initiative folders', () => {
    const result = createMockResult({
      initiatives: [
        {
          id: 'proj_1',
          sourcePath: 'initiatives/feature-a',
          sourceFolder: 'initiatives',
          name: 'Feature A',
          status: 'active',
          mappedColumn: 'discovery',
          statusConfidence: 1,
          isStatusAmbiguous: false,
          description: null,
          archived: false,
          tags: [],
          rawMeta: null,
          patternMatch: { pattern: 'initiatives', matchType: 'exact', confidence: 1 },
          selected: true,
        },
        {
          id: 'proj_2',
          sourcePath: 'work/project-b',
          sourceFolder: 'work',
          name: 'Project B',
          status: 'active',
          mappedColumn: 'discovery',
          statusConfidence: 1,
          isStatusAmbiguous: false,
          description: null,
          archived: false,
          tags: [],
          rawMeta: null,
          patternMatch: { pattern: 'work', matchType: 'exact', confidence: 0.8 },
          selected: true,
        },
      ],
    });

    const ambiguities = detectAmbiguities(result);
    expect(ambiguities).toHaveLength(1);
    expect(ambiguities[0].type).toBe('multiple_initiative_folders');
    expect(ambiguities[0].question).toContain('initiatives');
    expect(ambiguities[0].question).toContain('work');
    expect(ambiguities[0].options.length).toBeGreaterThanOrEqual(3); // 2 folders + "use all"
  });

  it('detects multiple context paths of same type', () => {
    const result = createMockResult({
      contextPaths: [
        { type: 'knowledge', path: 'docs', confidence: 0.8, fileCount: 10, selected: true },
        { type: 'knowledge', path: 'knowledge', confidence: 0.9, fileCount: 5, selected: true },
      ],
    });

    const ambiguities = detectAmbiguities(result);
    expect(ambiguities).toHaveLength(1);
    expect(ambiguities[0].type).toBe('multiple_context_paths');
    expect(ambiguities[0].question).toContain('knowledge');
  });

  it('detects ambiguous status mappings', () => {
    const result = createMockResult({
      initiatives: [{
        id: 'proj_1',
        sourcePath: 'initiatives/feature-a',
        sourceFolder: 'initiatives',
        name: 'Feature A',
        status: 'in-progress',
        mappedColumn: 'discovery',
        statusConfidence: 0.3,
        isStatusAmbiguous: true,
        description: null,
        archived: false,
        tags: [],
        rawMeta: null,
        patternMatch: { pattern: 'initiatives', matchType: 'exact', confidence: 1 },
        selected: true,
      }],
    });

    const ambiguities = detectAmbiguities(result);
    expect(ambiguities).toHaveLength(1);
    expect(ambiguities[0].type).toBe('ambiguous_status_mapping');
    expect(ambiguities[0].question).toContain('in-progress');
  });
});

describe('hasUnresolvedAmbiguities', () => {
  it('returns false for empty array', () => {
    expect(hasUnresolvedAmbiguities([])).toBe(false);
  });

  it('returns true when unresolved ambiguities exist', () => {
    const ambiguities = [{
      id: 'amb_1',
      type: 'multiple_initiative_folders' as const,
      question: 'Which folder?',
      options: [],
      context: {},
      resolved: false,
    }];
    expect(hasUnresolvedAmbiguities(ambiguities)).toBe(true);
  });

  it('returns false when all resolved', () => {
    const ambiguities = [{
      id: 'amb_1',
      type: 'multiple_initiative_folders' as const,
      question: 'Which folder?',
      options: [],
      context: {},
      resolved: true,
      selectedOptionId: 'opt_1',
    }];
    expect(hasUnresolvedAmbiguities(ambiguities)).toBe(false);
  });
});

describe('getNextAmbiguity', () => {
  it('returns null for empty array', () => {
    expect(getNextAmbiguity([])).toBeNull();
  });

  it('returns first unresolved ambiguity', () => {
    const ambiguities = [
      { id: 'amb_1', type: 'multiple_initiative_folders' as const, question: 'Q1', options: [], context: {}, resolved: true, selectedOptionId: 'opt' },
      { id: 'amb_2', type: 'multiple_context_paths' as const, question: 'Q2', options: [], context: {}, resolved: false },
      { id: 'amb_3', type: 'ambiguous_status_mapping' as const, question: 'Q3', options: [], context: {}, resolved: false },
    ];
    const next = getNextAmbiguity(ambiguities);
    expect(next?.id).toBe('amb_2');
  });
});

describe('resolveAmbiguity', () => {
  it('marks ambiguity as resolved with selected option', () => {
    const ambiguity = {
      id: 'amb_1',
      type: 'multiple_initiative_folders' as const,
      question: 'Which folder?',
      options: [{ id: 'opt_1', label: 'Option 1', value: 'initiatives' }],
      context: {},
      resolved: false,
    };

    const resolved = resolveAmbiguity(ambiguity, 'opt_1');
    expect(resolved.resolved).toBe(true);
    expect(resolved.selectedOptionId).toBe('opt_1');
    // Original should be unchanged
    expect(ambiguity.resolved).toBe(false);
  });
});
```
  </action>
  <verify>Run `npm test -- ambiguity-detector` - all tests should pass</verify>
  <done>Barrel file exports ambiguity detector, tests pass</done>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit`
- Tests pass: `npm test -- ambiguity-detector`
- Exports available: `import { detectAmbiguities } from '@/lib/discovery'`
</verification>

<success_criteria>
- Ambiguity types defined in types.ts
- detectAmbiguities() function detects all three ambiguity types
- Helper functions (hasUnresolvedAmbiguities, getNextAmbiguity, resolveAmbiguity) work correctly
- All tests pass
- Module exported from barrel file
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversational-discovery-a-submodule-support/04-01-SUMMARY.md`
</output>
