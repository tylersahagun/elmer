---
phase: 06-agents-management-a-column-automation
plan: 08
type: execute
wave: 4
depends_on: ["06-07"]
files_modified:
  - src/components/kanban/AutomationStatusBadge.tsx
  - src/components/kanban/ProjectCard.tsx
  - src/hooks/useProjectAutomationStatus.ts
autonomous: true

must_haves:
  truths:
    - "User sees automation execution status inline on project card"
    - "Status shows running/completed/failed state"
    - "User can click to see automation details"
  artifacts:
    - path: "src/components/kanban/AutomationStatusBadge.tsx"
      provides: "Inline automation status indicator"
      exports: ["AutomationStatusBadge"]
    - path: "src/hooks/useProjectAutomationStatus.ts"
      provides: "Hook for fetching project automation status"
      exports: ["useProjectAutomationStatus"]
  key_links:
    - from: "src/components/kanban/ProjectCard.tsx"
      to: "src/components/kanban/AutomationStatusBadge.tsx"
      via: "renders badge conditionally"
      pattern: "AutomationStatusBadge"
---

<objective>
Display automation execution status and results inline on project cards so users can see when automation is running or has completed.

Purpose: Users need visibility into automation status directly on project cards (AUTO-06).

Output: Status badge component integrated into project cards.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns
@src/components/kanban/ProjectCard.tsx (card to add badge to)
@src/components/kanban/JobStatusIndicator.tsx (similar status pattern)
@src/lib/db/schema.ts (jobs table for status)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useProjectAutomationStatus hook</name>
  <files>src/hooks/useProjectAutomationStatus.ts</files>
  <action>
Create hook to fetch recent automation status for a project:

```typescript
"use client";

import { useQuery } from "@tanstack/react-query";

interface AutomationJob {
  id: string;
  status: "queued" | "running" | "succeeded" | "failed";
  agentName: string;
  createdAt: string;
}

interface AutomationStatus {
  hasActiveAutomation: boolean;
  recentJobs: AutomationJob[];
  runningCount: number;
  lastRun: AutomationJob | null;
}

export function useProjectAutomationStatus(
  workspaceId: string,
  projectId: string | null,
  enabled: boolean = true
) {
  return useQuery<AutomationStatus>({
    queryKey: ["project-automation-status", projectId],
    queryFn: async () => {
      if (!projectId) throw new Error("No project ID");
      const res = await fetch(
        `/api/projects/${projectId}/automation-status?workspaceId=${workspaceId}`
      );
      if (!res.ok) throw new Error("Failed to fetch automation status");
      return res.json();
    },
    enabled: enabled && !!projectId,
    refetchInterval: 5000, // Poll every 5 seconds for active automations
    staleTime: 2000,
  });
}
```

This hook will poll for status updates while automation is running.
  </action>
  <verify>Hook compiles without errors</verify>
  <done>Hook for fetching automation status exists</done>
</task>

<task type="auto">
  <name>Task 2: Create automation status API endpoint</name>
  <files>src/app/api/projects/[id]/automation-status/route.ts</files>
  <action>
Create API endpoint to get recent automation jobs for a project:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { jobs, agentDefinitions } from "@/lib/db/schema";
import { eq, and, desc, gte } from "drizzle-orm";
import { requireWorkspaceAccess, handlePermissionError, PermissionError } from "@/lib/permissions";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: projectId } = await params;
    const { searchParams } = new URL(request.url);
    const workspaceId = searchParams.get("workspaceId");

    if (!workspaceId) {
      return NextResponse.json({ error: "workspaceId required" }, { status: 400 });
    }

    await requireWorkspaceAccess(workspaceId, "viewer");

    // Get jobs from last hour triggered by column automation
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

    const recentJobs = await db
      .select({
        id: jobs.id,
        status: jobs.status,
        createdAt: jobs.createdAt,
        input: jobs.input,
      })
      .from(jobs)
      .where(and(
        eq(jobs.projectId, projectId),
        eq(jobs.type, "execute_agent_definition"),
        gte(jobs.createdAt, oneHourAgo)
      ))
      .orderBy(desc(jobs.createdAt))
      .limit(5);

    // Enrich with agent names
    const enrichedJobs = await Promise.all(
      recentJobs.map(async (job) => {
        const input = job.input as Record<string, unknown>;
        const agentId = input?.agentDefinitionId as string;
        let agentName = "Unknown Agent";

        if (agentId) {
          const agent = await db.query.agentDefinitions.findFirst({
            where: eq(agentDefinitions.id, agentId),
            columns: { name: true }
          });
          agentName = agent?.name || agentName;
        }

        return {
          id: job.id,
          status: job.status,
          agentName,
          createdAt: job.createdAt?.toISOString(),
        };
      })
    );

    const runningCount = enrichedJobs.filter(
      j => j.status === "queued" || j.status === "running"
    ).length;

    return NextResponse.json({
      hasActiveAutomation: runningCount > 0,
      recentJobs: enrichedJobs,
      runningCount,
      lastRun: enrichedJobs[0] || null,
    });
  } catch (error) {
    if (error instanceof PermissionError) {
      const { error: message, status } = handlePermissionError(error);
      return NextResponse.json({ error: message }, { status });
    }
    console.error("Failed to fetch automation status:", error);
    return NextResponse.json({ error: "Failed to fetch status" }, { status: 500 });
  }
}
```
  </action>
  <verify>GET /api/projects/[id]/automation-status returns job status</verify>
  <done>Automation status API endpoint exists</done>
</task>

<task type="auto">
  <name>Task 3: Create AutomationStatusBadge and integrate into ProjectCard</name>
  <files>
    src/components/kanban/AutomationStatusBadge.tsx
    src/components/kanban/ProjectCard.tsx
  </files>
  <action>
**AutomationStatusBadge.tsx:**
```typescript
"use client";

import { cn } from "@/lib/utils";
import { Loader2, CheckCircle2, XCircle, Zap } from "lucide-react";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

interface AutomationStatusBadgeProps {
  hasActive: boolean;
  runningCount: number;
  lastStatus?: "succeeded" | "failed" | "queued" | "running";
  lastAgentName?: string;
  onClick?: () => void;
}

export function AutomationStatusBadge({
  hasActive,
  runningCount,
  lastStatus,
  lastAgentName,
  onClick
}: AutomationStatusBadgeProps) {
  if (!hasActive && !lastStatus) return null;

  const isRunning = hasActive || lastStatus === "running" || lastStatus === "queued";
  const succeeded = lastStatus === "succeeded";
  const failed = lastStatus === "failed";

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <button
            onClick={onClick}
            className={cn(
              "flex items-center gap-1 px-1.5 py-0.5 rounded-full text-xs font-medium transition-colors",
              isRunning && "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400",
              succeeded && "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400",
              failed && "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400"
            )}
          >
            {isRunning && <Loader2 className="w-3 h-3 animate-spin" />}
            {succeeded && <CheckCircle2 className="w-3 h-3" />}
            {failed && <XCircle className="w-3 h-3" />}
            {runningCount > 1 && <span>{runningCount}</span>}
            {!isRunning && <Zap className="w-3 h-3" />}
          </button>
        </TooltipTrigger>
        <TooltipContent side="top">
          <p>
            {isRunning && `Running: ${lastAgentName || "automation"}`}
            {succeeded && `Completed: ${lastAgentName || "automation"}`}
            {failed && `Failed: ${lastAgentName || "automation"}`}
          </p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
```

**ProjectCard.tsx update:**
1. Import useProjectAutomationStatus and AutomationStatusBadge
2. In the card header area (near the stage/status badges), add:
```tsx
const { data: automationStatus } = useProjectAutomationStatus(
  workspaceId,
  project.id,
  true // or some condition to enable
);

// In render, near other badges:
{automationStatus?.hasActiveAutomation || automationStatus?.lastRun ? (
  <AutomationStatusBadge
    hasActive={automationStatus.hasActiveAutomation}
    runningCount={automationStatus.runningCount}
    lastStatus={automationStatus.lastRun?.status}
    lastAgentName={automationStatus.lastRun?.agentName}
    onClick={() => openJobLogs(automationStatus.lastRun?.id)}
  />
) : null}
```
3. Connect onClick to open job logs drawer via existing useJobLogsStore
  </action>
  <verify>Project cards show automation status badge when automation runs</verify>
  <done>Automation status displays inline on project cards</done>
</task>

</tasks>

<verification>
1. Configure column automation and drag project to that column
2. See spinning loader badge on project card
3. Badge updates to checkmark when complete
4. Badge shows X if automation failed
5. Click badge opens job logs
6. Badge disappears after ~1 hour of no activity
</verification>

<success_criteria>
- AUTO-06: User sees automation execution status and results inline on project card
- Status badge shows running/completed/failed state
- Badge is clickable to see details
- Polling updates status in real-time
</success_criteria>

<output>
After completion, create `.planning/phases/06-agents-management-a-column-automation/06-08-SUMMARY.md`
</output>
