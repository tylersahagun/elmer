---
phase: 06-agents-management-a-column-automation
plan: 07
type: execute
wave: 3
depends_on: ["06-06"]
files_modified:
  - src/lib/automation/column-automation.ts
  - src/app/api/projects/[id]/route.ts
  - src/lib/db/schema.ts
autonomous: true

must_haves:
  truths:
    - "When project is dragged to column, configured auto-runs execute automatically"
    - "System prevents infinite loops"
    - "Automation only triggers on actual column changes"
  artifacts:
    - path: "src/lib/automation/column-automation.ts"
      provides: "Column automation trigger logic"
      exports: ["triggerColumnAutomation", "isAutomationLoop"]
  key_links:
    - from: "src/app/api/projects/[id]/route.ts"
      to: "src/lib/automation/column-automation.ts"
      via: "call on stage change"
      pattern: "triggerColumnAutomation"
    - from: "src/lib/automation/column-automation.ts"
      to: "/api/agents/execute"
      via: "creates agent jobs"
      pattern: "createJob"
---

<objective>
Implement the automation trigger logic that executes configured agents when projects are moved to columns.

Purpose: Automation runs automatically when projects are dragged to configured columns (AUTO-02, AUTO-05).

Output: Backend logic that triggers agent executions on stage changes with loop prevention.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns
@src/lib/automation/signal-automation.ts (automation pattern reference)
@src/app/api/projects/[id]/route.ts (project update endpoint)
@src/lib/db/schema.ts (stageTransitionEvents for audit)
@src/lib/db/queries.ts (getColumnConfigs)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create column automation service</name>
  <files>src/lib/automation/column-automation.ts</files>
  <action>
Create the column automation trigger service:

```typescript
/**
 * Column Automation Service
 *
 * Triggers configured agent executions when projects move to new columns.
 * Includes loop prevention to avoid infinite automation cycles.
 */

import { getColumnConfigs, createJob, getAgentDefinitionById } from "@/lib/db/queries";
import { db } from "@/lib/db";
import { stageTransitionEvents } from "@/lib/db/schema";
import { eq, and, gte } from "drizzle-orm";
import { nanoid } from "nanoid";
import type { ProjectStage } from "@/lib/db/schema";

const LOOP_PREVENTION_WINDOW_MS = 60000; // 1 minute
const MAX_TRIGGERS_IN_WINDOW = 3;

interface AutomationTriggerResult {
  triggered: boolean;
  jobIds: string[];
  skipped: string[];
  blocked?: "loop_prevention" | "no_triggers" | "disabled";
}

/**
 * Check if triggering automation would create a loop
 */
export async function isAutomationLoop(
  projectId: string,
  toStage: ProjectStage
): Promise<boolean> {
  const windowStart = new Date(Date.now() - LOOP_PREVENTION_WINDOW_MS);

  const recentTransitions = await db
    .select({ count: sql<number>`count(*)` })
    .from(stageTransitionEvents)
    .where(and(
      eq(stageTransitionEvents.cardId, projectId),
      eq(stageTransitionEvents.toStage, toStage),
      eq(stageTransitionEvents.actor, "automation"),
      gte(stageTransitionEvents.timestamp, windowStart)
    ));

  return Number(recentTransitions[0]?.count || 0) >= MAX_TRIGGERS_IN_WINDOW;
}

/**
 * Trigger column automation for a project stage change
 */
export async function triggerColumnAutomation(
  workspaceId: string,
  projectId: string,
  toStage: ProjectStage,
  triggeredBy: string // "user:{id}" | "automation"
): Promise<AutomationTriggerResult> {
  // Check for automation loops
  if (triggeredBy === "automation" && await isAutomationLoop(projectId, toStage)) {
    console.log(`[ColumnAutomation] Loop prevention: skipping automation for project ${projectId} -> ${toStage}`);
    return { triggered: false, jobIds: [], skipped: [], blocked: "loop_prevention" };
  }

  // Get column config for target stage
  const columns = await getColumnConfigs(workspaceId);
  const targetColumn = columns.find(c => c.stage === toStage);

  if (!targetColumn?.agentTriggers?.length) {
    return { triggered: false, jobIds: [], skipped: [], blocked: "no_triggers" };
  }

  const jobIds: string[] = [];
  const skipped: string[] = [];

  // Sort triggers by priority
  const sortedTriggers = [...targetColumn.agentTriggers].sort((a, b) => a.priority - b.priority);

  for (const trigger of sortedTriggers) {
    if (!trigger.enabled) {
      skipped.push(trigger.agentDefinitionId);
      continue;
    }

    // Verify agent exists and is enabled
    const agent = await getAgentDefinitionById(trigger.agentDefinitionId);
    if (!agent || agent.enabled === false) {
      skipped.push(trigger.agentDefinitionId);
      continue;
    }

    // Create job for agent execution
    const job = await createJob({
      workspaceId,
      projectId,
      type: "execute_agent_definition",
      input: {
        agentDefinitionId: trigger.agentDefinitionId,
        triggeredBy: "column_automation",
        fromStage: undefined, // Could add fromStage tracking
        toStage,
      },
    });

    if (job?.id) {
      jobIds.push(job.id);
    }
  }

  // Record transition event
  await db.insert(stageTransitionEvents).values({
    id: nanoid(),
    cardId: projectId,
    workspaceId,
    toStage,
    actor: triggeredBy.startsWith("user:") ? triggeredBy : "automation",
    reason: jobIds.length > 0 ? `Triggered ${jobIds.length} automation(s)` : "No automations triggered",
    timestamp: new Date(),
  });

  return {
    triggered: jobIds.length > 0,
    jobIds,
    skipped,
  };
}
```

Import sql from drizzle-orm for the count query.
  </action>
  <verify>Module exports triggerColumnAutomation and isAutomationLoop</verify>
  <done>Column automation service with loop prevention exists</done>
</task>

<task type="auto">
  <name>Task 2: Wire automation into project update endpoint</name>
  <files>src/app/api/projects/[id]/route.ts</files>
  <action>
Update the PATCH handler to trigger column automation on stage changes:

1. In the PATCH handler, detect stage changes:
```typescript
const existingProject = await getProjectById(id);
const isStageChange = body.stage && body.stage !== existingProject?.stage;
```

2. After updating the project, trigger automation:
```typescript
if (isStageChange && body.stage) {
  const { session } = await requireWorkspaceAccess(project.workspaceId, "editor");
  const triggeredBy = `user:${session.user.id}`;

  // Use after() for non-blocking execution
  after(async () => {
    try {
      const result = await triggerColumnAutomation(
        project.workspaceId,
        id,
        body.stage,
        triggeredBy
      );
      if (result.triggered) {
        console.log(`[ColumnAutomation] Triggered ${result.jobIds.length} jobs for project ${id}`);
      }
    } catch (error) {
      console.error("[ColumnAutomation] Error triggering automation:", error);
    }
  });
}
```

3. Add import for triggerColumnAutomation and after from next/server.
  </action>
  <verify>Dragging project to column with automation creates jobs</verify>
  <done>Stage changes trigger column automation</done>
</task>

<task type="auto">
  <name>Task 3: Add automation tracking to stage transition events</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Verify stageTransitionEvents table has necessary fields. If missing, add:

1. Check if `automationJobIds` field exists for tracking which jobs were triggered
2. If not present, add to schema:
```typescript
automationJobIds: jsonb("automation_job_ids").$type<string[]>(),
```

This allows the UI to show which automations ran for each transition.
  </action>
  <verify>Schema has field for tracking automation jobs</verify>
  <done>Stage transition events can track automation job IDs</done>
</task>

</tasks>

<verification>
1. Configure column to trigger agent on entry
2. Drag project to that column
3. Check jobs list - new job created for agent
4. Verify stageTransitionEvents has record
5. Move project rapidly multiple times - loop prevention kicks in
</verification>

<success_criteria>
- AUTO-02: When project is dragged to column, configured auto-runs execute automatically
- AUTO-05: System prevents infinite loops (project moving triggers automation that moves project again)
- Automation jobs are created and tracked
- Non-blocking execution via after()
</success_criteria>

<output>
After completion, create `.planning/phases/06-agents-management-a-column-automation/06-07-SUMMARY.md`
</output>
