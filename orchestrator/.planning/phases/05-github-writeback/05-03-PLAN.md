---
phase: 05-github-writeback
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/lib/execution/stage-executors/prd-executor.ts
  - src/lib/github/writeback-service.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PRD documents are committed to GitHub after generation"
    - "Design brief, engineering spec, and GTM brief are also committed"
    - "Document updates commit changes to GitHub"
    - "Commits are recorded in project_commits table"
  artifacts:
    - path: "src/lib/execution/stage-executors/prd-executor.ts"
      provides: "PRD executor with GitHub writeback"
      contains: "commitToGitHub"
      min_lines: 200
  key_links:
    - from: "src/lib/execution/stage-executors/prd-executor.ts"
      to: "src/lib/github/writeback-service.ts"
      via: "import and function call"
      pattern: "commitToGitHub"
    - from: "src/lib/execution/stage-executors/prd-executor.ts"
      to: "src/lib/db/queries.ts"
      via: "recordProjectCommit call"
      pattern: "recordProjectCommit"
---

<objective>
Integrate GitHub writeback into the PRD executor so that generated PRD documents (prd.md, design-brief.md, engineering-spec.md, gtm-brief.md) are automatically committed to GitHub.

Purpose: Implements WRITE-01 (PRD commits), WRITE-03 (document updates commit), WRITE-04 (atomic commit pattern), WRITE-05 (work in GitHub, not just database), and WRITE-06 (commits linked to project).

Output:
- PRD executor writes documents to GitHub after database save
- Each document type gets its own atomic commit
- Commit history is recorded in project_commits table
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs (Wave 1)
@.planning/phases/05-github-writeback/05-01-PLAN.md
@.planning/phases/05-github-writeback/05-02-PLAN.md

# Current PRD executor
@src/lib/execution/stage-executors/prd-executor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add authentication context to writeback service</name>
  <files>src/lib/github/writeback-service.ts</files>
  <action>
Update the writeback service to accept an authentication context (userId) since the GitHub API calls require authentication. Modify `commitToGitHub` to accept a `userId` parameter and use the getGitHubClient function.

Add these imports at the top:
```typescript
import { getGitHubClient } from "./auth";
```

Modify the `commitToGitHub` function signature and implementation:

```typescript
/**
 * Commits files to GitHub using authenticated Octokit client.
 * Records the operation in githubWriteOps for tracking.
 */
export async function commitToGitHub(
  config: WritebackConfig,
  files: WritebackFile[],
  metadata: CommitMetadata,
  userId: string,  // Required for authentication
  action: "add" | "update" = "add"
): Promise<WritebackResult> {
  const message = generateCommitMessage(metadata, action);
  const opId = `ghop_${nanoid()}`;

  try {
    // Get authenticated GitHub client
    const octokit = await getGitHubClient(userId);
    if (!octokit) {
      return {
        success: false,
        error: "GitHub not connected. Please reconnect your GitHub account.",
      };
    }

    // Record the operation as "prepared"
    await db.insert(githubWriteOps).values({
      id: opId,
      workspaceId: config.workspaceId,
      repoFullName: `${config.owner}/${config.repo}`,
      baseBranch: config.branch,
      writeBranch: config.branch,
      status: "prepared",
      proposedChanges: {
        files: files.map(f => ({ path: f.path, action })),
        message,
        metadata,
      },
      createdBy: userId,
      createdAt: new Date(),
    });

    // Get current branch ref
    const { data: refData } = await octokit.git.getRef({
      owner: config.owner,
      repo: config.repo,
      ref: `heads/${config.branch}`,
    });

    const parentSha = refData.object.sha;
    const { data: commitData } = await octokit.git.getCommit({
      owner: config.owner,
      repo: config.repo,
      commit_sha: parentSha,
    });

    // Create tree entries for files
    const tree = files.map((file) => ({
      path: file.path,
      mode: "100644" as const,
      type: "blob" as const,
      content: file.content,
    }));

    // Create new tree
    const { data: newTree } = await octokit.git.createTree({
      owner: config.owner,
      repo: config.repo,
      base_tree: commitData.tree.sha,
      tree,
    });

    // Create commit
    const { data: newCommit } = await octokit.git.createCommit({
      owner: config.owner,
      repo: config.repo,
      message,
      tree: newTree.sha,
      parents: [parentSha],
    });

    // Update branch ref
    await octokit.git.updateRef({
      owner: config.owner,
      repo: config.repo,
      ref: `heads/${config.branch}`,
      sha: newCommit.sha,
    });

    // Update operation status to committed
    await db.update(githubWriteOps)
      .set({
        status: "committed",
        commitSha: newCommit.sha,
      })
      .where(eq(githubWriteOps.id, opId));

    return {
      success: true,
      commitSha: newCommit.sha,
      commitUrl: `https://github.com/${config.owner}/${config.repo}/commit/${newCommit.sha}`,
      filesWritten: files.map(f => f.path),
    };
  } catch (error) {
    console.error("[writeback-service] Commit failed:", error);

    // Try to update operation status
    try {
      await db.update(githubWriteOps)
        .set({ status: "failed" })
        .where(eq(githubWriteOps.id, opId));
    } catch {
      // Ignore cleanup errors
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to commit to GitHub",
    };
  }
}
```

Also add a helper function to get the user ID from workspace context (for executors):

```typescript
/**
 * Gets the first admin user ID for a workspace (for automated operations).
 * In production, this should use the actual user context from the stage run.
 */
export async function getWorkspaceUserId(workspaceId: string): Promise<string | null> {
  const member = await db.query.workspaceMembers.findFirst({
    where: eq(workspaceMembers.workspaceId, workspaceId),
    orderBy: (members, { asc }) => [asc(members.joinedAt)],
  });
  return member?.userId || null;
}
```

Add import for `workspaceMembers` from schema.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/lib/github/writeback-service.ts`</verify>
  <done>Writeback service uses direct Octokit calls with proper authentication</done>
</task>

<task type="auto">
  <name>Task 2: Integrate writeback into PRD executor</name>
  <files>src/lib/execution/stage-executors/prd-executor.ts</files>
  <action>
Update the PRD executor to commit documents to GitHub after saving to database. Add the writeback integration after each document is created/updated.

Add imports at the top of the file:
```typescript
import { commitToGitHub, getWritebackConfig, getWorkspaceUserId } from "@/lib/github/writeback-service";
import { resolveDocumentPath } from "@/lib/github/path-resolver";
import { recordProjectCommit } from "@/lib/db/queries";
import type { WritebackFile, CommitMetadata } from "@/lib/github/types";
```

Modify the `createDoc` helper function inside `executePRD` to include writeback:

After the document is saved to database (after the `if (existing) {...} else {...}` block), add:

```typescript
  // Commit to GitHub (WRITE-01, WRITE-03, WRITE-05)
  const writebackConfig = await getWritebackConfig(run.workspaceId, project.id);
  const userId = await getWorkspaceUserId(run.workspaceId);

  if (writebackConfig && userId) {
    const filePath = resolveDocumentPath({
      projectName: project.name,
      documentType: type,
      basePath: writebackConfig.basePath,
    });

    const writebackFile: WritebackFile = {
      path: filePath,
      content: result.output || "",
    };

    const commitMetadata: CommitMetadata = {
      projectId: project.id,
      projectName: project.name,
      documentType: type,
      triggeredBy: "automation",
      stageRunId: run.id,
    };

    callbacks.onLog("info", `Committing ${type} to GitHub: ${filePath}`, "prd");

    const writebackResult = await commitToGitHub(
      writebackConfig,
      [writebackFile],
      commitMetadata,
      userId,
      existing ? "update" : "add"
    );

    if (writebackResult.success) {
      callbacks.onLog("info", `Committed to GitHub: ${writebackResult.commitSha}`, "prd");

      // Record in project commit history (WRITE-06)
      await recordProjectCommit({
        projectId: project.id,
        workspaceId: run.workspaceId,
        commitSha: writebackResult.commitSha!,
        commitUrl: writebackResult.commitUrl!,
        message: `docs(${project.name.toLowerCase().replace(/\s+/g, "-")}): ${existing ? "update" : "add"} ${type.replace(/_/g, "-")}`,
        documentType: type,
        filesChanged: writebackResult.filesWritten,
        triggeredBy: "automation",
        stageRunId: run.id,
      });
    } else {
      callbacks.onLog("warn", `GitHub writeback failed: ${writebackResult.error}`, "prd");
      // Don't fail the entire operation - document is saved locally
    }
  } else {
    callbacks.onLog("info", "GitHub writeback not configured or no user context", "prd");
  }
```

Place this code right before the `createdDocs.push(type);` line in the `createDoc` helper function.

Note: The writeback is non-blocking - if it fails, the document is still saved to the database and the stage execution continues. This ensures resilience while still attempting the writeback.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/execution/stage-executors/prd-executor.ts`

Verify import paths resolve correctly.
  </verify>
  <done>
- PRD executor commits documents to GitHub after database save
- Each document (prd, design_brief, engineering_spec, gtm_brief) is committed individually
- Commit history is recorded in project_commits table
- Writeback failures are logged but don't block stage execution
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles for both modified files
2. PRD executor imports writeback service and path resolver
3. Each document type triggers a separate atomic commit
4. Commit messages follow the pattern: `docs({project-slug}): {action} {document-type}`
5. Commits are recorded in project_commits table with proper metadata
6. Writeback failures are handled gracefully (logged, don't block execution)
</verification>

<success_criteria>
- PRD documents are committed to GitHub after generation (WRITE-01)
- Document updates commit changes to GitHub (WRITE-03)
- Commits use atomic pattern with descriptive messages (WRITE-04)
- All work appears in GitHub repo (WRITE-05)
- Commits are linked to project in project_commits table (WRITE-06)
- Writeback is resilient - failures don't break stage execution
</success_criteria>

<output>
After completion, create `.planning/phases/05-github-writeback/05-03-SUMMARY.md`
</output>
