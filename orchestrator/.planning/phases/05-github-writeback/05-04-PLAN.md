---
phase: 05-github-writeback
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/lib/execution/stage-executors/prototype-executor.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Prototype notes are committed to GitHub after generation"
    - "Prototype commits use submodule paths when configured"
    - "Commits are recorded in project_commits table"
  artifacts:
    - path: "src/lib/execution/stage-executors/prototype-executor.ts"
      provides: "Prototype executor with GitHub writeback"
      contains: "commitToGitHub"
      min_lines: 150
  key_links:
    - from: "src/lib/execution/stage-executors/prototype-executor.ts"
      to: "src/lib/github/writeback-service.ts"
      via: "import and function call"
      pattern: "commitToGitHub"
---

<objective>
Integrate GitHub writeback into the prototype executor so that generated prototype notes and component specifications are automatically committed to GitHub, including support for submodule paths.

Purpose: Implements WRITE-02 (prototype commits including submodule paths), WRITE-04 (atomic commit pattern), WRITE-05 (work in GitHub), and WRITE-06 (commits linked to project).

Output:
- Prototype executor writes prototype-notes.md to GitHub
- Submodule paths are respected for prototype commits
- Commit history is recorded in project_commits table
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs (Wave 1)
@.planning/phases/05-github-writeback/05-01-PLAN.md
@.planning/phases/05-github-writeback/05-02-PLAN.md

# Current prototype executor
@src/lib/execution/stage-executors/prototype-executor.ts

# Workspace settings reference (has prototypesPath)
WorkspaceSettings.prototypesPath is the configured prototype path, may include submodule
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add helper for prototype submodule path resolution</name>
  <files>src/lib/github/path-resolver.ts</files>
  <action>
Add a helper function to extract submodule information from a prototype path:

```typescript
/**
 * Parses a prototype path to extract submodule information.
 *
 * Examples:
 * - "src/components/prototypes" -> { submodulePath: null, localPath: "src/components/prototypes" }
 * - "elephant-ai/web/src/components/prototypes" -> { submodulePath: "elephant-ai/web", localPath: "src/components/prototypes" }
 */
export function parsePrototypePath(prototypesPath: string): {
  submodulePath: string | null;
  localPath: string;
} {
  // Normalize the path
  const normalized = prototypesPath.replace(/^\/+|\/+$/g, "");

  // Common patterns for local prototype paths
  const localPatterns = [
    /^src\/components\/prototypes$/,
    /^src\/prototypes$/,
    /^prototypes$/,
    /^components\/prototypes$/,
  ];

  // Check if path starts with a common local pattern
  if (localPatterns.some(p => p.test(normalized))) {
    return { submodulePath: null, localPath: normalized };
  }

  // Check for submodule pattern: {org/repo}/path or {folder}/path
  // Heuristic: if path has more than 2 directories before "src" or "prototypes", it's likely a submodule
  const parts = normalized.split("/");

  // Look for "src" in the path as a marker
  const srcIndex = parts.indexOf("src");
  if (srcIndex > 0) {
    // Everything before "src" is the submodule path
    const submodulePath = parts.slice(0, srcIndex).join("/");
    const localPath = parts.slice(srcIndex).join("/");
    return { submodulePath, localPath };
  }

  // Look for "prototypes" or "components" as markers
  const prototypeIndex = parts.findIndex(p => p === "prototypes" || p === "components");
  if (prototypeIndex > 1) {
    // Likely a submodule path
    const submodulePath = parts.slice(0, prototypeIndex - 1).join("/");
    const localPath = parts.slice(prototypeIndex - 1).join("/");
    return { submodulePath, localPath };
  }

  // Default: treat entire path as local
  return { submodulePath: null, localPath: normalized };
}
```

Also update `resolvePrototypePath` to use workspace settings path:

```typescript
/**
 * Resolves the full path for prototype files using workspace settings.
 *
 * @param options.projectName - The project name (for component naming)
 * @param options.prototypesPath - From workspace.settings.prototypesPath
 * @param options.fileName - Optional specific file name (default: creates directory path)
 */
export function resolvePrototypeFilePath(options: {
  projectName: string;
  prototypesPath?: string;
  fileName?: string;
}): string {
  const { projectName, prototypesPath, fileName } = options;

  // PascalCase component name
  const componentName = projectName
    .split(/[\s-_]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");

  // Use provided prototypes path or default
  const basePath = prototypesPath
    ? prototypesPath.replace(/^\/+|\/+$/g, "")
    : "src/components/prototypes";

  if (fileName) {
    return `${basePath}/${componentName}/${fileName}`;
  }

  return `${basePath}/${componentName}`;
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/lib/github/path-resolver.ts`</verify>
  <done>Helper functions for prototype path resolution added</done>
</task>

<task type="auto">
  <name>Task 2: Integrate writeback into prototype executor</name>
  <files>src/lib/execution/stage-executors/prototype-executor.ts</files>
  <action>
Update the prototype executor to commit prototype notes to GitHub after saving to database.

Add imports at the top of the file:
```typescript
import { commitToGitHub, getWritebackConfig, getWorkspaceUserId } from "@/lib/github/writeback-service";
import { resolveDocumentPath, resolvePrototypeFilePath, parsePrototypePath } from "@/lib/github/path-resolver";
import { recordProjectCommit } from "@/lib/db/queries";
import type { WritebackFile, CommitMetadata } from "@/lib/github/types";
```

After the prototype notes document is saved (after the `db.insert(documents).values(...)` call around line 145-160), add the writeback logic:

```typescript
  // Commit prototype notes to GitHub (WRITE-02, WRITE-05)
  const writebackConfig = await getWritebackConfig(run.workspaceId, project.id);
  const userId = await getWorkspaceUserId(run.workspaceId);

  if (writebackConfig && userId) {
    // Get workspace settings for prototype path
    const workspace = await db.query.workspaces.findFirst({
      where: eq(workspaces.id, run.workspaceId),
    });
    const settings = workspace?.settings || {};
    const prototypesPath = settings.prototypesPath;

    // Determine paths for prototype notes
    // 1. Prototype notes go to initiatives/{project}/prototype-notes.md
    const notesPath = resolveDocumentPath({
      projectName: project.name,
      documentType: "prototype_notes",
      basePath: writebackConfig.basePath,
    });

    // 2. If there's a prototypesPath, we may also want to note it
    //    (actual component generation is separate - this just commits the spec)
    const { submodulePath } = prototypesPath
      ? parsePrototypePath(prototypesPath)
      : { submodulePath: null };

    const files: WritebackFile[] = [
      {
        path: notesPath,
        content: result.output || "",
      },
    ];

    const commitMetadata: CommitMetadata = {
      projectId: project.id,
      projectName: project.name,
      documentType: "prototype_notes",
      triggeredBy: "automation",
      stageRunId: run.id,
    };

    callbacks.onLog(
      "info",
      `Committing prototype notes to GitHub: ${notesPath}${submodulePath ? ` (prototype path: ${prototypesPath})` : ""}`,
      "prototype"
    );

    const writebackResult = await commitToGitHub(
      writebackConfig,
      files,
      commitMetadata,
      userId,
      "add"
    );

    if (writebackResult.success) {
      callbacks.onLog("info", `Committed to GitHub: ${writebackResult.commitSha}`, "prototype");

      // Record in project commit history (WRITE-06)
      await recordProjectCommit({
        projectId: project.id,
        workspaceId: run.workspaceId,
        commitSha: writebackResult.commitSha!,
        commitUrl: writebackResult.commitUrl!,
        message: `docs(${project.name.toLowerCase().replace(/\s+/g, "-")}): add prototype-notes`,
        documentType: "prototype_notes",
        filesChanged: writebackResult.filesWritten,
        triggeredBy: "automation",
        stageRunId: run.id,
      });

      // Log submodule info if configured
      if (submodulePath) {
        callbacks.onLog(
          "info",
          `Prototype generation will use submodule path: ${prototypesPath}`,
          "prototype"
        );
      }
    } else {
      callbacks.onLog("warn", `GitHub writeback failed: ${writebackResult.error}`, "prototype");
    }
  } else {
    callbacks.onLog("info", "GitHub writeback not configured or no user context", "prototype");
  }
```

Add import for `workspaces` from schema and `eq` from drizzle-orm if not already present.

Place this code after the `db.insert(documents).values(...)` block and before the prototype record creation.

Note: The actual component files (React/Storybook) would be generated by a separate build process. This writeback commits the prototype specification document that defines what should be built.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/execution/stage-executors/prototype-executor.ts`

Verify import paths resolve correctly.
  </verify>
  <done>
- Prototype executor commits prototype-notes.md to GitHub
- Submodule path information is logged for downstream processes
- Commit history is recorded in project_commits table
- Writeback failures don't block stage execution
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles for modified files
2. Prototype executor imports writeback service and path resolver
3. Prototype notes are committed to initiatives/{project}/prototype-notes.md
4. Submodule path configuration is respected and logged
5. Commits are recorded in project_commits table
6. Writeback failures are handled gracefully
</verification>

<success_criteria>
- Prototype notes are committed to GitHub after generation (WRITE-02)
- Submodule paths are recognized from workspace settings
- Commits use atomic pattern with descriptive messages (WRITE-04)
- All work appears in GitHub repo (WRITE-05)
- Commits are linked to project in project_commits table (WRITE-06)
- Writeback is resilient - failures don't break stage execution
</success_criteria>

<output>
After completion, create `.planning/phases/05-github-writeback/05-04-SUMMARY.md`
</output>
