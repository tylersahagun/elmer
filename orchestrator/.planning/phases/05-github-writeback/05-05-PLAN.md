---
phase: 05-github-writeback
plan: 05
type: execute
wave: 3
depends_on: ["05-03", "05-04"]
files_modified:
  - src/app/api/projects/[id]/commits/route.ts
  - src/components/projects/ProjectCommitHistory.tsx
  - src/app/(dashboard)/projects/[id]/ProjectDetailPage.tsx
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User can see commit history for each project"
    - "Commit history shows commit message, timestamp, and link to GitHub"
    - "Commit history is accessible from project detail view"
  artifacts:
    - path: "src/app/api/projects/[id]/commits/route.ts"
      provides: "API endpoint for commit history"
      exports: ["GET"]
      min_lines: 30
    - path: "src/components/projects/ProjectCommitHistory.tsx"
      provides: "Commit history UI component"
      min_lines: 60
  key_links:
    - from: "src/components/projects/ProjectCommitHistory.tsx"
      to: "/api/projects/[id]/commits"
      via: "useQuery fetch"
      pattern: "fetch.*api/projects.*commits"
---

<objective>
Create the commit history UI that allows users to view all Elmer-generated commits for each project, completing the WRITE-07 requirement.

Purpose: Users need visibility into what Elmer has committed to their GitHub repository. This provides transparency and enables users to track automated changes.

Output:
- API endpoint to fetch project commit history
- ProjectCommitHistory component showing commits
- Integration into project detail page
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/05-github-writeback/05-02-PLAN.md

# Existing project detail page pattern
@src/app/(dashboard)/projects/[id]/ProjectDetailPage.tsx

# Query functions from 05-02
getProjectCommitHistory, getProjectCommitCount from src/lib/db/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create commit history API endpoint</name>
  <files>src/app/api/projects/[id]/commits/route.ts</files>
  <action>
Create an API endpoint to fetch commit history for a project:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/auth";
import { getProjectCommitHistory, getProjectCommitCount } from "@/lib/db/queries";
import { db } from "@/lib/db";
import { projects, workspaceMembers } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";

interface RouteParams {
  params: Promise<{ id: string }>;
}

export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    const { id: projectId } = await params;
    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get("limit") || "20", 10);
    const offset = parseInt(searchParams.get("offset") || "0", 10);

    // Get project and verify access
    const project = await db.query.projects.findFirst({
      where: eq(projects.id, projectId),
    });

    if (!project) {
      return NextResponse.json({ error: "Project not found" }, { status: 404 });
    }

    // Verify user has access to workspace
    const membership = await db.query.workspaceMembers.findFirst({
      where: and(
        eq(workspaceMembers.workspaceId, project.workspaceId),
        eq(workspaceMembers.userId, session.user.id)
      ),
    });

    if (!membership) {
      return NextResponse.json({ error: "Access denied" }, { status: 403 });
    }

    // Fetch commit history
    const [commits, totalCount] = await Promise.all([
      getProjectCommitHistory(projectId, { limit, offset }),
      getProjectCommitCount(projectId),
    ]);

    return NextResponse.json({
      commits,
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + commits.length < totalCount,
      },
    });
  } catch (error) {
    console.error("Failed to fetch commit history:", error);
    return NextResponse.json(
      { error: "Failed to fetch commit history" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/app/api/projects/[id]/commits/route.ts`</verify>
  <done>API endpoint returns paginated commit history with access control</done>
</task>

<task type="auto">
  <name>Task 2: Create ProjectCommitHistory component</name>
  <files>src/components/projects/ProjectCommitHistory.tsx</files>
  <action>
Create a component to display commit history:

```typescript
"use client";

import { useQuery } from "@tanstack/react-query";
import { formatDistanceToNow } from "date-fns";
import { GitCommit, ExternalLink, FileText } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";

interface Commit {
  id: string;
  commitSha: string;
  commitUrl: string;
  message: string;
  documentType: string | null;
  filesChanged: string[];
  triggeredBy: string | null;
  createdAt: string;
  stageRun?: {
    id: string;
    stage: string;
    status: string;
  } | null;
}

interface CommitHistoryResponse {
  commits: Commit[];
  pagination: {
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
  };
}

interface ProjectCommitHistoryProps {
  projectId: string;
}

const DOCUMENT_TYPE_LABELS: Record<string, string> = {
  prd: "PRD",
  design_brief: "Design Brief",
  engineering_spec: "Engineering Spec",
  gtm_brief: "GTM Brief",
  research: "Research",
  prototype_notes: "Prototype Notes",
  state: "State",
};

export function ProjectCommitHistory({ projectId }: ProjectCommitHistoryProps) {
  const { data, isLoading, error } = useQuery<CommitHistoryResponse>({
    queryKey: ["project-commits", projectId],
    queryFn: async () => {
      const response = await fetch(`/api/projects/${projectId}/commits`);
      if (!response.ok) throw new Error("Failed to fetch commits");
      return response.json();
    },
  });

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <GitCommit className="h-5 w-5" />
            Commit History
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          {[1, 2, 3].map((i) => (
            <Skeleton key={i} className="h-16 w-full" />
          ))}
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <GitCommit className="h-5 w-5" />
            Commit History
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">
            Failed to load commit history
          </p>
        </CardContent>
      </Card>
    );
  }

  const commits = data?.commits || [];

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <GitCommit className="h-5 w-5" />
          Commit History
        </CardTitle>
        <CardDescription>
          {data?.pagination.total || 0} Elmer-generated commit{data?.pagination.total === 1 ? "" : "s"}
        </CardDescription>
      </CardHeader>
      <CardContent>
        {commits.length === 0 ? (
          <p className="text-sm text-muted-foreground">
            No commits yet. Documents will appear here when committed to GitHub.
          </p>
        ) : (
          <div className="space-y-4">
            {commits.map((commit) => (
              <div
                key={commit.id}
                className="flex items-start justify-between rounded-lg border p-3"
              >
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <code className="text-xs text-muted-foreground">
                      {commit.commitSha.slice(0, 7)}
                    </code>
                    {commit.documentType && (
                      <Badge variant="secondary" className="text-xs">
                        <FileText className="mr-1 h-3 w-3" />
                        {DOCUMENT_TYPE_LABELS[commit.documentType] || commit.documentType}
                      </Badge>
                    )}
                    {commit.stageRun && (
                      <Badge variant="outline" className="text-xs">
                        {commit.stageRun.stage}
                      </Badge>
                    )}
                  </div>
                  <p className="text-sm font-medium">
                    {commit.message.split("\n")[0]}
                  </p>
                  <p className="text-xs text-muted-foreground">
                    {formatDistanceToNow(new Date(commit.createdAt), { addSuffix: true })}
                    {commit.triggeredBy && ` â€¢ ${commit.triggeredBy}`}
                  </p>
                  {commit.filesChanged.length > 0 && (
                    <p className="text-xs text-muted-foreground">
                      {commit.filesChanged.length} file{commit.filesChanged.length === 1 ? "" : "s"} changed
                    </p>
                  )}
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  asChild
                  className="shrink-0"
                >
                  <a
                    href={commit.commitUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                  >
                    <ExternalLink className="h-4 w-4" />
                    <span className="sr-only">View on GitHub</span>
                  </a>
                </Button>
              </div>
            ))}

            {data?.pagination.hasMore && (
              <p className="text-center text-xs text-muted-foreground">
                Showing {commits.length} of {data.pagination.total} commits
              </p>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/components/projects/ProjectCommitHistory.tsx`</verify>
  <done>ProjectCommitHistory component displays commits with links to GitHub</done>
</task>

<task type="auto">
  <name>Task 3: Integrate commit history into project detail page</name>
  <files>src/app/(dashboard)/projects/[id]/ProjectDetailPage.tsx</files>
  <action>
Add the ProjectCommitHistory component to the project detail page. This requires:

1. Import the component at the top:
```typescript
import { ProjectCommitHistory } from "@/components/projects/ProjectCommitHistory";
```

2. Find an appropriate location in the page layout to add the commit history.
   Look for the existing layout structure (likely a grid or flex layout with document sections).

3. Add the commit history component. A good location would be after the documents section or in a sidebar/tab:
```tsx
<ProjectCommitHistory projectId={project.id} />
```

If the page uses tabs, consider adding a "History" or "Commits" tab.
If the page uses a sidebar layout, add it to the sidebar.
If the page uses sections, add it as a new section.

Adjust the placement based on the existing page structure. The component should be visible but not dominate the main content area.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/app/(dashboard)/projects/[id]/ProjectDetailPage.tsx`

Dev server renders without errors: Start dev server and navigate to a project detail page.
  </verify>
  <done>Commit history is accessible from project detail view</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete GitHub writeback system:
1. Writeback service layer with atomic commits
2. Project commit history database schema
3. PRD executor integration (commits PRD, design brief, engineering spec, GTM brief)
4. Prototype executor integration (commits prototype notes)
5. Commit history API endpoint
6. Commit history UI component
7. Integration into project detail page
  </what-built>
  <how-to-verify>
1. Start the development server: `npm run dev`

2. Create a project in a workspace with a connected GitHub repo

3. Trigger PRD generation (move project to PRD stage or run PRD stage)

4. Verify in GitHub:
   - Check the repository for new commits
   - Commits should be at `initiatives/{project-slug}/prd.md`, etc.
   - Commit messages should follow pattern: `docs({project-slug}): add prd`

5. Verify in Elmer:
   - Navigate to project detail page
   - Look for "Commit History" section
   - Should show the commits with links to GitHub

6. Click a commit link and verify it opens the correct GitHub commit page

7. Trigger prototype stage and verify prototype-notes.md is committed

8. Verify edge cases:
   - Workspace without GitHub repo configured -> Writeback is skipped gracefully
   - GitHub API error -> Stage execution continues, error is logged
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. API endpoint returns commit history with pagination
2. Component displays commits with timestamps, types, and GitHub links
3. Commit history is visible on project detail page
4. End-to-end flow: Generate document -> Commit to GitHub -> View in history
5. Access control: Only workspace members can view commit history
</verification>

<success_criteria>
- User can see commit history for each project (WRITE-07)
- Commit history shows message, timestamp, document type, and GitHub link
- Commits are clickable and open on GitHub
- Empty state shows helpful message when no commits exist
- Access is properly restricted to workspace members
- Complete Phase 5: All WRITE-XX requirements verified working
</success_criteria>

<output>
After completion, create `.planning/phases/05-github-writeback/05-05-SUMMARY.md`
</output>
