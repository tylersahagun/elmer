---
phase: 05-github-writeback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/github/writeback-service.ts
  - src/lib/github/path-resolver.ts
  - src/lib/github/types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Writeback service commits files to GitHub with atomic pattern"
    - "Path resolver computes correct file paths for PRDs and prototypes"
    - "Commit messages follow descriptive pattern with project context"
  artifacts:
    - path: "src/lib/github/writeback-service.ts"
      provides: "Core writeback orchestration"
      exports: ["commitToGitHub", "WritebackResult"]
      min_lines: 80
    - path: "src/lib/github/path-resolver.ts"
      provides: "Path computation for documents"
      exports: ["resolveDocumentPath", "resolvePrototypePath"]
      min_lines: 40
    - path: "src/lib/github/types.ts"
      provides: "Writeback types"
      exports: ["WritebackConfig", "WritebackFile", "WritebackResult"]
      min_lines: 30
  key_links:
    - from: "src/lib/github/writeback-service.ts"
      to: "/api/github/write/commit"
      via: "fetch call"
      pattern: "fetch.*github/write/commit"
---

<objective>
Create the core GitHub writeback service layer that enables committing documents and prototypes to GitHub repositories with atomic commit patterns.

Purpose: This service layer provides the foundation for all writeback operations, abstracting the GitHub API calls into a clean interface that PRD and prototype executors can use.

Output:
- Writeback types (WritebackConfig, WritebackFile, WritebackResult)
- Path resolver for computing document and prototype paths
- Writeback service with atomic commit capabilities
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing GitHub write infrastructure
@src/app/api/github/write/commit/route.ts
@src/app/api/github/write/prepare/route.ts

# Database schema for reference
@src/lib/db/schema.ts

# Workspace settings (has prototypesPath, baseBranch, etc.)
Relevant: WorkspaceSettings interface has prototypesPath, baseBranch, contextPaths
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create writeback types</name>
  <files>src/lib/github/types.ts</files>
  <action>
Create TypeScript types for the writeback system:

```typescript
// WritebackConfig - configuration for a writeback operation
export interface WritebackConfig {
  workspaceId: string;
  projectId: string;
  projectName: string;
  owner: string;
  repo: string;
  branch: string;
  basePath?: string; // e.g., "initiatives/" or submodule path
}

// WritebackFile - a single file to commit
export interface WritebackFile {
  path: string;      // Full path in repo (e.g., "initiatives/feature-a/prd.md")
  content: string;   // File content
  encoding?: "utf-8" | "base64";
}

// WritebackResult - result of a commit operation
export interface WritebackResult {
  success: boolean;
  commitSha?: string;
  commitUrl?: string;
  error?: string;
  filesWritten?: string[];
}

// CommitMetadata - metadata to include in commit message
export interface CommitMetadata {
  projectId: string;
  projectName: string;
  documentType?: string;   // "prd" | "design_brief" | "prototype_notes" | etc.
  triggeredBy?: string;    // "automation" | "user" | stage run ID
  stageRunId?: string;
}
```

Add type for document path options:

```typescript
export interface DocumentPathOptions {
  projectName: string;
  documentType: string;
  basePath?: string;       // Override default "initiatives/"
  submodulePath?: string;  // For prototype submodule paths
}
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit src/lib/github/types.ts`</verify>
  <done>Types exported and importable from src/lib/github/types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create path resolver</name>
  <files>src/lib/github/path-resolver.ts</files>
  <action>
Create a path resolver module that computes correct file paths for documents and prototypes:

```typescript
import type { DocumentPathOptions } from "./types";

/**
 * Resolves the path for a document in the repository.
 *
 * Convention: initiatives/{project-slug}/{document-type}.md
 * Example: initiatives/feature-a/prd.md
 */
export function resolveDocumentPath(options: DocumentPathOptions): string {
  const { projectName, documentType, basePath = "initiatives" } = options;

  // Slugify project name: lowercase, replace spaces with hyphens
  const slug = projectName.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "");

  // Map document types to filenames
  const fileNameMap: Record<string, string> = {
    prd: "prd.md",
    design_brief: "design-brief.md",
    engineering_spec: "engineering-spec.md",
    gtm_brief: "gtm-brief.md",
    research: "research.md",
    prototype_notes: "prototype-notes.md",
    state: "state.md",
  };

  const fileName = fileNameMap[documentType] || `${documentType.replace(/_/g, "-")}.md`;

  // Normalize base path (no leading slash, trailing slash)
  const normalizedBase = basePath.replace(/^\/+/, "").replace(/\/+$/, "");

  return `${normalizedBase}/${slug}/${fileName}`;
}

/**
 * Resolves the path for a prototype in the repository.
 *
 * Supports submodule paths: {submodulePath}/src/components/prototypes/{ComponentName}/
 * Default: src/components/prototypes/{ComponentName}/
 */
export function resolvePrototypePath(options: {
  projectName: string;
  submodulePath?: string;  // e.g., "elephant-ai/web"
  componentSuffix?: string; // e.g., "Prototype" (default)
}): string {
  const { projectName, submodulePath, componentSuffix = "" } = options;

  // PascalCase component name
  const componentName = projectName
    .split(/[\s-_]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("") + componentSuffix;

  const basePath = submodulePath
    ? `${submodulePath.replace(/^\/+|\/+$/g, "")}/src/components/prototypes`
    : "src/components/prototypes";

  return `${basePath}/${componentName}`;
}

/**
 * Get the parent initiative directory for a project.
 */
export function getProjectBasePath(projectName: string, basePath = "initiatives"): string {
  const slug = projectName.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "");
  return `${basePath.replace(/^\/+|\/+$/, "")}/${slug}`;
}
```
  </action>
  <verify>
Run TypeScript compiler: `npx tsc --noEmit src/lib/github/path-resolver.ts`

Manually verify paths resolve correctly:
- "Feature Alpha" + "prd" -> "initiatives/feature-alpha/prd.md"
- "My Test" + submodule "elephant-ai/web" -> "elephant-ai/web/src/components/prototypes/MyTest"
  </verify>
  <done>Path resolver functions exported and correctly compute initiative paths</done>
</task>

<task type="auto">
  <name>Task 3: Create writeback service</name>
  <files>src/lib/github/writeback-service.ts</files>
  <action>
Create the core writeback service that orchestrates GitHub commits:

```typescript
import type { WritebackConfig, WritebackFile, WritebackResult, CommitMetadata } from "./types";
import { db } from "@/lib/db";
import { githubWriteOps, projects } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";

/**
 * Generates an atomic commit message with project context.
 *
 * Pattern: docs({project-slug}): {action} {document-type}
 * Example: "docs(feature-alpha): add prd"
 */
export function generateCommitMessage(metadata: CommitMetadata, action: "add" | "update" = "add"): string {
  const slug = metadata.projectName.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "");
  const docType = metadata.documentType?.replace(/_/g, "-") || "document";

  return `docs(${slug}): ${action} ${docType}

Project: ${metadata.projectName}
Generated by: Elmer ${metadata.triggeredBy ? `(${metadata.triggeredBy})` : ""}
${metadata.stageRunId ? `Stage run: ${metadata.stageRunId}` : ""}`.trim();
}

/**
 * Commits files to GitHub using the existing write/commit API.
 * Records the operation in githubWriteOps for tracking.
 */
export async function commitToGitHub(
  config: WritebackConfig,
  files: WritebackFile[],
  metadata: CommitMetadata,
  action: "add" | "update" = "add"
): Promise<WritebackResult> {
  const message = generateCommitMessage(metadata, action);
  const opId = `ghop_${nanoid()}`;

  try {
    // Record the operation as "prepared"
    await db.insert(githubWriteOps).values({
      id: opId,
      workspaceId: config.workspaceId,
      repoFullName: `${config.owner}/${config.repo}`,
      baseBranch: config.branch,
      writeBranch: config.branch, // Direct commit to branch
      status: "prepared",
      proposedChanges: {
        files: files.map(f => ({ path: f.path, action })),
        message,
        metadata,
      },
      createdAt: new Date(),
    });

    // Call the internal commit API (server-to-server)
    // This is called from executors which already have the session context
    const response = await fetch(`${process.env.AUTH_URL || ""}/api/github/write/commit`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        owner: config.owner,
        repo: config.repo,
        branch: config.branch,
        message,
        files: files.map(f => ({ path: f.path, content: f.content })),
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: "Unknown error" }));

      // Update operation status to failed
      await db.update(githubWriteOps)
        .set({ status: "failed" })
        .where(eq(githubWriteOps.id, opId));

      return {
        success: false,
        error: errorData.error || `HTTP ${response.status}`,
      };
    }

    const result = await response.json();

    // Update operation status to committed
    await db.update(githubWriteOps)
      .set({
        status: "committed",
        commitSha: result.commitSha,
      })
      .where(eq(githubWriteOps.id, opId));

    return {
      success: true,
      commitSha: result.commitSha,
      commitUrl: `https://github.com/${config.owner}/${config.repo}/commit/${result.commitSha}`,
      filesWritten: files.map(f => f.path),
    };
  } catch (error) {
    console.error("[writeback-service] Commit failed:", error);

    // Try to update operation status
    try {
      await db.update(githubWriteOps)
        .set({ status: "failed" })
        .where(eq(githubWriteOps.id, opId));
    } catch {
      // Ignore cleanup errors
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to commit to GitHub",
    };
  }
}

/**
 * Gets the writeback configuration for a project from workspace settings.
 */
export async function getWritebackConfig(
  workspaceId: string,
  projectId: string
): Promise<WritebackConfig | null> {
  // Get project with workspace
  const project = await db.query.projects.findFirst({
    where: eq(projects.id, projectId),
    with: { workspace: true },
  });

  if (!project || !project.workspace) return null;

  const workspace = project.workspace;
  const settings = workspace.settings || {};

  // Parse repo from githubRepo (format: "owner/repo")
  if (!workspace.githubRepo) return null;

  const [owner, repo] = workspace.githubRepo.split("/");
  if (!owner || !repo) return null;

  return {
    workspaceId,
    projectId,
    projectName: project.name,
    owner,
    repo,
    branch: settings.baseBranch || "main",
    basePath: "initiatives", // Could make this configurable later
  };
}
```

Note: The fetch to `/api/github/write/commit` needs authentication context. In production, this will be called from stage executors that already have the user session. For now, this structure prepares for that integration.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/github/writeback-service.ts`

Verify imports work:
```typescript
import { commitToGitHub, getWritebackConfig, generateCommitMessage } from "@/lib/github/writeback-service";
```
  </verify>
  <done>
- commitToGitHub function commits files with atomic pattern
- generateCommitMessage creates conventional commit messages
- getWritebackConfig extracts config from workspace settings
- Operations are tracked in githubWriteOps table
  </done>
</task>

</tasks>

<verification>
1. All three files compile without TypeScript errors
2. Types are correctly exported from src/lib/github/types.ts
3. Path resolver correctly computes paths for initiatives and prototypes
4. Writeback service correctly imports from existing database schema
5. Commit message format follows conventional commits pattern
</verification>

<success_criteria>
- Writeback types defined with WritebackConfig, WritebackFile, WritebackResult, CommitMetadata
- Path resolver computes correct paths for documents and prototypes (including submodules)
- Writeback service provides commitToGitHub function that uses existing /api/github/write/commit
- Commit messages follow pattern: `docs({project-slug}): {action} {document-type}`
- All operations tracked in githubWriteOps table for audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/05-github-writeback/05-01-SUMMARY.md`
</output>
