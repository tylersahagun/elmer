---
phase: 02-structure-discovery-a-workspace-population
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/discovery/scanner.ts
  - src/app/api/discovery/route.ts
autonomous: true

must_haves:
  truths:
    - "System scans repo for folder patterns and returns structured discovery results"
    - "System detects context paths (knowledge, personas, signals, prototypes)"
    - "System detects .cursor/ directory and AGENTS.md configuration"
    - "API endpoint returns discovery results for a workspace's connected repo"
  artifacts:
    - path: "src/lib/discovery/scanner.ts"
      provides: "Repository scanning orchestration"
      exports: ["scanRepository", "ScanOptions"]
    - path: "src/app/api/discovery/route.ts"
      provides: "Discovery API endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/discovery/route.ts"
      to: "src/lib/discovery/scanner.ts"
      via: "API calls scanRepository"
      pattern: "scanRepository\\("
    - from: "src/lib/discovery/scanner.ts"
      to: "src/lib/discovery/patterns.ts"
      via: "Uses pattern matching for folder discovery"
      pattern: "matchFolderPattern\\("
---

<objective>
Create the repository scanner and discovery API endpoint.

Purpose: Orchestrate the scanning of a GitHub repository using the tree API, detect pm-workspace structures, and return comprehensive discovery results for the preview UI.

Output: Scanner module that coordinates discovery and API endpoint for triggering discovery.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-structure-discovery-a-workspace-population/02-CONTEXT.md

# Prior plan outputs
@.planning/phases/02-structure-discovery-a-workspace-population/02-01-SUMMARY.md
@.planning/phases/02-structure-discovery-a-workspace-population/02-02-SUMMARY.md

# Existing patterns
@src/lib/github/auth.ts (getGitHubClient pattern)
@src/app/api/github/tree/route.ts (tree API usage)
@src/lib/agents/sync.ts (agent detection patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repository scanner module</name>
  <files>src/lib/discovery/scanner.ts</files>
  <action>
Create the main repository scanner that orchestrates discovery.

Implementation:

1. Import dependencies:
   - Octokit from @octokit/rest
   - All discovery modules from './index'
   - Types from './types'

2. Define ScanOptions interface:
   ```typescript
   interface ScanOptions {
     workspaceId: string;
     owner: string;
     repo: string;
     branch: string;
     octokit: Octokit;
   }
   ```

3. Create scanRepository(options: ScanOptions): Promise<DiscoveryResult>

   Step 1: Get repository tree using recursive=true (single API call per P5 pitfall):
   ```typescript
   const { data: tree } = await octokit.git.getTree({
     owner,
     repo,
     tree_sha: branch,
     recursive: 'true'
   });
   ```

   Step 2: Build folder map from tree entries:
   - Filter for type='tree' (directories)
   - Create Map<path, TreeEntry> for quick lookup

   Step 3: Discover initiative folders:
   - Get top-level directories from tree
   - Run matchFolderPattern against INITIATIVE_PATTERNS
   - For each match, scan for subdirectories (the actual initiatives)
   - Per CONTEXT.md: "Show all candidate folders with equal weight"

   Step 4: For each discovered initiative:
   - Check for _meta.json file in tree
   - If exists, fetch content using getContent API
   - Parse with parseMetaJson and extractStatus
   - Map status with mapStatusToColumn
   - Generate deterministic ID with generateProjectId
   - Build DiscoveredInitiative object

   Step 5: Discover context paths:
   - Check for knowledge/, docs/, kb/, personas/, signals/ directories
   - Use CONTEXT_PATTERNS for matching
   - Count files in each directory from tree
   - Build DiscoveredContextPath objects

   Step 6: Discover agents:
   - Check for .cursor/ directory
   - Check for AGENTS.md at root
   - If found, note for import (actual parsing happens during import)
   - Build DiscoveredAgent objects

   Step 7: Compile DiscoveryResult with stats and warnings

4. Handle errors gracefully:
   - Catch API errors and add to warnings
   - Continue scanning even if individual items fail
   - Return partial results with warning list
  </action>
  <verify>
Create src/lib/discovery/__tests__/scanner.test.ts with mocked Octokit:
- Test discovers initiatives folder with _meta.json
- Test handles missing _meta.json (uses folder name)
- Test discovers knowledge path
- Test discovers .cursor/ agents
- Test returns warnings for parse errors
Run: npm test -- src/lib/discovery/__tests__/scanner.test.ts
  </verify>
  <done>Scanner orchestrates full repository discovery with pattern matching and metadata extraction</done>
</task>

<task type="auto">
  <name>Task 2: Create discovery API endpoint</name>
  <files>src/app/api/discovery/route.ts</files>
  <action>
Create API endpoint to trigger repository discovery.

Implementation:

1. GET /api/discovery
   - Query params: workspaceId (required)
   - Returns DiscoveryResult JSON

2. Implementation flow:
   ```typescript
   import { NextRequest, NextResponse } from "next/server";
   import { auth } from "@/auth";
   import { getGitHubClient } from "@/lib/github/auth";
   import { getWorkspace } from "@/lib/db/queries";
   import { scanRepository } from "@/lib/discovery";

   export async function GET(request: NextRequest) {
     // 1. Auth check
     const session = await auth();
     if (!session?.user?.id) {
       return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
     }

     // 2. Get workspaceId from query
     const { searchParams } = new URL(request.url);
     const workspaceId = searchParams.get("workspaceId");
     if (!workspaceId) {
       return NextResponse.json({ error: "workspaceId required" }, { status: 400 });
     }

     // 3. Load workspace and validate
     const workspace = await getWorkspace(workspaceId);
     if (!workspace) {
       return NextResponse.json({ error: "Workspace not found" }, { status: 404 });
     }

     // 4. Parse repo slug (owner/repo)
     const repoSlug = workspace.githubRepo;
     if (!repoSlug) {
       return NextResponse.json({ error: "No repository connected" }, { status: 400 });
     }
     const [owner, repo] = repoSlug.split('/');

     // 5. Get branch (from onboarding data or default)
     const branch = workspace.onboardingData?.selectedBranch
       || workspace.settings?.baseBranch
       || 'main';

     // 6. Get GitHub client
     const octokit = await getGitHubClient(session.user.id);
     if (!octokit) {
       return NextResponse.json({
         error: "GitHub not connected",
         connectUrl: "/api/auth/signin/github"
       }, { status: 403 });
     }

     // 7. Run discovery
     try {
       const result = await scanRepository({
         workspaceId,
         owner,
         repo,
         branch,
         octokit
       });

       return NextResponse.json(result);
     } catch (error) {
       console.error("Discovery error:", error);
       return NextResponse.json({
         error: error instanceof Error ? error.message : "Discovery failed"
       }, { status: 500 });
     }
   }
   ```

3. Add permission check if requireWorkspaceAccess helper exists
  </action>
  <verify>
Manual test (requires running app):
1. Connect GitHub and select repo in onboarding
2. Call GET /api/discovery?workspaceId=xxx
3. Verify response contains initiatives, contextPaths, agents arrays

Automated test in src/app/api/discovery/__tests__/route.test.ts:
- Test returns 401 without auth
- Test returns 400 without workspaceId
- Test returns 404 for missing workspace
Run: npm test -- src/app/api/discovery/
  </verify>
  <done>API endpoint triggers discovery and returns structured results</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `npx tsc --noEmit`
2. Tests pass: `npm test -- src/lib/discovery/`
3. API endpoint is accessible (verify route file exists)
</verification>

<success_criteria>
- Scanner uses tree API with recursive=true (single API call for efficiency)
- Scanner discovers initiatives with pattern matching and status extraction
- Scanner detects context paths and agents
- API endpoint wires scanner to HTTP interface
- Errors handled gracefully with warnings in result
</success_criteria>

<output>
After completion, create `.planning/phases/02-structure-discovery-a-workspace-population/02-03-SUMMARY.md`
</output>
