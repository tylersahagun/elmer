---
phase: 02-structure-discovery-a-workspace-population
plan: 07
type: execute
wave: 4
depends_on: ["02-03", "02-05", "02-06"]
files_modified:
  - src/lib/discovery/populate.ts
  - src/app/api/discovery/import/route.ts
  - src/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "System creates project records from discovered initiatives"
    - "Projects are assigned to correct Kanban columns based on status mapping"
    - "System triggers knowledge base sync from detected context path"
    - "System handles duplicate detection using deterministic IDs (upsert)"
  artifacts:
    - path: "src/lib/discovery/populate.ts"
      provides: "Population engine for creating workspace entities"
      exports: ["populateWorkspace", "PopulateOptions"]
    - path: "src/app/api/discovery/import/route.ts"
      provides: "Import API endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/discovery/import/route.ts"
      to: "src/lib/discovery/populate.ts"
      via: "API calls populateWorkspace"
      pattern: "populateWorkspace\\("
    - from: "src/lib/discovery/populate.ts"
      to: "src/lib/db/queries.ts"
      via: "Uses upsertProject for idempotent import"
      pattern: "upsertProject\\("
---

<objective>
Create the population engine and import API endpoint.

Purpose: Transform discovered initiatives into Elmer projects in the database, sync context paths, and handle re-onboarding gracefully with upsert behavior.

Output: Population module that creates/updates workspace entities and API endpoint for triggering import.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-structure-discovery-a-workspace-population/02-CONTEXT.md

# Database patterns
@src/lib/db/schema.ts (projects table, ProjectStage type)
@src/lib/db/queries.ts (existing query patterns)

# Knowledge sync pattern
@src/lib/knowledgebase/sync.ts (syncKnowledgeBase function)

# Agent sync pattern
@src/lib/agents/sync.ts (syncAgentArchitecture function)

# Prior plan outputs
@.planning/phases/02-structure-discovery-a-workspace-population/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add upsertProject query to database queries</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Add upsertProject function for idempotent project creation.

Find the existing queries file and add:

```typescript
import { eq } from "drizzle-orm";
import { projects } from "./schema";
import type { ProjectStage, ProjectMetadata } from "./schema";

interface UpsertProjectInput {
  id: string;  // Deterministic ID
  workspaceId: string;
  name: string;
  description?: string | null;
  stage: ProjectStage;
  metadata?: ProjectMetadata;
}

/**
 * Upsert a project - update if exists, create if not.
 * Uses deterministic ID for idempotent imports (DISC-09, POPUL-06).
 */
export async function upsertProject(input: UpsertProjectInput) {
  const { id, workspaceId, name, description, stage, metadata } = input;
  const now = new Date();

  // Check if project exists
  const existing = await db.query.projects.findFirst({
    where: eq(projects.id, id)
  });

  if (existing) {
    // Update existing project
    await db
      .update(projects)
      .set({
        name,
        description,
        stage,
        metadata: metadata ?? existing.metadata,
        updatedAt: now
      })
      .where(eq(projects.id, id));

    return { action: 'updated' as const, id };
  } else {
    // Create new project
    await db.insert(projects).values({
      id,
      workspaceId,
      name,
      description,
      stage,
      status: 'active',
      metadata,
      createdAt: now,
      updatedAt: now
    });

    return { action: 'created' as const, id };
  }
}
```

Note: The exact location to add this depends on the existing queries.ts structure. Add near other project-related queries.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Function is exported from queries module
  </verify>
  <done>upsertProject enables idempotent project creation with deterministic IDs</done>
</task>

<task type="auto">
  <name>Task 2: Create population engine</name>
  <files>src/lib/discovery/populate.ts</files>
  <action>
Create the population engine that transforms discovery results into database records.

Implementation:

```typescript
import { Octokit } from "@octokit/rest";
import type { ImportSelection, ImportResult, DiscoveryResult, DiscoveredInitiative } from "./types";
import type { ProjectStage } from "@/lib/db/schema";
import { upsertProject } from "@/lib/db/queries";
import { syncKnowledgeBase } from "@/lib/knowledgebase/sync";
import { syncAgentArchitecture } from "@/lib/agents/sync";

export interface PopulateOptions {
  workspaceId: string;
  result: DiscoveryResult;
  selection: ImportSelection;
  octokit: Octokit;
}

// Map discovery column names to ProjectStage enum
const COLUMN_TO_STAGE: Record<string, ProjectStage> = {
  'inbox': 'inbox',
  'discovery': 'discovery',
  'prd': 'prd',
  'design': 'design',
  'prototype': 'prototype',
  'validate': 'validate',
  'tickets': 'tickets',
  'build': 'build',
  'alpha': 'alpha',
  'beta': 'beta',
  'ga': 'ga',
};

function getStageFromColumn(column: string): ProjectStage {
  // Check if it's a known stage
  if (column in COLUMN_TO_STAGE) {
    return COLUMN_TO_STAGE[column];
  }
  // For dynamic columns, default to inbox
  // Note: Dynamic column creation is handled at UI/Kanban level, not database
  return 'inbox';
}

export async function populateWorkspace(options: PopulateOptions): Promise<ImportResult> {
  const { workspaceId, result, selection, octokit } = options;
  const [owner, repo] = [result.repoOwner, result.repoName];

  const importResult: ImportResult = {
    success: true,
    projectsCreated: 0,
    projectsUpdated: 0,
    columnsCreated: [],
    knowledgeSynced: 0,
    personasSynced: 0,
    signalsSynced: 0,
    agentsImported: 0,
    errors: [],
  };

  // Track dynamic columns for potential creation
  const dynamicColumns = new Set<string>();

  // 1. Create/Update projects from selected initiatives
  const selectedInitiatives = result.initiatives.filter(
    (i) => selection.initiatives.includes(i.id)
  );

  for (const initiative of selectedInitiatives) {
    try {
      const stage = getStageFromColumn(initiative.mappedColumn);

      // Track if this is a dynamic column
      if (!(initiative.mappedColumn in COLUMN_TO_STAGE)) {
        dynamicColumns.add(initiative.mappedColumn);
      }

      const upsertResult = await upsertProject({
        id: initiative.id,
        workspaceId,
        name: initiative.name,
        description: initiative.description,
        stage,
        metadata: {
          tags: initiative.tags,
          // Store source info for traceability
          importSource: {
            repo: `${owner}/${repo}`,
            path: initiative.sourcePath,
            branch: result.branch,
            importedAt: new Date().toISOString(),
          },
          // Preserve raw meta for reference
          rawMeta: initiative.rawMeta || undefined,
        },
      });

      if (upsertResult.action === 'created') {
        importResult.projectsCreated++;
      } else {
        importResult.projectsUpdated++;
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Unknown error';
      importResult.errors.push(`Project ${initiative.name}: ${msg}`);
    }
  }

  // 2. Sync knowledge base from selected context paths
  const selectedKnowledge = result.contextPaths.filter(
    (cp) => cp.type === 'knowledge' && selection.contextPaths.includes(cp.path)
  );

  if (selectedKnowledge.length > 0) {
    try {
      const knowledgeResult = await syncKnowledgeBase(workspaceId, {
        octokit,
        repoOwner: owner,
        repoName: repo,
        repoRef: result.branch,
        contextPaths: selectedKnowledge.map((cp) => cp.path),
      });

      importResult.knowledgeSynced = knowledgeResult.synced;
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Unknown error';
      importResult.errors.push(`Knowledge sync: ${msg}`);
    }
  }

  // 3. Sync agents from selected paths
  if (selection.agents.length > 0) {
    try {
      await syncAgentArchitecture({
        workspaceId,
        owner,
        repo,
        ref: result.branch,
        octokit,
        selection: {
          agentsMd: selection.agents.includes('AGENTS.md'),
          skills: selection.agents.some((a) => a.includes('.cursor/skills')),
          commands: selection.agents.some((a) => a.includes('.cursor/commands')),
          subagents: selection.agents.some((a) => a.includes('.cursor/agents')),
          rules: selection.agents.some((a) => a.includes('.cursor/rules')),
        },
      });

      importResult.agentsImported = selection.agents.length;
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Unknown error';
      importResult.errors.push(`Agent import: ${msg}`);
    }
  }

  // 4. Record dynamic columns created
  importResult.columnsCreated = Array.from(dynamicColumns);

  // Set success based on whether we had critical errors
  importResult.success = importResult.errors.length === 0 ||
    (importResult.projectsCreated + importResult.projectsUpdated) > 0;

  return importResult;
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Module exports populateWorkspace function
  </verify>
  <done>Population engine creates projects, syncs knowledge, and imports agents with idempotent behavior</done>
</task>

<task type="auto">
  <name>Task 3: Create import API endpoint</name>
  <files>src/app/api/discovery/import/route.ts</files>
  <action>
Create API endpoint to trigger workspace population.

Implementation:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/auth";
import { getGitHubClient } from "@/lib/github/auth";
import { getWorkspace, updateWorkspace } from "@/lib/db/queries";
import { populateWorkspace } from "@/lib/discovery/populate";
import type { ImportSelection, DiscoveryResult } from "@/lib/discovery/types";

export async function POST(request: NextRequest) {
  try {
    // 1. Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // 2. Parse request body
    const body = await request.json();
    const { workspaceId, result, selection } = body as {
      workspaceId: string;
      result: DiscoveryResult;
      selection: ImportSelection;
    };

    if (!workspaceId || !result || !selection) {
      return NextResponse.json(
        { error: "Missing required fields: workspaceId, result, selection" },
        { status: 400 }
      );
    }

    // 3. Load workspace and validate
    const workspace = await getWorkspace(workspaceId);
    if (!workspace) {
      return NextResponse.json({ error: "Workspace not found" }, { status: 404 });
    }

    // 4. Get GitHub client
    const octokit = await getGitHubClient(session.user.id);
    if (!octokit) {
      return NextResponse.json({
        error: "GitHub not connected",
        connectUrl: "/api/auth/signin/github"
      }, { status: 403 });
    }

    // 5. Run population
    const importResult = await populateWorkspace({
      workspaceId,
      result,
      selection,
      octokit,
    });

    // 6. Update workspace onboarding data with import stats
    const existingData = workspace.onboardingData || { completedAt: '', selectedBranch: '' };
    await updateWorkspace(workspaceId, {
      onboardingData: {
        ...existingData,
        importedProjects: importResult.projectsCreated + importResult.projectsUpdated,
        importedPersonas: importResult.personasSynced,
        importedKnowledge: importResult.knowledgeSynced,
      },
      // Update context paths from discovery
      settings: {
        ...workspace.settings,
        contextPaths: selection.contextPaths,
      },
    });

    return NextResponse.json(importResult);
  } catch (error) {
    console.error("Import error:", error);
    return NextResponse.json({
      error: error instanceof Error ? error.message : "Import failed",
      success: false,
      projectsCreated: 0,
      projectsUpdated: 0,
      columnsCreated: [],
      knowledgeSynced: 0,
      personasSynced: 0,
      signalsSynced: 0,
      agentsImported: 0,
      errors: [error instanceof Error ? error.message : "Import failed"],
    }, { status: 500 });
  }
}
```

Note: If updateWorkspace doesn't exist, create it following the pattern in queries.ts:

```typescript
export async function updateWorkspace(
  workspaceId: string,
  updates: Partial<{
    onboardingData: OnboardingData;
    settings: WorkspaceSettings;
  }>
) {
  await db
    .update(workspaces)
    .set({
      ...updates,
      updatedAt: new Date(),
    })
    .where(eq(workspaces.id, workspaceId));
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
API route file exists at correct path
  </verify>
  <done>Import API endpoint triggers population and returns result</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `npx tsc --noEmit`
2. upsertProject function exists in queries
3. populateWorkspace function exported from discovery module
4. API endpoint accessible at POST /api/discovery/import
</verification>

<success_criteria>
- Projects created from discovered initiatives (POPUL-01)
- Projects assigned to correct columns based on status mapping (POPUL-02)
- Knowledge base sync triggered (POPUL-03)
- Duplicate detection via deterministic IDs - upsert behavior (POPUL-06)
- Import result includes success/failure counts
</success_criteria>

<output>
After completion, create `.planning/phases/02-structure-discovery-a-workspace-population/02-07-SUMMARY.md`
</output>
