---
phase: 02-structure-discovery-a-workspace-population
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/discovery/patterns.ts
  - src/lib/discovery/meta-parser.ts
  - src/lib/discovery/status-mapper.ts
autonomous: true

must_haves:
  truths:
    - "System identifies initiative folders by pattern matching (initiatives/, features/, projects/, work/, epics/)"
    - "System parses _meta.json files with permissive schema and extracts status"
    - "System maps status strings to Kanban columns with fuzzy matching"
  artifacts:
    - path: "src/lib/discovery/patterns.ts"
      provides: "Pattern matching for folder discovery"
      exports: ["INITIATIVE_PATTERNS", "CONTEXT_PATTERNS", "matchFolderPattern", "rankFolderMatch"]
    - path: "src/lib/discovery/meta-parser.ts"
      provides: "Permissive _meta.json parsing"
      exports: ["parseMetaJson", "extractStatus", "MetaJsonSchema"]
    - path: "src/lib/discovery/status-mapper.ts"
      provides: "Fuzzy status to column mapping"
      exports: ["mapStatusToColumn", "STATUS_ALIASES", "createDynamicColumn"]
  key_links:
    - from: "src/lib/discovery/meta-parser.ts"
      to: "src/lib/discovery/status-mapper.ts"
      via: "extractStatus result fed to mapStatusToColumn"
      pattern: "mapStatusToColumn\\(.*extractStatus"
---

<objective>
Create the core discovery engine for scanning GitHub repository structures.

Purpose: Enable Elmer to identify pm-workspace folders, parse initiative metadata, and map statuses to Kanban columns - the foundation for auto-populating workspaces from GitHub repos.

Output: Three library modules providing pattern matching, metadata parsing, and status mapping capabilities.
</objective>

<execution_context>
@/Users/tylersahagun/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylersahagun/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-structure-discovery-a-workspace-population/02-CONTEXT.md

# Existing patterns from Phase 1
@src/lib/db/schema.ts (ProjectStage type, projects table structure)
@src/lib/knowledgebase/sync.ts (GitHub file reading patterns with Octokit)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create folder pattern matching module</name>
  <files>src/lib/discovery/patterns.ts</files>
  <action>
Create pattern matching module for discovering pm-workspace folders.

Implementation:
1. Define INITIATIVE_PATTERNS array with exact matches and plural variations:
   - "initiatives", "initiative", "features", "feature", "projects", "project", "work", "epics", "epic"

2. Define CONTEXT_PATTERNS for more permissive context path discovery:
   - Knowledge: "knowledge", "docs", "kb", "documentation", "pm-workspace-docs"
   - Personas: "personas", "persona", "team", "users"
   - Signals: "signals", "signal", "feedback", "insights"

3. Create matchFolderPattern(folderName: string, patterns: string[]): PatternMatch | null
   - Returns { pattern: string, matchType: 'exact' | 'plural' | 'partial', confidence: number }
   - Exact match = confidence 1.0
   - Plural variation = confidence 0.9
   - Case-insensitive matching

4. Create rankFolderMatch(matches: PatternMatch[]): PatternMatch[]
   - Sort by confidence descending
   - Per CONTEXT.md: "Show all candidate folders with equal weight" - but still provide confidence for UI sorting

Export types: PatternMatch, FolderType ('initiative' | 'knowledge' | 'personas' | 'signals')
  </action>
  <verify>
Create src/lib/discovery/__tests__/patterns.test.ts with:
- Test exact match: "initiatives" returns confidence 1.0
- Test plural: "initiative" matches "initiatives" pattern with 0.9
- Test case insensitive: "Initiatives" matches
- Test no match: "random-folder" returns null
Run: npm test -- src/lib/discovery/__tests__/patterns.test.ts
  </verify>
  <done>Pattern matching identifies initiative folders with appropriate confidence scores</done>
</task>

<task type="auto">
  <name>Task 2: Create permissive _meta.json parser</name>
  <files>src/lib/discovery/meta-parser.ts</files>
  <action>
Create a permissive parser for _meta.json files that handles real-world variations.

Implementation:
1. Define MetaJsonSchema interface (permissive - all fields optional):
   ```typescript
   interface MetaJsonSchema {
     status?: string;
     stage?: string;  // alternate field name
     state?: string;  // alternate field name
     name?: string;
     title?: string;
     description?: string;
     archived?: boolean;
     created?: string;
     updated?: string;
     tags?: string[];
     [key: string]: unknown;  // allow any other fields
   }
   ```

2. Create parseMetaJson(content: string): ParsedMeta | ParseError
   - Try JSON.parse, catch and return ParseError with helpful message
   - Validate basic structure (should be object, not array)
   - Return parsed object with all fields preserved

3. Create extractStatus(meta: MetaJsonSchema): ExtractedStatus
   - Check fields in order: status, stage, state
   - Return { value: string | null, source: 'status' | 'stage' | 'state' | 'none', archived: boolean }
   - If archived: true, set archived flag

4. Handle malformed files gracefully (DISC-08):
   - Empty file -> return ParseError
   - Invalid JSON -> return ParseError with line/column if possible
   - Valid JSON but wrong structure (array, string) -> return ParseError
  </action>
  <verify>
Create src/lib/discovery/__tests__/meta-parser.test.ts with:
- Test valid JSON with status field
- Test stage field fallback (no status, has stage)
- Test state field fallback (no status/stage, has state)
- Test archived: true handling
- Test malformed JSON returns ParseError
- Test empty content returns ParseError
Run: npm test -- src/lib/discovery/__tests__/meta-parser.test.ts
  </verify>
  <done>_meta.json files parsed permissively with status extraction from multiple possible fields</done>
</task>

<task type="auto">
  <name>Task 3: Create fuzzy status to column mapper</name>
  <files>src/lib/discovery/status-mapper.ts</files>
  <action>
Create fuzzy matching for status strings to Kanban columns.

Implementation:
1. Define STATUS_ALIASES mapping variations to canonical columns:
   ```typescript
   const STATUS_ALIASES: Record<string, string[]> = {
     'inbox': ['inbox', 'new', 'triage', 'backlog'],
     'discovery': ['discovery', 'disc', 'research', 'exploring', 'ideation'],
     'prd': ['prd', 'requirements', 'spec', 'specification'],
     'design': ['design', 'ux', 'ui', 'wireframe'],
     'prototype': ['prototype', 'proto', 'poc', 'mvp'],
     'validate': ['validate', 'validation', 'testing', 'qa'],
     'tickets': ['tickets', 'jira', 'linear', 'issues'],
     'build': ['build', 'development', 'dev', 'in-progress', 'coding', 'implementation'],
     'alpha': ['alpha', 'internal'],
     'beta': ['beta', 'beta-testing'],
     'ga': ['ga', 'production', 'released', 'live', 'shipped'],
   };
   ```

2. Create mapStatusToColumn(status: string): MappingResult
   - Normalize: lowercase, trim, replace underscores/dashes with spaces
   - Check exact match against aliases
   - If no exact match, try fuzzy match (contains, starts with)
   - Return { column: string | null, confidence: number, isAmbiguous: boolean, alternatives?: string[] }
   - Per CONTEXT.md: Flag ambiguous mappings like 'discovery-dev-ready' for user review

3. Create createDynamicColumn(status: string): string
   - Per CONTEXT.md: "Create columns dynamically to match discovered statuses"
   - If no match found, return capitalized/formatted status as new column name
   - Example: 'Beta Testing' stays as 'Beta Testing' for dynamic column creation

4. Export isKnownColumn(column: string): boolean for validation
  </action>
  <verify>
Create src/lib/discovery/__tests__/status-mapper.test.ts with:
- Test exact match: 'discovery' -> column: 'discovery', confidence: 1.0
- Test alias: 'dev' -> column: 'build', confidence: 0.9
- Test fuzzy: 'in-progress' -> column: 'build'
- Test ambiguous: 'discovery-dev' -> isAmbiguous: true
- Test unknown status creates dynamic column name
- Test case insensitive matching
Run: npm test -- src/lib/discovery/__tests__/status-mapper.test.ts
  </verify>
  <done>Status strings map to Kanban columns with fuzzy matching and ambiguity detection</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All test files pass: `npm test -- src/lib/discovery/`
2. TypeScript compiles: `npx tsc --noEmit`
3. Modules export expected functions (check barrel file if created)
</verification>

<success_criteria>
- Pattern matching identifies pm-workspace folder structures
- _meta.json parsing is permissive and handles malformed files gracefully
- Status mapping uses fuzzy matching with ambiguity detection
- All modules have passing unit tests
- Types are exported for use by discovery API
</success_criteria>

<output>
After completion, create `.planning/phases/02-structure-discovery-a-workspace-population/02-01-SUMMARY.md`
</output>
