# Codebase Concerns

**Analysis Date:** 2026-01-25

## Tech Debt

**Incomplete Jury Score Validation:**
- Issue: Jury score checking gate is stubbed out with auto-pass fallback
- Files: `src/lib/execution/stage-executors/index.ts:280-288`
- Impact: Quality gates on stage transitions may not enforce intended quality standards. Runs can advance stages even if jury evaluations don't meet thresholds.
- Fix approach: Implement `checkJuryScore()` to fetch jury evaluations from database, calculate aggregate score, and return boolean based on configurable thresholds.

**Missing Transaction Support for Data Consistency:**
- Issue: No database transactions used despite multi-step mutations (create project → create stages → create documents)
- Files: `src/lib/db/queries.ts`, `src/lib/jobs/executor.ts`, `src/lib/execution/stage-executors/index.ts`
- Impact: Partial failures leave database in inconsistent state. If job creation fails mid-way, project stages may exist without documents or vice versa.
- Fix approach: Wrap related mutations in Drizzle transactions: `db.transaction(async (tx) => { ... })`

**Hardcoded Connection Pool Configuration:**
- Issue: PostgreSQL connection pool created with default settings (no pooling config)
- Files: `src/lib/db/index.ts:31-33`
- Impact: Potential connection exhaustion in production under high concurrency. No connection limit enforcement.
- Fix approach: Add `max`, `min`, `idleTimeoutMillis` settings to `pg.Pool` configuration based on deployment environment.

**Large Monolithic Query File:**
- Issue: `queries.ts` contains 2,345 lines with all database queries in single file
- Files: `src/lib/db/queries.ts`
- Impact: Difficult to navigate, maintain, and test. Hard to reason about query dependencies. Query reuse across concerns.
- Fix approach: Split into domain-specific query modules: `workspace-queries.ts`, `project-queries.ts`, `job-queries.ts`, etc.

## Known Bugs

**Race Condition in Job Claiming:**
- Symptoms: Multiple workers can claim the same job, leading to duplicate execution
- Files: `src/lib/execution/worker.ts:140-160` (claim logic), `src/lib/db/queries.ts` (claimRun)
- Trigger: Run `getPendingJobs() → claimRun()` simultaneously with multiple workers without SELECT FOR UPDATE
- Workaround: Implement worker heartbeat timeout (already partially done) and manual reconciliation
- Fix approach: Use `SELECT FOR UPDATE` in claimRun query to lock job rows before claiming

**Incomplete Form Submission in NotificationInbox:**
- Symptoms: Navigation doesn't work when clicking on inbox items
- Files: `src/components/inbox/NotificationInbox.tsx:487`
- Trigger: Component has TODO for implementing full inbox navigation
- Impact: Users can view notifications but can't navigate to related content in production
- Fix approach: Implement proper routing based on notification type (projects/signals/jobs)

**Jury Evaluation Display Inconsistency:**
- Symptoms: Jury scores not enforced in stage gates, but may be displayed to users
- Files: `src/lib/execution/stage-executors/index.ts:284`
- Impact: Users see quality gates listed but system ignores them, causing confusion

## Security Considerations

**XSS Risk in Code Highlighting Component:**
- Risk: `dangerouslySetInnerHTML` used with syntax-highlighted HTML from Shiki
- Files: `src/components/animate-ui/primitives/animate/code-block.tsx:153`, `src/components/animate-ui/components/animate/code-tabs.tsx:141`
- Current mitigation: HTML generated by trusted Shiki library, code input is from internal sources only
- Recommendations:
  - Add Content Security Policy header to prevent inline script injection
  - Consider using React-compatible Shiki output instead of `dangerouslySetInnerHTML`
  - Add DOMPurify sanitization as defense-in-depth if ever accepting user-supplied code

**Environment Variable Exposure in Client-Side Code:**
- Risk: Composio API key stored in workspace settings (jsonb column) which may be exposed via API
- Files: `src/lib/db/schema.ts:98` (composio?.apiKey), `src/components/settings/IntegrationsSettingsCard.tsx`
- Current mitigation: API key should only be sent client-side for OAuth flows
- Recommendations:
  - Move API keys to server-only environment variables or secrets manager
  - Implement secure token exchange (server signs key, client uses signature)
  - Never return full API keys in API responses

**Path Traversal in Knowledgebase Sync:**
- Risk: User-supplied context paths concatenated without validation
- Files: `src/lib/knowledgebase/sync.ts:35-46`, `src/lib/knowledgebase.ts:19-46`
- Current mitigation: `path.resolve()` resolves `..` sequences
- Recommendations:
  - Add explicit validation: reject paths containing `..` or absolute paths
  - Use `path.relative()` to detect escape attempts
  - Whitelist allowed context path patterns per workspace

**Unvalidated GitHub API Integration:**
- Risk: No validation of GitHub repo paths or branch names before git operations
- Files: `src/lib/git/branches.ts`, `src/app/api/github/repos/route.ts`
- Current mitigation: Operations limited to authenticated workspace
- Recommendations:
  - Validate repo paths match expected format (owner/repo)
  - Validate branch names against git naming conventions
  - Add timeout protection for long-running git operations

## Performance Bottlenecks

**Full-Table Scan for Pending Jobs:**
- Problem: `getPendingJobs()` retrieves all pending jobs without pagination
- Files: `src/lib/jobs/processor.ts:36-54`, called in polling loop
- Cause: No limit applied to initial query, though limit parameter exists
- Impact: Scales linearly with pending job count. Can timeout with thousands of jobs.
- Improvement path:
  - Use pagination with cursor-based loading
  - Add index on (workspaceId, status, createdAt)
  - Implement priority-based fetching (by job type, workspace)

**Polling Overhead with Adaptive Intervals:**
- Problem: Even with adaptive polling (5s active, 60s idle), creates significant DB load
- Files: `src/hooks/useJobPolling.ts:53-55`, `src/execution-worker.ts:20`
- Cause: Browser-side polling duplicates server-side worker polling
- Impact: Unnecessary database queries and WebSocket-like behavior over HTTP
- Improvement path:
  - Implement WebSocket or Server-Sent Events for real-time updates
  - Remove client-side polling when server worker is active
  - Use batch polling for multiple projects

**Large Component Tree Re-renders:**
- Problem: Components like `ProjectDetailModal` (1,174 lines), `ColumnsSettingsCard` (862 lines) re-render on any prop change
- Files: `src/components/kanban/ProjectDetailModal.tsx`, `src/components/settings/ColumnsSettingsCard.tsx`
- Cause: Monolithic components without memoization or state isolation
- Impact: UI lag when updating job status, project names, or column configs
- Improvement path:
  - Split into smaller memoized subcomponents
  - Use `React.memo()` for expensive renders
  - Implement context for deeply nested prop drilling

**Vector Embedding Synchronization:**
- Problem: All embedding operations synchronous during knowledge base sync
- Files: `src/lib/knowledgebase/sync.ts`, `src/lib/ai/embeddings.ts`
- Cause: Sequential processing of documents for vectorization
- Impact: Knowledge base sync blocks other operations for large repositories (100+ files)
- Improvement path:
  - Use batch embedding API calls
  - Implement queue-based background processing
  - Add incremental sync (only new/modified files)

## Fragile Areas

**Stage Executor Dispatcher:**
- Files: `src/lib/execution/stage-executors/index.ts:98-120`
- Why fragile: Manual if/else dispatch by stage name. Adding new stages requires modifying dispatcher. No compile-time safety for missing handlers.
- Safe modification:
  - Use factory pattern: `const executors: Record<ProjectStage, StageExecutor> = { discovery: executeDiscovery, ... }`
  - Add TypeScript exhaustiveness check to prevent missing handlers
  - Keep stage list in schema type, not duplicated in executor
- Test coverage: No unit tests for stage dispatch logic

**Job Status Transitions:**
- Files: `src/lib/jobs/processor.ts`, `src/lib/db/queries.ts` (updateJobStatus)
- Why fragile: No validation of invalid state transitions (e.g., failed → pending). Multiple places update job status independently.
- Safe modification:
  - Create `JobStateTransition` type with allowed transitions
  - Use single transition function: `transitionJobStatus(jobId, oldStatus, newStatus)`
  - Reject invalid transitions at database level with CHECK constraints
- Test coverage: Some test coverage in `src/__tests__/execution/skill-summaries.test.ts` but incomplete

**Composio Integration Assumptions:**
- Files: `src/lib/composio/service.ts`, `src/app/api/workspaces/[id]/integrations/status/route.ts`
- Why fragile: API integration assumes specific response shapes without validation. Silent failures on `items?.status` access.
- Safe modification:
  - Add Zod schemas for Composio API responses
  - Validate response structure before accessing nested properties
  - Implement circuit breaker for failed integration checks
- Test coverage: No tests for Composio integration error paths

**Webhook Auth without Rate Limiting:**
- Files: `src/lib/webhooks/auth.ts`, `src/lib/webhooks/processor.ts`
- Why fragile: Webhook endpoints validate signature but don't rate limit replay attacks
- Safe modification:
  - Add nonce/timestamp validation to webhook signature
  - Implement per-webhook-key rate limiting
  - Add request deduplication using webhook ID + timestamp
- Test coverage: Minimal webhook testing

## Scaling Limits

**Database Connection Pool:**
- Current capacity: Default pg.Pool (no max specified, defaults to 10 connections)
- Limit: Will exhaust connections at ~10 concurrent requests when each operation opens a connection
- Scaling path:
  - Configure pool size based on deployment environment
  - Implement connection pooling proxy (pgBouncer) for production
  - Monitor with `pool.activeCount` and circuit breaker

**Job Processing Throughput:**
- Current capacity: Single execution worker with MAX_CONCURRENT=1 (default)
- Limit: ~0.5 jobs/sec per workspace assuming 2s execution time
- Scaling path:
  - Increase MAX_CONCURRENT environment variable
  - Implement multiple worker processes/containers
  - Add job prioritization queue (high priority → low priority)

**Knowledge Base Vectorization:**
- Current capacity: Sequential embedding of files (~0.5 files/sec with OpenAI)
- Limit: Knowledge base sync blocks for 2+ minutes with 100+ files
- Scaling path:
  - Implement batch embedding API calls (10 files at once)
  - Use background queue for embedding jobs
  - Cache embeddings per file hash

**Real-time Notifications:**
- Current capacity: HTTP polling creates N requests/sec across all browsers
- Limit: 1,000 active users = 5,000 polls/min (without visibility detection)
- Scaling path:
  - Migrate to WebSocket or Server-Sent Events
  - Implement Redis pub/sub for multi-instance deployments
  - Add client-side request batching

## Dependencies at Risk

**next-auth@5.0.0-beta.30 (Beta Version):**
- Risk: Using beta version in production without stability guarantees
- Impact: Breaking changes possible in minor updates. Security patches delayed.
- Migration plan: Migrate to v5 stable when released, or downgrade to v4 if stability critical

**@composio/core@0.5.5 (Early Stage):**
- Risk: Low adoption, API changes likely, limited production track record
- Impact: Integration may break with upstream updates. Limited community support for issues.
- Migration plan: Monitor for v1.0 release. Consider building integration abstraction layer for easier swaps.

**pg@8.17.1 (Major Version):**
- Risk: No security advisories, but pg driver occasionally has connection leak issues
- Impact: Potential memory leaks over long-running worker processes
- Migration plan: Add connection pool monitoring and periodic restart strategy. Consider postgres.js as alternative.

**React 19 (Latest Major):**
- Risk: Very recent release (Feb 2025 cutoff), limited production battle-testing
- Impact: Potential issues with Server Components, hydration edge cases
- Migration plan: Monitor Next.js and React release notes. Have rollback plan to React 18.

## Missing Critical Features

**Audit Logging:**
- Problem: No audit trail for user actions (who created job, modified project, changed settings)
- Blocks: GDPR compliance, security investigation, user accountability
- Workaround: Query activity_logs table (if populated) manually
- Recommended: Implement middleware that logs all state mutations with user context

**Multi-Tenancy Isolation:**
- Problem: No row-level security or data isolation verification
- Blocks: Hosting multiple customers safely. One query vulnerability = all data exposed.
- Workaround: Run separate database per workspace
- Recommended: Implement RLS policies in PostgreSQL enforced at query level

**Error Recovery for Failed Jobs:**
- Problem: Failed jobs require manual retry. No automatic retry with backoff strategy.
- Blocks: Resilience for transient failures (network timeouts, service degradation)
- Workaround: Manually trigger retry via UI
- Recommended: Implement exponential backoff with max retries. Different retry strategy per failure type.

**Job Cancellation:**
- Problem: Running jobs can't be cancelled. Only "failed" or "completed" states.
- Blocks: Users can't abort long-running operations
- Workaround: Kill worker process (crude)
- Recommended: Add "cancelled" state, implement safe cancellation in stage executors

## Test Coverage Gaps

**Database Query Functions (2,345 lines of queries.ts):**
- What's not tested: Most CRUD operations, complex queries with joins, transaction behavior
- Files: `src/lib/db/queries.ts`
- Risk: Schema changes break queries silently. Data mutations produce incorrect results.
- Priority: High - affects all application data

**Job Executor Logic:**
- What's not tested: Job validation, executor dispatch, error handling paths
- Files: `src/lib/jobs/executor.ts`
- Risk: Invalid jobs execute, wrong executor selected, errors not handled
- Priority: High - core business logic

**Stage Executors and Runners:**
- What's not tested: Individual stage execution, verification criteria, task loops
- Files: `src/lib/execution/stage-executors/`, `src/lib/execution/run-manager.ts`
- Risk: Stages fail silently, verification bypassed, state corruption
- Priority: High - production-critical

**Git Integration (Branches, Commits):**
- What's not tested: Git command execution, branch creation, commit logic
- Files: `src/lib/git/branches.ts`
- Risk: Malformed commits, failed pushes, corrupted repository state
- Priority: High - modifies external system

**API Route Handlers (20+ routes):**
- What's not tested: Permission checks, input validation, error responses
- Files: `src/app/api/**`
- Risk: Security bypass, SSRF, injection attacks
- Priority: Critical - attack surface

**Permission System:**
- What's not tested: Role transitions, cross-workspace access, edge cases
- Files: `src/lib/permissions.ts`
- Risk: Users access unauthorized resources or actions
- Priority: Critical - security

**Webhook Processing:**
- What's not tested: Signature validation, duplicate detection, error recovery
- Files: `src/lib/webhooks/processor.ts`, `src/lib/webhooks/auth.ts`
- Risk: Forged webhooks processed, duplicate events applied
- Priority: Medium - external integration

**Components with Complex Logic:**
- What's not tested: Event handlers, state updates, conditional rendering
- Files: `src/components/kanban/ProjectDetailModal.tsx`, `src/components/inbox/NotificationInbox.tsx`, `src/components/settings/ColumnsSettingsCard.tsx`
- Risk: UI bugs, missing features, broken interactions
- Priority: Medium - user experience

**Test File Count:** 11 test files for 422 source files = ~2.6% coverage by file count

---

*Concerns audit: 2026-01-25*
