/**
 * Document Generation Tools
 * 
 * NOTE: These tools are kept for backwards compatibility but are NOT the primary
 * way to generate documents. The recommended flow is:
 * 
 * 1. Jobs are created in the orchestrator with status "pending"
 * 2. Cursor AI processes them via MCP CRUD tools (get-pending-jobs, complete-job)
 * 3. Cursor generates content using its own AI credentials
 * 
 * These direct generation tools require ANTHROPIC_API_KEY to be set and are
 * useful for testing or direct invocation outside the job system.
 */

import type {
  GeneratePRDInput,
  GenerateDesignBriefInput,
  GenerateEngineeringSpecInput,
  GenerateGTMBriefInput,
  ToolResult,
} from "../types.js";

// ============================================
// STUB IMPLEMENTATIONS
// ============================================

/**
 * Generate PRD - Stub that returns instructions for Cursor
 * 
 * For actual generation, use the job system:
 * 1. Create a job with type "generate_prd"
 * 2. Process via get-pending-jobs + complete-job MCP tools
 */
export async function generatePRD(input: GeneratePRDInput): Promise<ToolResult<string>> {
  // Return a template/instructions instead of calling Anthropic directly
  const template = `# ${input.projectName} - PRD

## Instructions for Cursor AI

This PRD should be generated by Cursor AI using its credentials.
Use the job processing system:

1. Call \`get-pending-jobs\` to find this job
2. Read company context from elmer-docs/company-context/
3. Generate the PRD following the template below
4. Call \`complete-job\` with the generated content

## PRD Template

### Problem Statement
[What problem are we solving? Include user quotes from research]

### Target Personas
[Who is this for? Reference company personas]

### Success Metrics
[How do we measure success?]

### User Journey
Current state â†’ Desired state

### MVP Scope
#### Must Have
- ...

#### Nice to Have
- ...

### Out of Scope
[What are we NOT building?]

### Open Questions
[What still needs answers?]

---

## Context Provided

${input.research ? `### Research\n${input.research.slice(0, 500)}...\n` : "No research provided"}
${input.transcript ? `### Transcript\n${input.transcript.slice(0, 500)}...\n` : "No transcript provided"}
${input.companyContext ? `### Company Context\n${input.companyContext.slice(0, 500)}...\n` : "No company context provided"}
${input.personas?.length ? `### Personas\n${input.personas.join(", ")}\n` : "No personas specified"}
`;

  return { 
    success: true, 
    data: template,
  };
}

/**
 * Generate Design Brief - Stub that returns instructions for Cursor
 */
export async function generateDesignBrief(input: GenerateDesignBriefInput): Promise<ToolResult<string>> {
  const template = `# Design Brief

## Instructions for Cursor AI

This design brief should be generated by Cursor AI using its credentials.

## Design Brief Template

### Design Goals
[What are we trying to achieve visually and experientially?]

### User Experience Considerations
[Key UX principles for this feature]

### Visual Design Direction
[Colors, typography, spacing, etc.]

### Interaction Patterns
[How users interact with this feature]

### Accessibility Requirements
[WCAG compliance, keyboard navigation, screen readers]

### Component Specifications
[List of components needed]

### Edge Cases and Error States
[What happens when things go wrong?]

---

## PRD Summary
${input.prd.slice(0, 1000)}...

${input.designLanguage ? `### Design Language\n${input.designLanguage}\n` : ""}
${input.existingPatterns?.length ? `### Existing Patterns\n${input.existingPatterns.join("\n")}\n` : ""}
`;

  return { success: true, data: template };
}

/**
 * Generate Engineering Spec - Stub that returns instructions for Cursor
 */
export async function generateEngineeringSpec(input: GenerateEngineeringSpecInput): Promise<ToolResult<string>> {
  const template = `# Engineering Specification

## Instructions for Cursor AI

This engineering spec should be generated by Cursor AI using its credentials.

## Engineering Spec Template

### Technical Overview
[High-level architecture]

### Data Models
[Database schemas, types]

### API Endpoints
[REST/GraphQL endpoints if applicable]

### Component Structure
[React component hierarchy]

### State Management
[How state is managed]

### Integration Points
[External services, APIs]

### Testing Strategy
[Unit, integration, e2e tests]

### Performance Considerations
[Optimization strategies]

### Security Considerations
[Auth, data protection]

### Migration Plan
[How to roll out safely]

---

## PRD Summary
${input.prd.slice(0, 1000)}...

${input.designBrief ? `### Design Brief Summary\n${input.designBrief.slice(0, 500)}...\n` : ""}
${input.techStack ? `### Tech Stack\n${input.techStack}\n` : ""}
`;

  return { success: true, data: template };
}

/**
 * Generate GTM Brief - Stub that returns instructions for Cursor
 */
export async function generateGTMBrief(input: GenerateGTMBriefInput): Promise<ToolResult<string>> {
  const template = `# Go-to-Market Brief

## Instructions for Cursor AI

This GTM brief should be generated by Cursor AI using its credentials.

## GTM Brief Template

### Feature Positioning
[How we position this feature]

### Target Audience
[Who we're targeting]

### Key Benefits
[Value propositions]

### Competitive Differentiation
[How we're different]

### Launch Timeline
[Recommended timeline]

### Marketing Channels
[Where to promote]

### Success Metrics
[How to measure launch success]

### Sales Enablement
[What sales team needs]

### Customer Communication
[How to communicate to existing customers]

---

## PRD Summary
${input.prd.slice(0, 1000)}...

${input.targetPersonas?.length ? `### Target Personas\n${input.targetPersonas.join("\n")}\n` : ""}
${input.marketingGuidelines ? `### Marketing Guidelines\n${input.marketingGuidelines}\n` : ""}
`;

  return { success: true, data: template };
}
