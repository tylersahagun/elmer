/**
 * Linear Integration Tools
 * 
 * NOTE: These tools are kept for backwards compatibility but are NOT the primary
 * way to generate tickets. The recommended flow is:
 * 
 * 1. Jobs are created in the orchestrator with status "pending"
 * 2. Cursor AI processes them via MCP CRUD tools (get-pending-jobs, complete-job)
 * 3. Cursor generates content using its own AI credentials
 */

import type {
  GenerateTicketsInput,
  ValidateTicketsInput,
  ToolResult,
} from "../types.js";

// ============================================
// TICKET TYPES
// ============================================

export interface GeneratedTicket {
  title: string;
  description: string;
  type: "feature" | "task" | "bug" | "chore";
  priority: "urgent" | "high" | "medium" | "low";
  estimatedPoints: number;
  labels: string[];
  dependencies: string[];
  acceptanceCriteria: string[];
  prototypeComponentLink?: string;
}

export interface TicketValidationResult {
  isValid: boolean;
  coverage: number; // 0-1, how much of the PRD is covered
  missingTickets: string[];
  redundantTickets: string[];
  suggestions: string[];
  dependencyIssues: string[];
}

// ============================================
// GENERATE TICKETS - STUB
// ============================================

/**
 * Generate tickets - Stub that returns instructions for Cursor
 * 
 * For actual generation, use the job system:
 * 1. Create a job with type "generate_tickets"
 * 2. Process via get-pending-jobs + complete-job MCP tools
 */
export async function generateTickets(
  input: GenerateTicketsInput
): Promise<ToolResult<GeneratedTicket[]>> {
  const placeholder: GeneratedTicket[] = [
    {
      title: "[Cursor AI should generate tickets from engineering spec]",
      description: "This ticket should be generated by Cursor AI using its credentials",
      type: "feature",
      priority: "high",
      estimatedPoints: 3,
      labels: ["generated", "needs-review"],
      dependencies: [],
      acceptanceCriteria: [
        "Use the job system: get-pending-jobs + complete-job",
        "Break down engineering spec into implementable tickets",
        "Include acceptance criteria for each ticket",
      ],
      prototypeComponentLink: input.prototypeComponents?.[0],
    },
  ];

  return { success: true, data: placeholder };
}

// ============================================
// VALIDATE TICKETS - STUB
// ============================================

/**
 * Validate tickets - Stub that returns instructions for Cursor
 */
export async function validateTickets(
  input: ValidateTicketsInput
): Promise<ToolResult<TicketValidationResult>> {
  const placeholder: TicketValidationResult = {
    isValid: false,
    coverage: 0,
    missingTickets: [
      "[Cursor AI should analyze PRD coverage]",
      "[Identify missing implementation tickets]",
    ],
    redundantTickets: [],
    suggestions: [
      "Use the job system for proper AI-powered validation",
      "Cursor AI should compare tickets against PRD requirements",
    ],
    dependencyIssues: [],
  };

  return { success: true, data: placeholder };
}

// ============================================
// LINEAR API INTEGRATION (Placeholder)
// ============================================

// Note: Actual Linear API integration would go here
// This requires the Linear SDK and API key

export interface LinearConfig {
  apiKey: string;
  teamId: string;
}

export async function createLinearIssue(
  config: LinearConfig,
  ticket: GeneratedTicket
): Promise<ToolResult<{ id: string; identifier: string; url: string }>> {
  // Placeholder - would use @linear/sdk
  console.log("Would create Linear issue:", ticket.title);
  
  return {
    success: true,
    data: {
      id: "placeholder-id",
      identifier: "ENG-XXX",
      url: "https://linear.app/team/issue/ENG-XXX",
    },
  };
}

export async function syncLinearStatus(
  config: LinearConfig,
  issueId: string
): Promise<ToolResult<{ status: string; updatedAt: string }>> {
  // Placeholder - would use @linear/sdk
  console.log("Would sync Linear issue status:", issueId);
  
  return {
    success: true,
    data: {
      status: "in_progress",
      updatedAt: new Date().toISOString(),
    },
  };
}
