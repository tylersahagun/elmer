---
phase: 14-file-and-paste-upload
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - orchestrator/src/app/api/signals/upload/route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can POST a file to /api/signals/upload and receive signal creation response"
    - "File is validated for type (PDF, CSV, TXT) and size (max 5MB)"
    - "Text is extracted from file and stored as signal verbatim"
    - "Signal is created with source='upload' and file metadata in sourceMetadata"
  artifacts:
    - path: "orchestrator/src/app/api/signals/upload/route.ts"
      provides: "File upload endpoint for signal creation"
      exports: ["POST"]
  key_links:
    - from: "orchestrator/src/app/api/signals/upload/route.ts"
      to: "orchestrator/src/lib/files/extractText.ts"
      via: "extractTextFromFile import"
      pattern: "import.*extractTextFromFile.*from.*@/lib/files"
    - from: "orchestrator/src/app/api/signals/upload/route.ts"
      to: "orchestrator/src/lib/db/queries.ts"
      via: "createSignal import"
      pattern: "import.*createSignal.*from.*@/lib/db/queries"
    - from: "orchestrator/src/app/api/signals/upload/route.ts"
      to: "orchestrator/src/lib/files/validators.ts"
      via: "validateFileContent import"
      pattern: "import.*validateFileContent.*from.*@/lib/files"
---

<objective>
Create the file upload API endpoint that extracts text from files and creates signals.

Purpose: Enable server-side file processing for signal ingestion. This endpoint receives file uploads via FormData, extracts text using the utilities from Plan 01, and creates signals with source='upload'.

Output: /api/signals/upload POST endpoint
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-file-&-paste-upload/14-RESEARCH.md
@.planning/phases/14-file-&-paste-upload/14-01-SUMMARY.md

# Existing patterns
@orchestrator/src/app/api/signals/route.ts
@orchestrator/src/app/api/webhooks/signals/route.ts
@orchestrator/src/lib/permissions.ts
@orchestrator/src/lib/files/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload API route</name>
  <files>orchestrator/src/app/api/signals/upload/route.ts</files>
  <action>
Create the upload endpoint at /api/signals/upload:

```typescript
// orchestrator/src/app/api/signals/upload/route.ts

import { NextRequest, NextResponse } from "next/server";
import { after } from "next/server";
import { nanoid } from "nanoid";
import {
  requireWorkspaceAccess,
  handlePermissionError,
  PermissionError,
} from "@/lib/permissions";
import {
  extractTextFromFile,
  validateFileContent,
  MAX_FILE_SIZE_BYTES,
  MAX_FILE_SIZE_DISPLAY,
} from "@/lib/files";
import { createSignal } from "@/lib/db/queries";
import { db } from "@/lib/db";
import { activityLogs } from "@/lib/db/schema";

const ALLOWED_MIME_TYPES = ["application/pdf", "text/csv", "text/plain"];
const ALLOWED_EXTENSIONS = ["pdf", "csv", "txt"];

/**
 * POST /api/signals/upload
 * Upload a file (PDF, CSV, TXT), extract text, create signal
 *
 * FormData fields:
 * - file: File (required) - The file to process
 * - workspaceId: string (required) - Workspace to create signal in
 * - interpretation: string (optional) - User's interpretation of the content
 */
export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get("file") as File | null;
    const workspaceId = formData.get("workspaceId") as string | null;
    const interpretation = formData.get("interpretation") as string | null;

    // Validate required fields
    if (!file) {
      return NextResponse.json({ error: "File is required" }, { status: 400 });
    }
    if (!workspaceId) {
      return NextResponse.json(
        { error: "workspaceId is required" },
        { status: 400 }
      );
    }

    // Validate file size
    if (file.size > MAX_FILE_SIZE_BYTES) {
      return NextResponse.json(
        { error: `File too large. Maximum size is ${MAX_FILE_SIZE_DISPLAY}` },
        { status: 400 }
      );
    }

    // Validate file size > 0
    if (file.size === 0) {
      return NextResponse.json({ error: "File is empty" }, { status: 400 });
    }

    // Validate file type (MIME and/or extension)
    const extension = file.name.toLowerCase().split(".").pop() || "";
    const mimeValid = ALLOWED_MIME_TYPES.includes(file.type);
    const extensionValid = ALLOWED_EXTENSIONS.includes(extension);

    if (!mimeValid && !extensionValid) {
      return NextResponse.json(
        { error: "Invalid file type. Accepted: PDF, CSV, TXT" },
        { status: 400 }
      );
    }

    // Require member access to create signals
    await requireWorkspaceAccess(workspaceId, "member");

    // Convert file to buffer
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Server-side content validation (magic bytes for PDFs)
    const contentValidation = await validateFileContent(buffer, file.type);
    if (!contentValidation.valid) {
      return NextResponse.json(
        { error: contentValidation.error },
        { status: 400 }
      );
    }

    // Extract text from file
    let extraction;
    try {
      extraction = await extractTextFromFile(buffer, file.name, file.type);
    } catch (extractionError) {
      const message =
        extractionError instanceof Error
          ? extractionError.message
          : "Could not extract text from file";
      return NextResponse.json({ error: message }, { status: 400 });
    }

    // Verify extraction produced text
    if (!extraction.text || extraction.text.trim().length === 0) {
      return NextResponse.json(
        { error: "Could not extract text from file. File may be empty or unreadable." },
        { status: 400 }
      );
    }

    // Create signal with extracted text
    const sourceRef = `upload-${Date.now()}-${nanoid(6)}`;
    const signal = await createSignal({
      workspaceId,
      verbatim: extraction.text,
      interpretation: interpretation?.trim() || undefined,
      source: "upload",
      sourceRef,
      sourceMetadata: {
        fileName: file.name,
        fileSize: file.size,
        fileType: extraction.metadata.fileType,
        ...extraction.metadata,
      },
    });

    // Log activity asynchronously (queue-first pattern from Phase 13)
    after(async () => {
      try {
        await db.insert(activityLogs).values({
          id: nanoid(),
          workspaceId,
          action: "signal.created",
          targetType: "signal",
          targetId: signal.id,
          metadata: {
            source: "upload",
            fileName: file.name,
            fileType: extraction.metadata.fileType,
            charCount: extraction.metadata.charCount,
          },
          createdAt: new Date(),
        });
      } catch (logError) {
        // Never throw in after() context - log errors for debugging (Phase 13 pattern)
        console.error("Failed to log upload activity:", logError);
      }
    });

    return NextResponse.json(
      {
        success: true,
        signal: {
          id: signal.id,
          verbatim:
            signal.verbatim.length > 200
              ? signal.verbatim.slice(0, 200) + "..."
              : signal.verbatim,
          source: signal.source,
          status: signal.status,
        },
        extraction: {
          fileType: extraction.metadata.fileType,
          fileName: extraction.metadata.originalFileName,
          charCount: extraction.metadata.charCount,
          pageCount: extraction.metadata.pageCount,
          rowCount: extraction.metadata.rowCount,
        },
      },
      { status: 201 }
    );
  } catch (error) {
    if (error instanceof PermissionError) {
      const { error: message, status } = handlePermissionError(error);
      return NextResponse.json({ error: message }, { status });
    }
    console.error("Upload failed:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Upload failed" },
      { status: 500 }
    );
  }
}
```

Key behaviors following existing patterns:
- Uses requireWorkspaceAccess("member") like existing signals POST route
- Uses createSignal from queries.ts like existing signals route
- Uses after() for activity logging like webhook processor (Phase 13)
- Never throws in after() context (Phase 13 decision)
- Returns 201 on success with signal summary
- Returns 400 for validation errors, 401/403 for auth errors, 500 for server errors
- sourceRef uses timestamp + nanoid for uniqueness
- sourceMetadata captures all file metadata
  </action>
  <verify>
Run `npx tsc --noEmit` from orchestrator directory to confirm no TypeScript errors.
Run `npm run lint` to check for linting issues.
Verify file exists at orchestrator/src/app/api/signals/upload/route.ts
  </verify>
  <done>Upload API endpoint created with file validation, text extraction, and signal creation</done>
</task>

</tasks>

<verification>
Run from orchestrator directory:

```bash
# Verify TypeScript compiles
npx tsc --noEmit

# Verify lint passes
npm run lint

# Verify endpoint file exists
ls -la src/app/api/signals/upload/

# Manual test (requires running server):
# 1. Start dev server: npm run dev
# 2. Create a test.txt file with some content
# 3. Use curl to test:
# curl -X POST http://localhost:3000/api/signals/upload \
#   -H "Cookie: <your-session-cookie>" \
#   -F "file=@test.txt" \
#   -F "workspaceId=<your-workspace-id>"
```

Expected: 201 response with signal ID and extraction metadata.
</verification>

<success_criteria>
1. /api/signals/upload/route.ts exists and exports POST handler
2. File validation rejects oversized files (>5MB) and invalid types
3. Text extraction called for PDF, CSV, TXT files
4. Signal created with source="upload" and file metadata in sourceMetadata
5. Activity logged asynchronously via after()
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-file-&-paste-upload/14-02-SUMMARY.md`
</output>
