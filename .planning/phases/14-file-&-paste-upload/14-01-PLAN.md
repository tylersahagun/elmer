---
phase: 14-file-and-paste-upload
plan: 01
type: execute
wave: 1
depends_on: []
# Note: Cross-phase dependency (Phase 14 depends on Phase 13) is handled by the
# orchestrator. Plan-level depends_on is for intra-phase dependencies only.
# Phase 13 completion is a prerequisite for starting Phase 14 execution.
files_modified:
  - orchestrator/package.json
  - orchestrator/src/lib/files/extractText.ts
  - orchestrator/src/lib/files/validators.ts
  - orchestrator/src/lib/files/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PDF files can be parsed to extract plain text"
    - "CSV files can be parsed and converted to readable text"
    - "TXT files can be read as UTF-8 text"
    - "File validation rejects unsupported types and oversized files"
  artifacts:
    - path: "orchestrator/src/lib/files/extractText.ts"
      provides: "Text extraction utilities for PDF, CSV, TXT"
      exports: ["extractTextFromFile", "ExtractionResult"]
    - path: "orchestrator/src/lib/files/validators.ts"
      provides: "File validation utilities"
      exports: ["validateFile", "validateFileContent", "ACCEPTED_FILE_TYPES", "MAX_FILE_SIZE_BYTES"]
    - path: "orchestrator/src/lib/files/index.ts"
      provides: "Barrel exports for files module"
  key_links:
    - from: "orchestrator/src/lib/files/extractText.ts"
      to: "unpdf"
      via: "import extractText from unpdf"
      pattern: "import.*from.*unpdf"
    - from: "orchestrator/src/lib/files/extractText.ts"
      to: "papaparse"
      via: "import Papa from papaparse"
      pattern: "import.*Papa.*from.*papaparse"
---

<objective>
Create file parsing infrastructure for extracting text from uploaded files (PDF, CSV, TXT).

Purpose: Establish the foundational utilities for file-based signal ingestion. These utilities will be used by the upload API endpoint to extract text from documents before creating signals.

Output: Text extraction and validation utilities in orchestrator/src/lib/files/

Note: "Paste text with source selection" (Success Criterion 2 in ROADMAP) is already implemented in Phase 12 via CreateSignalModal. This phase focuses on FILE upload capability only.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-file-&-paste-upload/14-RESEARCH.md

# Existing patterns
@orchestrator/src/lib/webhooks/processor.ts
@orchestrator/src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add file parsing dependencies</name>
  <files>orchestrator/package.json</files>
  <action>
Add the required npm packages for file parsing:

```bash
cd orchestrator && npm install unpdf papaparse && npm install -D @types/papaparse
```

Dependencies to add:
- `unpdf` - PDF text extraction (serverless-optimized, zero native deps)
- `papaparse` - CSV parsing (fastest JS CSV parser, RFC 4180 compliant)
- `@types/papaparse` - TypeScript types for papaparse

Note: `react-dropzone` will be added in Plan 03 when implementing the UI.

Do NOT add `@vercel/blob` - research recommends starting with local storage and 5MB client-side limit for MVP.
  </action>
  <verify>
Run `npm ls unpdf papaparse` from orchestrator directory to confirm packages installed.
Run `npx tsc --noEmit` to confirm no TypeScript errors introduced.
  </verify>
  <done>unpdf and papaparse installed with types, no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Create file validation utilities</name>
  <files>orchestrator/src/lib/files/validators.ts</files>
  <action>
Create validators.ts with file type and size validation:

```typescript
// orchestrator/src/lib/files/validators.ts

export const ACCEPTED_FILE_TYPES = {
  "application/pdf": [".pdf"],
  "text/csv": [".csv"],
  "text/plain": [".txt"],
} as const;

export const MAX_FILE_SIZE_BYTES = 5 * 1024 * 1024; // 5MB
export const MAX_FILE_SIZE_DISPLAY = "5MB";

// Magic bytes for PDF verification
const PDF_SIGNATURE = [0x25, 0x50, 0x44, 0x46]; // %PDF

export interface ValidationResult {
  valid: boolean;
  error?: string;
}

/**
 * Validate file before upload (client-side compatible)
 * Checks: size limit, file type (MIME + extension), empty file
 */
export function validateFile(file: File): ValidationResult {
  // Size check
  if (file.size > MAX_FILE_SIZE_BYTES) {
    return {
      valid: false,
      error: `File too large. Maximum size is ${MAX_FILE_SIZE_DISPLAY}`,
    };
  }

  // Empty file check
  if (file.size === 0) {
    return {
      valid: false,
      error: "File is empty",
    };
  }

  // Type check (MIME + extension)
  const acceptedMimes = Object.keys(ACCEPTED_FILE_TYPES);
  const acceptedExtensions = Object.values(ACCEPTED_FILE_TYPES).flat();
  const extension = `.${file.name.split(".").pop()?.toLowerCase()}`;

  const mimeValid = acceptedMimes.includes(file.type);
  const extensionValid = acceptedExtensions.includes(extension);

  if (!mimeValid && !extensionValid) {
    return {
      valid: false,
      error: "Invalid file type. Accepted: PDF, CSV, TXT",
    };
  }

  return { valid: true };
}

/**
 * Server-side content validation (magic bytes check for PDFs)
 * Call after receiving buffer on server
 */
export async function validateFileContent(
  buffer: Buffer,
  mimeType: string
): Promise<ValidationResult> {
  // For PDFs, verify magic bytes to detect spoofed MIME types
  if (mimeType === "application/pdf" || mimeType.includes("pdf")) {
    const fileStart = Array.from(buffer.subarray(0, PDF_SIGNATURE.length));
    const isPdf = PDF_SIGNATURE.every((byte, i) => fileStart[i] === byte);

    if (!isPdf) {
      return {
        valid: false,
        error: "File does not appear to be a valid PDF",
      };
    }
  }

  return { valid: true };
}

/**
 * Get allowed extensions as flat array for react-dropzone accept prop
 */
export function getAllowedExtensions(): string[] {
  return Object.values(ACCEPTED_FILE_TYPES).flat();
}
```

Key behaviors:
- validateFile() for client-side pre-upload checks (size, type, empty)
- validateFileContent() for server-side magic byte verification
- 5MB limit enforced client-side to stay under Vercel 4.5MB serverless limit
- Both MIME type AND extension checked (defense in depth)
  </action>
  <verify>
Run `npx tsc --noEmit` from orchestrator directory to confirm no TypeScript errors.
Verify file exists at orchestrator/src/lib/files/validators.ts
  </verify>
  <done>validators.ts created with validateFile, validateFileContent, and constants exported</done>
</task>

<task type="auto">
  <name>Task 3: Create text extraction utilities</name>
  <files>orchestrator/src/lib/files/extractText.ts</files>
  <action>
Create extractText.ts with PDF, CSV, and TXT extraction:

```typescript
// orchestrator/src/lib/files/extractText.ts

import { extractText as extractPdfText } from "unpdf";
import Papa from "papaparse";

export interface ExtractionResult {
  text: string;
  metadata: {
    fileType: "pdf" | "csv" | "txt";
    originalFileName: string;
    pageCount?: number;      // PDF only
    rowCount?: number;       // CSV only
    charCount: number;
  };
}

/**
 * Extract text from file buffer based on type
 * Main entry point for file text extraction
 */
export async function extractTextFromFile(
  buffer: Buffer,
  fileName: string,
  mimeType: string
): Promise<ExtractionResult> {
  const fileType = getFileType(mimeType, fileName);

  switch (fileType) {
    case "pdf":
      return extractFromPdf(buffer, fileName);
    case "csv":
      return extractFromCsv(buffer, fileName);
    case "txt":
      return extractFromTxt(buffer, fileName);
    default:
      throw new Error(`Unsupported file type: ${mimeType}`);
  }
}

/**
 * Determine file type from MIME type or extension
 */
function getFileType(mimeType: string, fileName: string): "pdf" | "csv" | "txt" {
  const extension = fileName.toLowerCase().split(".").pop();

  // Check MIME type first
  if (mimeType === "application/pdf") return "pdf";
  if (mimeType === "text/csv") return "csv";
  if (mimeType === "text/plain") return "txt";

  // Fall back to extension
  if (extension === "pdf") return "pdf";
  if (extension === "csv") return "csv";
  if (extension === "txt") return "txt";

  throw new Error(`Unknown file type: ${mimeType} (${fileName})`);
}

/**
 * Extract text from PDF using unpdf
 * unpdf is serverless-optimized and handles most PDF formats
 */
async function extractFromPdf(buffer: Buffer, fileName: string): Promise<ExtractionResult> {
  const result = await extractPdfText(buffer, { mergePages: true });
  const text = typeof result.text === "string" ? result.text.trim() : "";

  if (!text) {
    throw new Error(
      "Could not extract text from PDF. The file may be image-only (scanned) or password-protected."
    );
  }

  return {
    text,
    metadata: {
      fileType: "pdf",
      originalFileName: fileName,
      pageCount: result.totalPages,
      charCount: text.length,
    },
  };
}

/**
 * Extract text from CSV using papaparse
 * Converts rows to readable text format for signal verbatim
 */
async function extractFromCsv(buffer: Buffer, fileName: string): Promise<ExtractionResult> {
  const csvString = buffer.toString("utf-8");

  const parseResult = Papa.parse(csvString, {
    header: true,
    skipEmptyLines: true,
    transformHeader: (header) => header.trim(),
  });

  if (parseResult.errors.length > 0) {
    // Log but don't fail on non-critical parse errors
    console.warn("CSV parse warnings:", parseResult.errors);
  }

  const rows = parseResult.data as Record<string, string>[];

  if (rows.length === 0) {
    throw new Error("CSV file is empty or contains no valid data rows");
  }

  // Convert to readable text format
  // Each row becomes: "Row N: field1: value1, field2: value2, ..."
  const text = rows
    .map((row, i) => {
      const values = Object.entries(row)
        .filter(([_, value]) => value !== undefined && value !== "")
        .map(([key, value]) => `${key}: ${value}`)
        .join(", ");
      return `Row ${i + 1}: ${values}`;
    })
    .join("\n");

  return {
    text,
    metadata: {
      fileType: "csv",
      originalFileName: fileName,
      rowCount: rows.length,
      charCount: text.length,
    },
  };
}

/**
 * Extract text from TXT file
 * Simple UTF-8 decode with trimming
 */
async function extractFromTxt(buffer: Buffer, fileName: string): Promise<ExtractionResult> {
  const text = buffer.toString("utf-8").trim();

  if (!text) {
    throw new Error("TXT file is empty");
  }

  return {
    text,
    metadata: {
      fileType: "txt",
      originalFileName: fileName,
      charCount: text.length,
    },
  };
}
```

Key behaviors:
- extractTextFromFile() is the main entry point
- PDF: Uses unpdf with mergePages for single text output; throws on image-only PDFs
- CSV: Uses papaparse with header:true, converts rows to readable text format
- TXT: Simple UTF-8 decode
- All throw descriptive errors on empty/unreadable content
- Metadata includes file type, name, and type-specific counts
  </action>
  <verify>
Run `npx tsc --noEmit` from orchestrator directory to confirm no TypeScript errors.
Verify file exists at orchestrator/src/lib/files/extractText.ts
  </verify>
  <done>extractText.ts created with extractTextFromFile and ExtractionResult type exported</done>
</task>

<task type="auto">
  <name>Task 4: Create barrel exports for files module</name>
  <files>orchestrator/src/lib/files/index.ts</files>
  <action>
Create index.ts with barrel exports:

```typescript
// orchestrator/src/lib/files/index.ts

export {
  extractTextFromFile,
  type ExtractionResult,
} from "./extractText";

export {
  validateFile,
  validateFileContent,
  getAllowedExtensions,
  ACCEPTED_FILE_TYPES,
  MAX_FILE_SIZE_BYTES,
  MAX_FILE_SIZE_DISPLAY,
  type ValidationResult,
} from "./validators";
```

This allows clean imports:
```typescript
import { extractTextFromFile, validateFile, MAX_FILE_SIZE_BYTES } from "@/lib/files";
```
  </action>
  <verify>
Run `npx tsc --noEmit` from orchestrator directory to confirm barrel exports compile correctly.
Verify file exists at orchestrator/src/lib/files/index.ts
  </verify>
  <done>Barrel exports created at lib/files/index.ts</done>
</task>

</tasks>

<verification>
Run from orchestrator directory:

```bash
# Verify packages installed
npm ls unpdf papaparse

# Verify TypeScript compiles
npx tsc --noEmit

# Verify files exist
ls -la src/lib/files/
```

Expected: 3 files in lib/files (extractText.ts, validators.ts, index.ts), no TypeScript errors.
</verification>

<success_criteria>
1. unpdf and papaparse packages installed with types
2. extractText.ts exports extractTextFromFile function handling PDF, CSV, TXT
3. validators.ts exports validateFile, validateFileContent, and constants
4. index.ts provides clean barrel exports
5. All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-file-&-paste-upload/14-01-SUMMARY.md`
</output>
