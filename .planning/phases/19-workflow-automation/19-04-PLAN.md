---
phase: 19-workflow-automation
plan: 04
type: execute
wave: 3
depends_on: ["19-02", "19-03"]
files_modified:
  - orchestrator/src/lib/signals/processor.ts
  - orchestrator/src/app/api/cron/signal-automation/route.ts
  - orchestrator/vercel.json
autonomous: true

must_haves:
  truths:
    - "Signal processor calls automation check after processing"
    - "Cron endpoint checks all workspaces periodically"
    - "Cron endpoint is protected by CRON_SECRET"
    - "Automation runs async via after() pattern"
  artifacts:
    - path: "orchestrator/src/lib/signals/processor.ts"
      provides: "Integration with automation check"
      contains: "checkSignalAutomationForNewSignal"
    - path: "orchestrator/src/app/api/cron/signal-automation/route.ts"
      provides: "Cron endpoint for periodic automation"
      exports: ["GET"]
    - path: "orchestrator/vercel.json"
      provides: "Cron schedule configuration"
      contains: "signal-automation"
  key_links:
    - from: "orchestrator/src/lib/signals/processor.ts"
      to: "lib/automation/signal-automation.ts"
      via: "checkSignalAutomationForNewSignal import"
      pattern: "checkSignalAutomationForNewSignal"
---

<objective>
Wire automation into signal processing flow and add cron endpoint.

Purpose: Connect the automation engine to signal ingestion (event-driven) and add periodic cron check (backup). This completes the automation loop so signals automatically trigger actions when thresholds are met.

Output: Updated signal processor with automation hook, cron API endpoint, Vercel cron configuration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-workflow-automation/19-RESEARCH.md
@.planning/phases/19-workflow-automation/19-02-SUMMARY.md
@.planning/phases/19-workflow-automation/19-03-SUMMARY.md

# Existing signal processor
@orchestrator/src/lib/signals/processor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire automation check into signal processor</name>
  <files>orchestrator/src/lib/signals/processor.ts</files>
  <action>
Update `orchestrator/src/lib/signals/processor.ts` to call automation check after processing:

1. Add import at top:
```typescript
import { checkSignalAutomationForNewSignal } from "@/lib/automation/signal-automation";
```

2. In the `processSignalExtraction` function, after the classification block (around line 90), add automation check:

After this existing code:
```typescript
      } catch (classifyError) {
        // Classification failure should not fail the overall processing
        console.error(`Classification failed for signal ${signalId}:`, classifyError);
      }
    }
```

Add:
```typescript
    // Check if automation thresholds are now met (Phase 19)
    // This is async and won't block - runs after classification completes
    try {
      const updatedSignal = await getSignal(signalId);
      if (updatedSignal) {
        await checkSignalAutomationForNewSignal(
          updatedSignal.workspaceId,
          signalId
        );
      }
    } catch (autoError) {
      // Automation check failure should not fail signal processing
      console.error(`Automation check failed for signal ${signalId}:`, autoError);
    }
```

This ensures automation is checked after every signal is processed, but failures don't break the pipeline.
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Signal processor calls checkSignalAutomationForNewSignal after processing each signal</done>
</task>

<task type="auto">
  <name>Task 2: Create cron endpoint for periodic automation</name>
  <files>orchestrator/src/app/api/cron/signal-automation/route.ts</files>
  <action>
Create directory and file `orchestrator/src/app/api/cron/signal-automation/route.ts`:

```typescript
/**
 * GET /api/cron/signal-automation
 *
 * Cron endpoint for periodic signal automation checks.
 * Runs hourly to catch any missed triggers from event-driven flow.
 *
 * Protected by CRON_SECRET header (Vercel sets this automatically).
 *
 * Configure in vercel.json:
 * {
 *   "crons": [{
 *     "path": "/api/cron/signal-automation",
 *     "schedule": "0 * * * *"
 *   }]
 * }
 */

import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { workspaces } from "@/lib/db/schema";
import { checkSignalAutomation, type AutomationCheckResult } from "@/lib/automation/signal-automation";

export const maxDuration = 300; // 5 minutes max
export const dynamic = "force-dynamic";

interface WorkspaceResult {
  workspaceId: string;
  result?: AutomationCheckResult;
  error?: string;
}

export async function GET(request: NextRequest) {
  // Verify cron secret (Vercel sets this automatically for cron jobs)
  const authHeader = request.headers.get("authorization");
  const cronSecret = process.env.CRON_SECRET;

  // In development, allow without secret
  if (process.env.NODE_ENV === "production" && cronSecret) {
    if (authHeader !== `Bearer ${cronSecret}`) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
  }

  const startTime = Date.now();

  // Get all workspaces
  const workspaceList = await db
    .select({ id: workspaces.id, name: workspaces.name })
    .from(workspaces);

  const results: WorkspaceResult[] = [];

  // Process each workspace
  for (const workspace of workspaceList) {
    try {
      const result = await checkSignalAutomation(workspace.id);
      results.push({
        workspaceId: workspace.id,
        result,
      });

      // Log if any actions were triggered
      if (result.actionsTriggered.length > 0) {
        console.log(
          `[Cron] Workspace ${workspace.name}: ${result.actionsTriggered.length} actions triggered`
        );
      }
    } catch (error) {
      console.error(
        `[Cron] Automation check failed for workspace ${workspace.id}:`,
        error
      );
      results.push({
        workspaceId: workspace.id,
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  const duration = Date.now() - startTime;

  // Calculate summary
  const totalActions = results.reduce(
    (sum, r) => sum + (r.result?.actionsTriggered.length ?? 0),
    0
  );
  const errors = results.filter((r) => r.error).length;

  return NextResponse.json({
    success: true,
    timestamp: new Date().toISOString(),
    durationMs: duration,
    workspacesChecked: workspaceList.length,
    totalActionsTriggered: totalActions,
    errors,
    results,
  });
}
```
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Cron endpoint created at /api/cron/signal-automation with CRON_SECRET protection</done>
</task>

<task type="auto">
  <name>Task 3: Add cron configuration to vercel.json</name>
  <files>orchestrator/vercel.json</files>
  <action>
Check if `orchestrator/vercel.json` exists. If it does, add the cron configuration to it. If not, create it.

The file should include (merge with existing if present):

```json
{
  "crons": [
    {
      "path": "/api/cron/signal-automation",
      "schedule": "0 * * * *"
    }
  ]
}
```

This schedules the cron to run every hour at minute 0.

If there are existing crons in the file, add this one to the array. Do not remove existing configurations.

Note: CRON_SECRET is automatically set by Vercel for cron jobs in production. For local testing, the endpoint allows requests without the secret when NODE_ENV is not "production".
  </action>
  <verify>vercel.json is valid JSON and contains the signal-automation cron entry</verify>
  <done>Vercel cron configuration added for hourly signal automation checks</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd orchestrator && npx tsc --noEmit` passes
2. Signal processor imports and calls checkSignalAutomationForNewSignal
3. Cron endpoint exists at /api/cron/signal-automation
4. vercel.json contains cron configuration
</verification>

<success_criteria>
- Signal processor triggers automation check after each signal is processed
- Cron endpoint runs automation check for all workspaces
- Cron endpoint is protected by CRON_SECRET in production
- Automation failures don't break signal processing pipeline
- Cron is scheduled to run hourly
</success_criteria>

<output>
After completion, create `.planning/phases/19-workflow-automation/19-04-SUMMARY.md`
</output>
