---
phase: 19-workflow-automation
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - orchestrator/src/lib/automation/signal-automation.ts
  - orchestrator/src/lib/automation/auto-actions.ts
  - orchestrator/src/lib/automation/rate-limiter.ts
  - orchestrator/src/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "checkSignalAutomation function evaluates clusters against workspace settings"
    - "Rate limiting prevents runaway automation"
    - "Auto-actions create projects and trigger PRD jobs"
    - "Automation respects cooldown between actions on same cluster"
  artifacts:
    - path: "orchestrator/src/lib/automation/signal-automation.ts"
      provides: "checkSignalAutomation, checkSignalAutomationForNewSignal"
      exports: ["checkSignalAutomation", "checkSignalAutomationForNewSignal"]
    - path: "orchestrator/src/lib/automation/auto-actions.ts"
      provides: "createProjectFromClusterAuto, triggerPrdGeneration"
      exports: ["createProjectFromClusterAuto", "triggerPrdGeneration"]
    - path: "orchestrator/src/lib/automation/rate-limiter.ts"
      provides: "canPerformAutoAction, recordAutomationAction"
      exports: ["canPerformAutoAction", "recordAutomationAction"]
  key_links:
    - from: "orchestrator/src/lib/automation/signal-automation.ts"
      to: "lib/classification/clustering.ts"
      via: "findSignalClusters import"
      pattern: "findSignalClusters"
    - from: "orchestrator/src/lib/automation/signal-automation.ts"
      to: "lib/automation/rate-limiter.ts"
      via: "canPerformAutoAction import"
      pattern: "canPerformAutoAction"
---

<objective>
Implement the core automation logic for signal-based workflow triggers.

Purpose: Create the automation engine that evaluates signal clusters against workspace thresholds and triggers appropriate actions (initiative creation, PRD generation) with proper rate limiting.

Output: Three modules - signal-automation.ts (orchestration), auto-actions.ts (actions), rate-limiter.ts (rate limiting).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-workflow-automation/19-RESEARCH.md
@.planning/phases/19-workflow-automation/19-01-SUMMARY.md

# Existing infrastructure
@orchestrator/src/lib/classification/clustering.ts
@orchestrator/src/app/api/projects/from-cluster/route.ts
@orchestrator/src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiter module</name>
  <files>orchestrator/src/lib/automation/rate-limiter.ts</files>
  <action>
Create `orchestrator/src/lib/automation/rate-limiter.ts`:

```typescript
/**
 * Rate Limiter for Signal Automation
 *
 * Prevents runaway automation by enforcing:
 * 1. Cooldown period per cluster (don't re-action same cluster too quickly)
 * 2. Daily rate limit per workspace (cap total auto-actions)
 */

import { db } from "@/lib/db";
import { automationActions } from "@/lib/db/schema";
import { eq, and, gt, count } from "drizzle-orm";
import { nanoid } from "nanoid";
import type { SignalAutomationSettings, AutomationActionType } from "@/lib/db/schema";

/**
 * Check if an automation action can be performed (rate limits, cooldown).
 */
export async function canPerformAutoAction(
  workspaceId: string,
  clusterId: string,
  settings: SignalAutomationSettings
): Promise<{ allowed: boolean; reason?: string }> {
  const now = new Date();

  // Check cooldown for this specific cluster
  const cooldownThreshold = new Date(now.getTime() - settings.cooldownMinutes * 60 * 1000);
  const recentClusterAction = await db
    .select()
    .from(automationActions)
    .where(and(
      eq(automationActions.workspaceId, workspaceId),
      eq(automationActions.clusterId, clusterId),
      gt(automationActions.triggeredAt, cooldownThreshold)
    ))
    .limit(1);

  if (recentClusterAction.length > 0) {
    return {
      allowed: false,
      reason: `Cluster in cooldown (${settings.cooldownMinutes}m)`
    };
  }

  // Check daily rate limit
  const dayStart = new Date(now);
  dayStart.setHours(0, 0, 0, 0);

  const dailyCount = await db
    .select({ count: count() })
    .from(automationActions)
    .where(and(
      eq(automationActions.workspaceId, workspaceId),
      gt(automationActions.triggeredAt, dayStart)
    ));

  if (dailyCount[0].count >= settings.maxAutoActionsPerDay) {
    return {
      allowed: false,
      reason: `Daily limit reached (${settings.maxAutoActionsPerDay}/day)`
    };
  }

  return { allowed: true };
}

/**
 * Record an automation action for rate limiting tracking.
 */
export async function recordAutomationAction(
  workspaceId: string,
  clusterId: string,
  actionType: AutomationActionType,
  projectId?: string,
  metadata?: Record<string, unknown>
): Promise<string> {
  const actionId = nanoid();

  await db.insert(automationActions).values({
    id: actionId,
    workspaceId,
    clusterId,
    actionType,
    projectId: projectId ?? null,
    triggeredAt: new Date(),
    metadata: metadata ?? null,
  });

  return actionId;
}

/**
 * Check if a cluster has already been actioned (for deduplication).
 */
export async function hasClusterBeenActioned(
  workspaceId: string,
  clusterId: string
): Promise<boolean> {
  const existing = await db
    .select({ id: automationActions.id })
    .from(automationActions)
    .where(and(
      eq(automationActions.workspaceId, workspaceId),
      eq(automationActions.clusterId, clusterId)
    ))
    .limit(1);

  return existing.length > 0;
}
```
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Rate limiter module created with canPerformAutoAction, recordAutomationAction, hasClusterBeenActioned functions</done>
</task>

<task type="auto">
  <name>Task 2: Create auto-actions module</name>
  <files>orchestrator/src/lib/automation/auto-actions.ts</files>
  <action>
Create `orchestrator/src/lib/automation/auto-actions.ts`:

```typescript
/**
 * Auto-Actions Module
 *
 * Actions triggered by signal automation:
 * - Create project from cluster (AUTO-04)
 * - Trigger PRD generation (AUTO-02)
 */

import { db } from "@/lib/db";
import { projects, signalProjects, signals, jobs } from "@/lib/db/schema";
import { nanoid } from "nanoid";
import { inArray, eq } from "drizzle-orm";
import { logProjectCreated } from "@/lib/activity";
import type { SignalCluster } from "@/lib/classification/clustering";

/**
 * Create a project from a signal cluster (automated version).
 * Similar to POST /api/projects/from-cluster but for automation context.
 */
export async function createProjectFromClusterAuto(
  workspaceId: string,
  cluster: SignalCluster
): Promise<string> {
  const projectId = `proj_${nanoid()}`;
  const now = new Date();

  // Create project with cluster theme as name
  await db.insert(projects).values({
    id: projectId,
    workspaceId,
    name: cluster.theme,
    description: `Auto-created from ${cluster.signalCount} signal cluster. Severity: ${cluster.severity}`,
    stage: "inbox",
    status: "active",
    metadata: {
      autoCreated: true,
      sourceClusterId: cluster.id,
      clusterConfidence: cluster.confidence,
    },
    createdAt: now,
    updatedAt: now,
  });

  // Bulk link signals
  const signalIds = cluster.signals.map(s => s.id);
  await db.insert(signalProjects).values(
    signalIds.map(signalId => ({
      id: nanoid(),
      signalId,
      projectId,
      linkedBy: null, // Automation, not a user
      linkReason: `Auto-linked from cluster: ${cluster.theme}`,
      confidence: cluster.confidence,
      linkedAt: now,
    }))
  );

  // Update signal statuses to "linked"
  await db
    .update(signals)
    .set({ status: "linked", updatedAt: now })
    .where(inArray(signals.id, signalIds));

  // Log activity (automation as actor)
  await logProjectCreated(workspaceId, "automation", projectId, cluster.theme);

  return projectId;
}

/**
 * Trigger PRD generation for a project.
 * Creates a pending job that the background worker will pick up.
 */
export async function triggerPrdGeneration(
  projectId: string,
  workspaceId: string
): Promise<string> {
  const jobId = `job_${nanoid()}`;
  const now = new Date();

  // First, move project to discovery stage (prerequisite for PRD)
  await db
    .update(projects)
    .set({ stage: "discovery", updatedAt: now })
    .where(eq(projects.id, projectId));

  // Create PRD generation job
  await db.insert(jobs).values({
    id: jobId,
    projectId,
    workspaceId,
    type: "generate_prd",
    status: "pending",
    input: {
      autoTriggered: true,
      triggeredBy: "automation",
    },
    createdAt: now,
  });

  return jobId;
}
```
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Auto-actions module created with createProjectFromClusterAuto and triggerPrdGeneration functions</done>
</task>

<task type="auto">
  <name>Task 3: Create signal automation orchestrator and add query helper</name>
  <files>orchestrator/src/lib/automation/signal-automation.ts, orchestrator/src/lib/db/queries.ts</files>
  <action>
First, add a helper function to `orchestrator/src/lib/db/queries.ts` to get workspace automation settings:

```typescript
// Add this function (place near other workspace-related queries)

/**
 * Get signal automation settings for a workspace.
 * Returns defaults if not configured.
 */
export async function getWorkspaceAutomationSettings(
  workspaceId: string
): Promise<SignalAutomationSettings> {
  const workspace = await db
    .select({ settings: workspaces.settings })
    .from(workspaces)
    .where(eq(workspaces.id, workspaceId))
    .limit(1);

  if (workspace.length === 0) {
    return DEFAULT_SIGNAL_AUTOMATION;
  }

  return workspace[0].settings?.signalAutomation ?? DEFAULT_SIGNAL_AUTOMATION;
}
```

Also add the necessary imports at the top of queries.ts:
```typescript
import { DEFAULT_SIGNAL_AUTOMATION, type SignalAutomationSettings } from "@/lib/db/schema";
```

Then create `orchestrator/src/lib/automation/signal-automation.ts`:

```typescript
/**
 * Signal Automation Orchestrator
 *
 * Checks signal clusters against workspace thresholds and triggers
 * appropriate actions (initiative creation, PRD generation).
 *
 * Entry points:
 * - checkSignalAutomation: Full check for all clusters (cron)
 * - checkSignalAutomationForNewSignal: Triggered after signal processing
 */

import { findSignalClusters, type SignalCluster } from "@/lib/classification/clustering";
import { getWorkspaceAutomationSettings } from "@/lib/db/queries";
import { canPerformAutoAction, recordAutomationAction, hasClusterBeenActioned } from "./rate-limiter";
import { createProjectFromClusterAuto, triggerPrdGeneration } from "./auto-actions";
import type { SignalSeverity, SignalAutomationSettings } from "@/lib/db/schema";

export interface AutomationCheckResult {
  clustersChecked: number;
  actionsTriggered: AutoActionRecord[];
  skipped: SkippedCluster[];
}

export interface AutoActionRecord {
  clusterId: string;
  action: "initiative_created" | "prd_triggered";
  projectId?: string;
  timestamp: string;
}

export interface SkippedCluster {
  clusterId: string;
  reason: "below_threshold" | "low_confidence" | "rate_limited" | "cooldown" | "already_actioned" | "severity_filter";
}

/**
 * Check signal clusters and trigger automation based on workspace settings.
 * Called from cron job or manually.
 */
export async function checkSignalAutomation(
  workspaceId: string
): Promise<AutomationCheckResult> {
  const settings = await getWorkspaceAutomationSettings(workspaceId);
  const actionsTriggered: AutoActionRecord[] = [];
  const skipped: SkippedCluster[] = [];

  // Exit early if automation is manual
  if (settings.automationDepth === "manual") {
    return { clustersChecked: 0, actionsTriggered, skipped };
  }

  // Find current clusters (minimum 2 signals)
  const clusters = await findSignalClusters(workspaceId, 2);

  for (const cluster of clusters) {
    const skipReason = await evaluateCluster(cluster, workspaceId, settings);

    if (skipReason) {
      skipped.push({ clusterId: cluster.id, reason: skipReason });
      continue;
    }

    const now = new Date().toISOString();

    // AUTO-04: Auto-create initiative from cluster above threshold
    if (settings.automationDepth === "auto_create" || settings.automationDepth === "full_auto") {
      if (cluster.signalCount >= settings.autoInitiativeThreshold) {
        const projectId = await createProjectFromClusterAuto(workspaceId, cluster);

        await recordAutomationAction(
          workspaceId,
          cluster.id,
          "initiative_created",
          projectId,
          { clusterTheme: cluster.theme, signalCount: cluster.signalCount }
        );

        actionsTriggered.push({
          clusterId: cluster.id,
          action: "initiative_created",
          projectId,
          timestamp: now,
        });

        // AUTO-02: Auto-trigger PRD if full_auto and threshold met
        if (settings.automationDepth === "full_auto" &&
            cluster.signalCount >= settings.autoPrdThreshold) {
          const jobId = await triggerPrdGeneration(projectId, workspaceId);

          await recordAutomationAction(
            workspaceId,
            cluster.id,
            "prd_triggered",
            projectId,
            { jobId }
          );

          actionsTriggered.push({
            clusterId: cluster.id,
            action: "prd_triggered",
            projectId,
            timestamp: now,
          });
        }
      }
    }
  }

  return {
    clustersChecked: clusters.length,
    actionsTriggered,
    skipped,
  };
}

/**
 * Evaluate if a cluster should be skipped.
 * Returns skip reason if should skip, null if should process.
 */
async function evaluateCluster(
  cluster: SignalCluster,
  workspaceId: string,
  settings: SignalAutomationSettings
): Promise<SkippedCluster["reason"] | null> {
  // Check if already actioned
  if (await hasClusterBeenActioned(workspaceId, cluster.id)) {
    return "already_actioned";
  }

  // Check rate limiting
  const rateCheck = await canPerformAutoAction(workspaceId, cluster.id, settings);
  if (!rateCheck.allowed) {
    return rateCheck.reason?.includes("cooldown") ? "cooldown" : "rate_limited";
  }

  // Check confidence threshold
  if (cluster.confidence < settings.minClusterConfidence) {
    return "low_confidence";
  }

  // Check severity filter
  if (settings.minSeverityForAuto &&
      !meetsSeverityThreshold(cluster.severity, settings.minSeverityForAuto)) {
    return "severity_filter";
  }

  // Check size threshold
  if (cluster.signalCount < settings.autoInitiativeThreshold) {
    return "below_threshold";
  }

  return null;
}

/**
 * Check if cluster severity meets minimum threshold.
 * Lower index = higher severity.
 */
function meetsSeverityThreshold(
  clusterSeverity: SignalSeverity,
  minSeverity: SignalSeverity
): boolean {
  const severityOrder: SignalSeverity[] = ["critical", "high", "medium", "low"];
  const clusterIdx = severityOrder.indexOf(clusterSeverity);
  const minIdx = severityOrder.indexOf(minSeverity);
  return clusterIdx <= minIdx;
}

/**
 * Quick automation check triggered after a new signal is processed.
 * Called from after() blocks in signal processing.
 */
export async function checkSignalAutomationForNewSignal(
  workspaceId: string,
  triggeringSignalId: string
): Promise<void> {
  try {
    const settings = await getWorkspaceAutomationSettings(workspaceId);

    // Exit early if automation is disabled
    if (settings.automationDepth === "manual") return;

    // Run full automation check
    const result = await checkSignalAutomation(workspaceId);

    // Log for observability
    if (result.actionsTriggered.length > 0) {
      console.log(
        `[SignalAutomation] Triggered ${result.actionsTriggered.length} actions after signal ${triggeringSignalId}`
      );
    }
  } catch (error) {
    // Never throw in after() context - log and continue
    console.error(`[SignalAutomation] Error checking automation for signal ${triggeringSignalId}:`, error);
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Signal automation orchestrator created with checkSignalAutomation and checkSignalAutomationForNewSignal, query helper added to queries.ts</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd orchestrator && npx tsc --noEmit` passes
2. All three automation modules exist and export their functions
3. getWorkspaceAutomationSettings function added to queries.ts
</verification>

<success_criteria>
- checkSignalAutomation evaluates all clusters against workspace thresholds
- Rate limiting prevents more than maxAutoActionsPerDay actions
- Cooldown prevents re-actioning the same cluster within cooldownMinutes
- createProjectFromClusterAuto creates project and links signals
- triggerPrdGeneration creates a pending PRD job
- checkSignalAutomationForNewSignal is safe to call from after() context
</success_criteria>

<output>
After completion, create `.planning/phases/19-workflow-automation/19-02-SUMMARY.md`
</output>
