---
phase: 12-signal-management-ui
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - orchestrator/src/app/(dashboard)/workspace/[id]/signals/page.tsx
  - orchestrator/src/components/signals/SignalsTable.tsx
  - orchestrator/src/components/signals/SignalFilters.tsx
  - orchestrator/src/components/signals/SignalRow.tsx
autonomous: true

must_haves:
  truths:
    - "User can view paginated list of all signals in workspace"
    - "User can search signals by keyword and find matching results"
    - "User can filter signals by date range, source type, and status"
    - "Table columns are sortable by user"
    - "Table shows loading and empty states"
  artifacts:
    - path: "orchestrator/src/app/(dashboard)/workspace/[id]/signals/page.tsx"
      provides: "Signals page route"
      contains: "export default function SignalsPage"
    - path: "orchestrator/src/components/signals/SignalsTable.tsx"
      provides: "Main table component with data fetching"
      contains: "useQuery"
    - path: "orchestrator/src/components/signals/SignalFilters.tsx"
      provides: "Search input and filter controls"
      contains: "useState"
    - path: "orchestrator/src/components/signals/SignalRow.tsx"
      provides: "Individual table row component"
      contains: "function SignalRow"
  key_links:
    - from: "orchestrator/src/components/signals/SignalsTable.tsx"
      to: "/api/signals"
      via: "fetch in useQuery"
      pattern: "fetch.*api/signals"
    - from: "orchestrator/src/app/(dashboard)/workspace/[id]/signals/page.tsx"
      to: "orchestrator/src/components/signals/SignalsTable.tsx"
      via: "import and render"
      pattern: "import.*SignalsTable"
---

<objective>
Create the Signals page with data table, search, filters, pagination, and sorting.

Purpose: Deliver the primary signal viewing experience - users can see, search, and filter all signals in their workspace.
Output: Working signals page at /workspace/[id]/signals with table, filters, and pagination.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-signal-management-ui/12-CONTEXT.md
@.planning/phases/12-signal-management-ui/12-RESEARCH.md
@.planning/phases/12-signal-management-ui/12-01-SUMMARY.md

# Key files to reference
@orchestrator/src/components/inbox/InboxPanel.tsx (useQuery pattern, Badge usage)
@orchestrator/src/components/ui/badge.tsx
@orchestrator/src/components/ui/button.tsx
@orchestrator/src/components/ui/input.tsx
@orchestrator/src/components/ui/select.tsx
@orchestrator/src/lib/db/schema.ts (SignalStatus, SignalSource types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SignalFilters component</name>
  <files>orchestrator/src/components/signals/SignalFilters.tsx</files>
  <action>
Create a filter component with search input and filter dropdowns.

Props interface:
```typescript
interface SignalFiltersProps {
  search: string;
  onSearchChange: (value: string) => void;
  status: string;
  onStatusChange: (value: string) => void;
  source: string;
  onSourceChange: (value: string) => void;
  dateFrom: string;
  onDateFromChange: (value: string) => void;
  dateTo: string;
  onDateToChange: (value: string) => void;
}
```

Layout (horizontal flex, responsive):
1. Search input with Search icon (lucide-react)
   - placeholder: "Search signals..."
   - onChange calls onSearchChange

2. Status select dropdown
   - Options: "All Statuses", "new", "reviewed", "linked", "archived"
   - Use @radix-ui/react-select via @/components/ui/select

3. Source select dropdown
   - Options: "All Sources", "paste", "webhook", "upload", "video", "slack", "pylon", "email", "interview", "other"

4. Date range inputs (type="date")
   - "From" and "To" labels
   - Native date inputs for simplicity

Styling:
- Use Tailwind: flex, gap-3, flex-wrap for responsive
- Inputs: bg-muted/50, rounded-lg, border-border
- Follow existing component styles

Export as named export: `export function SignalFilters`
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>SignalFilters component renders search input and 4 filter controls</done>
</task>

<task type="auto">
  <name>Task 2: Create SignalRow component</name>
  <files>orchestrator/src/components/signals/SignalRow.tsx</files>
  <action>
Create a table row component for individual signals.

Props interface:
```typescript
interface SignalRowProps {
  signal: {
    id: string;
    verbatim: string;
    interpretation?: string | null;
    status: "new" | "reviewed" | "linked" | "archived";
    source: string;
    severity?: string | null;
    createdAt: string;
  };
  onView: (signal: SignalRowProps["signal"]) => void;
  onDelete: (id: string) => void;
}
```

Row content (table cells):
1. Verbatim (truncated to 100 chars with ellipsis, max-w-xs)
2. Status badge (use Badge component with color mapping)
3. Source badge (different color scheme)
4. Severity badge (if present, otherwise "-")
5. Created date (formatted with toLocaleDateString)
6. Actions dropdown (MoreHorizontal icon)
   - "View Details" -> calls onView
   - "Delete" -> calls onDelete (with red text)

Status colors (similar to InboxPanel pattern):
```typescript
const STATUS_COLORS: Record<string, string> = {
  new: "bg-blue-500/20 text-blue-300 border-blue-500/30",
  reviewed: "bg-amber-500/20 text-amber-300 border-amber-500/30",
  linked: "bg-green-500/20 text-green-300 border-green-500/30",
  archived: "bg-slate-500/20 text-slate-300 border-slate-500/30",
};
```

Source colors:
```typescript
const SOURCE_COLORS: Record<string, string> = {
  paste: "bg-purple-500/20 text-purple-300 border-purple-500/30",
  webhook: "bg-teal-500/20 text-teal-300 border-teal-500/30",
  upload: "bg-pink-500/20 text-pink-300 border-pink-500/30",
  // ... etc
};
```

Use DropdownMenu from @/components/ui/dropdown-menu for actions.
Use lucide-react icons: MoreHorizontal, Eye, Trash2
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>SignalRow component renders table row with badges and action dropdown</done>
</task>

<task type="auto">
  <name>Task 3: Create SignalsTable component with data fetching</name>
  <files>orchestrator/src/components/signals/SignalsTable.tsx</files>
  <action>
Create main table component with TanStack Query data fetching.

"use client" directive at top.

Props interface:
```typescript
interface SignalsTableProps {
  workspaceId: string;
  onViewSignal: (signal: Signal) => void;
  onCreateSignal: () => void;
}
```

State management:
1. Filter state (useState for each):
   - search, debouncedSearch (with 300ms debounce using useEffect)
   - status, source, dateFrom, dateTo
   - page (default 1), pageSize (default 20)
   - sortBy (default "createdAt"), sortOrder (default "desc")

2. Debounce pattern (from RESEARCH.md):
```typescript
const [search, setSearch] = useState("");
const [debouncedSearch, setDebouncedSearch] = useState("");

useEffect(() => {
  const timer = setTimeout(() => setDebouncedSearch(search), 300);
  return () => clearTimeout(timer);
}, [search]);
```

Data fetching with useQuery:
```typescript
const { data, isLoading, isError } = useQuery({
  queryKey: ["signals", workspaceId, debouncedSearch, status, source, dateFrom, dateTo, page, pageSize, sortBy, sortOrder],
  queryFn: async () => {
    const params = new URLSearchParams({ workspaceId });
    if (debouncedSearch) params.set("search", debouncedSearch);
    if (status) params.set("status", status);
    if (source) params.set("source", source);
    if (dateFrom) params.set("dateFrom", dateFrom);
    if (dateTo) params.set("dateTo", dateTo);
    params.set("page", String(page));
    params.set("pageSize", String(pageSize));
    params.set("sortBy", sortBy);
    params.set("sortOrder", sortOrder);

    const res = await fetch(`/api/signals?${params}`);
    if (!res.ok) throw new Error("Failed to load signals");
    return res.json();
  },
});
```

Delete mutation:
```typescript
const deleteMutation = useMutation({
  mutationFn: async (id: string) => {
    const res = await fetch(`/api/signals/${id}`, { method: "DELETE" });
    if (!res.ok) throw new Error("Failed to delete");
    return res.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["signals", workspaceId] });
  },
});
```

Layout:
1. Header row: Title "Signals", count badge, "Add Signal" button
2. SignalFilters component
3. Table with sortable headers (click to toggle sort)
4. SignalRow for each signal
5. Pagination controls (Previous/Next, "Showing X-Y of Z")

Table headers with sort:
- Verbatim, Status, Source, Severity, Created, Actions
- Click header to sort (toggle asc/desc)
- Show sort indicator (ChevronUp/ChevronDown icon)

Loading state: Render skeleton rows or Loader2 spinner
Empty state: "No signals found" message with optional "Add Signal" button
Error state: "Failed to load signals" message

Reset page to 1 when filters change (useEffect).
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>SignalsTable fetches paginated data, supports search/filter/sort, renders table with pagination</done>
</task>

<task type="auto">
  <name>Task 4: Create Signals page route</name>
  <files>orchestrator/src/app/(dashboard)/workspace/[id]/signals/page.tsx</files>
  <action>
Create the signals page component.

Server component that renders client component with workspaceId.

```typescript
import { SignalsPageClient } from "./SignalsPageClient";

type PageProps = { params: Promise<{ id: string }> };

export default async function SignalsPage({ params }: PageProps) {
  const { id } = await params;
  return <SignalsPageClient workspaceId={id} />;
}
```

Create SignalsPageClient.tsx in same directory:

"use client" directive.

```typescript
"use client";

import { useState } from "react";
import { SignalsTable } from "@/components/signals/SignalsTable";

interface SignalsPageClientProps {
  workspaceId: string;
}

export function SignalsPageClient({ workspaceId }: SignalsPageClientProps) {
  const [selectedSignal, setSelectedSignal] = useState<Signal | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);

  return (
    <div className="container mx-auto py-6 px-4">
      <SignalsTable
        workspaceId={workspaceId}
        onViewSignal={setSelectedSignal}
        onCreateSignal={() => setShowCreateModal(true)}
      />

      {/* Modals will be added in 12-03-PLAN */}
    </div>
  );
}
```

Note: Modal implementations are in 12-03-PLAN. For now, just wire up the state and callbacks.
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```

Page is accessible at /workspace/[id]/signals route.
  </verify>
  <done>Signals page exists at /workspace/[id]/signals and renders SignalsTable</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
2. Navigate to /workspace/[id]/signals shows table
3. Search input filters results in real-time (debounced)
4. Filter dropdowns narrow results
5. Column headers are sortable
6. Pagination works (if more than 20 signals)
</verification>

<success_criteria>
- Signals page loads at /workspace/[id]/signals
- Table displays signals with verbatim, status, source, severity, date columns
- Search filters results as user types (300ms debounce)
- Status and source dropdowns filter results
- Date range filters work
- Column headers toggle sort order on click
- Pagination shows "Showing X-Y of Z" and Next/Previous buttons
- Loading state shows spinner
- Empty state shows "No signals found"
- Delete action removes signal and refreshes table
</success_criteria>

<output>
After completion, create `.planning/phases/12-signal-management-ui/12-02-SUMMARY.md`
</output>
