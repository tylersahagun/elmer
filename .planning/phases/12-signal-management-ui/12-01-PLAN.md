---
phase: 12-signal-management-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/lib/db/queries.ts
  - orchestrator/src/app/api/signals/route.ts
  - orchestrator/src/app/api/signals/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "API returns paginated list of signals for a workspace"
    - "API accepts search, status, source, and date range filters"
    - "API creates new signal with verbatim content and source"
    - "API updates signal fields (verbatim, interpretation, status)"
    - "API deletes signal by ID"
  artifacts:
    - path: "orchestrator/src/lib/db/queries.ts"
      provides: "getSignals, getSignal, createSignal, updateSignal, deleteSignal functions"
      contains: "export async function getSignals"
    - path: "orchestrator/src/app/api/signals/route.ts"
      provides: "GET (list with filters), POST (create)"
      exports: ["GET", "POST"]
    - path: "orchestrator/src/app/api/signals/[id]/route.ts"
      provides: "GET (single), PATCH (update), DELETE"
      exports: ["GET", "PATCH", "DELETE"]
  key_links:
    - from: "orchestrator/src/app/api/signals/route.ts"
      to: "orchestrator/src/lib/db/queries.ts"
      via: "getSignals, createSignal imports"
      pattern: "import.*getSignals.*from.*queries"
    - from: "orchestrator/src/app/api/signals/[id]/route.ts"
      to: "orchestrator/src/lib/db/queries.ts"
      via: "getSignal, updateSignal, deleteSignal imports"
      pattern: "import.*updateSignal.*from.*queries"
---

<objective>
Create Signal CRUD API endpoints with filtering, pagination, and search capabilities.

Purpose: Establish backend foundation for Signal Management UI - all UI components will fetch from these endpoints.
Output: Complete REST API for signals (list, create, read, update, delete) with query parameter filtering.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-signal-management-ui/12-CONTEXT.md
@.planning/phases/12-signal-management-ui/12-RESEARCH.md
@.planning/phases/11-signal-schema/11-01-SUMMARY.md

# Key files to reference
@orchestrator/src/lib/db/schema.ts (lines 1129-1290 - Signal schema)
@orchestrator/src/lib/db/queries.ts (existing query patterns)
@orchestrator/src/app/api/projects/route.ts (API route pattern with permissions)
@orchestrator/src/lib/permissions.ts (requireWorkspaceAccess pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add signal query functions to queries.ts</name>
  <files>orchestrator/src/lib/db/queries.ts</files>
  <action>
Add signal query functions following existing patterns (getProjects, getNotifications).

Add imports at top:
```typescript
import { ilike } from "drizzle-orm";
```

Add to schema imports:
```typescript
signals,
type SignalStatus,
type SignalSource,
```

Create these functions:

1. `getSignals(workspaceId, options)` - List with filters and pagination
   - options: { search?, status?, source?, dateFrom?, dateTo?, sortBy?, sortOrder?, page?, pageSize? }
   - Build dynamic WHERE conditions using `and()`, `or()`, `ilike()`, `eq()`, `gte()`, `lte()`
   - Search should check verbatim and interpretation fields with ILIKE
   - Default sort: createdAt desc
   - Default pageSize: 20
   - Return array of signals

2. `getSignalsCount(workspaceId, options)` - Count for pagination
   - Same filter options as getSignals (minus pagination)
   - Return total count for "Showing X of Y" UI

3. `getSignal(id)` - Single signal by ID
   - Use db.query.signals.findFirst with eq(signals.id, id)

4. `createSignal(data)` - Create new signal
   - data: { workspaceId, verbatim, interpretation?, source, sourceRef?, sourceMetadata?, status? }
   - Generate ID with uuid()
   - Set createdAt and updatedAt to now
   - Default status to "new" if not provided
   - Return created signal

5. `updateSignal(id, data)` - Update signal
   - data: Partial of { verbatim, interpretation, status, severity, frequency, userSegment, sourceRef, sourceMetadata }
   - Set updatedAt to now
   - Return updated signal

6. `deleteSignal(id)` - Delete signal
   - Delete by ID
   - Return { id } for confirmation

Follow the existing patterns in queries.ts for error handling and return types.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>Six signal query functions exist in queries.ts with proper typing and filtering support</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/signals route (GET list, POST create)</name>
  <files>orchestrator/src/app/api/signals/route.ts</files>
  <action>
Create new file following the projects/route.ts pattern.

GET handler:
- Extract workspaceId from searchParams (required)
- Extract optional filters: search, status, source, dateFrom, dateTo, page, pageSize, sortBy, sortOrder
- Call requireWorkspaceAccess(workspaceId, "viewer")
- Call getSignals with parsed options
- Call getSignalsCount with same filter options
- Return JSON: { signals: [...], total: number, page: number, pageSize: number }

POST handler:
- Parse body: { workspaceId, verbatim, interpretation?, source?, sourceRef?, sourceMetadata? }
- Validate workspaceId and verbatim are present
- Call requireWorkspaceAccess(workspaceId, "member")
- Default source to "paste" if not provided (manual entry default)
- Call createSignal
- Return created signal with status 201

Error handling:
- PermissionError -> handlePermissionError
- Missing workspaceId -> 400
- Missing verbatim on POST -> 400
- Catch all -> 500 with console.error

Import pattern:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { getSignals, getSignalsCount, createSignal } from "@/lib/db/queries";
import {
  requireWorkspaceAccess,
  handlePermissionError,
  PermissionError,
} from "@/lib/permissions";
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>GET /api/signals returns paginated signals with filters, POST /api/signals creates signal</done>
</task>

<task type="auto">
  <name>Task 3: Create /api/signals/[id] route (GET, PATCH, DELETE)</name>
  <files>orchestrator/src/app/api/signals/[id]/route.ts</files>
  <action>
Create new file following the projects/[id]/route.ts pattern.

GET handler:
- Extract id from params
- Call getSignal(id)
- If not found, return 404
- Call requireWorkspaceAccess(signal.workspaceId, "viewer")
- Return signal JSON

PATCH handler:
- Extract id from params
- Parse body for updatable fields: { verbatim?, interpretation?, status?, severity?, frequency?, userSegment?, sourceRef?, sourceMetadata? }
- Call getSignal(id) to verify exists and get workspaceId
- If not found, return 404
- Call requireWorkspaceAccess(signal.workspaceId, "member")
- Call updateSignal(id, body)
- Return updated signal JSON

DELETE handler:
- Extract id from params
- Call getSignal(id) to verify exists and get workspaceId
- If not found, return 404
- Call requireWorkspaceAccess(signal.workspaceId, "member")
- Call deleteSignal(id)
- Return { success: true, id } with status 200

Error handling same as route.ts (PermissionError, 404, 500).

Type the params correctly for Next.js 15:
```typescript
type RouteContext = { params: Promise<{ id: string }> };

export async function GET(request: NextRequest, context: RouteContext) {
  const { id } = await context.params;
  // ...
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>GET/PATCH/DELETE /api/signals/[id] endpoints work with permission checks</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
2. API routes exist at correct paths
3. Query functions handle all filter combinations
4. Permission checks use requireWorkspaceAccess
</verification>

<success_criteria>
- GET /api/signals?workspaceId=X returns paginated signals with total count
- GET /api/signals?workspaceId=X&search=keyword returns filtered results
- GET /api/signals?workspaceId=X&status=new&source=paste filters work
- POST /api/signals creates signal and returns 201
- GET /api/signals/[id] returns single signal
- PATCH /api/signals/[id] updates signal fields
- DELETE /api/signals/[id] removes signal
- All endpoints require authentication and workspace membership
</success_criteria>

<output>
After completion, create `.planning/phases/12-signal-management-ui/12-01-SUMMARY.md`
</output>
