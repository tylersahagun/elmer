---
phase: 12-signal-management-ui
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - orchestrator/src/components/signals/CreateSignalModal.tsx
  - orchestrator/src/components/signals/SignalDetailModal.tsx
  - orchestrator/src/app/(dashboard)/workspace/[id]/signals/SignalsPageClient.tsx
autonomous: true

must_haves:
  truths:
    - "User can paste or type feedback directly to create a signal"
    - "User can view full signal details in a modal"
    - "User can edit any signal field from detail modal"
    - "User can delete signal from detail modal"
    - "Create & Add Another button allows batch signal creation"
  artifacts:
    - path: "orchestrator/src/components/signals/CreateSignalModal.tsx"
      provides: "Modal form for creating new signals"
      contains: "Create & Add Another"
    - path: "orchestrator/src/components/signals/SignalDetailModal.tsx"
      provides: "Modal for viewing/editing signal details"
      contains: "useMutation"
    - path: "orchestrator/src/app/(dashboard)/workspace/[id]/signals/SignalsPageClient.tsx"
      provides: "Page client with modal state management"
      contains: "CreateSignalModal"
  key_links:
    - from: "orchestrator/src/components/signals/CreateSignalModal.tsx"
      to: "/api/signals"
      via: "POST fetch in mutation"
      pattern: "fetch.*api/signals.*POST"
    - from: "orchestrator/src/components/signals/SignalDetailModal.tsx"
      to: "/api/signals/[id]"
      via: "PATCH and DELETE fetch"
      pattern: "fetch.*api/signals.*PATCH"
---

<objective>
Create modal components for signal creation (with batch support) and detail view/edit.

Purpose: Enable users to manually create signals and view/edit full signal details without leaving the table context.
Output: Working Create Signal modal with "Create & Add Another" and Signal Detail modal with edit/delete capabilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-signal-management-ui/12-CONTEXT.md
@.planning/phases/12-signal-management-ui/12-RESEARCH.md
@.planning/phases/12-signal-management-ui/12-01-SUMMARY.md

# Key files to reference
@orchestrator/src/components/ui/dialog.tsx (existing Dialog component)
@orchestrator/src/components/ui/textarea.tsx
@orchestrator/src/components/ui/select.tsx
@orchestrator/src/components/ui/label.tsx
@orchestrator/src/components/inbox/InboxPanel.tsx (mutation patterns, form patterns)
@orchestrator/src/lib/db/schema.ts (SignalSource type options)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CreateSignalModal component</name>
  <files>orchestrator/src/components/signals/CreateSignalModal.tsx</files>
  <action>
Create modal for manual signal entry following CONTEXT.md decisions.

"use client" directive.

Props interface:
```typescript
interface CreateSignalModalProps {
  workspaceId: string;
  isOpen: boolean;
  onClose: () => void;
  onSuccess: () => void;
}
```

State:
- verbatim (string, required)
- interpretation (string, optional)
- source (SignalSource, default "paste")
- keepOpen (boolean, for "Create & Add Another")
- isSubmitting (boolean)

Form fields:
1. Verbatim textarea (required)
   - Label: "Feedback (required)"
   - Placeholder: "Paste or type the user feedback verbatim..."
   - 4 rows minimum
   - Validation: must not be empty

2. Interpretation textarea (optional)
   - Label: "Interpretation (optional)"
   - Placeholder: "What does this feedback really mean?"
   - 2 rows

3. Source select (default "paste")
   - Label: "Source"
   - Options for manual entry: "paste" (Manual Entry), "interview", "email", "other"
   - Note: webhook, upload, video, slack, pylon are for automated ingestion

Create mutation:
```typescript
const queryClient = useQueryClient();

const createMutation = useMutation({
  mutationFn: async (data: { verbatim: string; interpretation?: string; source: string }) => {
    const res = await fetch("/api/signals", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ workspaceId, ...data }),
    });
    if (!res.ok) throw new Error("Failed to create signal");
    return res.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["signals", workspaceId] });
    if (keepOpen) {
      // Clear form but keep modal open
      setVerbatim("");
      setInterpretation("");
      setSource("paste");
    } else {
      onSuccess();
      onClose();
    }
  },
});
```

Submit handlers:
```typescript
const handleCreate = () => {
  if (!verbatim.trim()) return;
  setKeepOpen(false);
  createMutation.mutate({ verbatim, interpretation: interpretation || undefined, source });
};

const handleCreateAndAddAnother = () => {
  if (!verbatim.trim()) return;
  setKeepOpen(true);
  createMutation.mutate({ verbatim, interpretation: interpretation || undefined, source });
};
```

Dialog structure (use existing Dialog component from @/components/ui/dialog):
```tsx
<Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
  <DialogContent className="sm:max-w-[500px]">
    <DialogHeader>
      <DialogTitle>Add Signal</DialogTitle>
      <DialogDescription>
        Manually add user feedback to your signals library.
      </DialogDescription>
    </DialogHeader>

    {/* Form fields */}

    <DialogFooter className="gap-2 sm:gap-0">
      <Button variant="outline" onClick={onClose}>
        Cancel
      </Button>
      <Button
        variant="outline"
        onClick={handleCreateAndAddAnother}
        disabled={!verbatim.trim() || createMutation.isPending}
      >
        {createMutation.isPending && keepOpen ? (
          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
        ) : null}
        Create & Add Another
      </Button>
      <Button
        onClick={handleCreate}
        disabled={!verbatim.trim() || createMutation.isPending}
      >
        {createMutation.isPending && !keepOpen ? (
          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
        ) : null}
        Create Signal
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>CreateSignalModal renders form with verbatim, interpretation, source fields and Create/Create & Add Another buttons</done>
</task>

<task type="auto">
  <name>Task 2: Create SignalDetailModal component</name>
  <files>orchestrator/src/components/signals/SignalDetailModal.tsx</files>
  <action>
Create modal for viewing/editing signal details following CONTEXT.md decisions.

"use client" directive.

Props interface:
```typescript
interface SignalDetailModalProps {
  signal: Signal | null;
  isOpen: boolean;
  onClose: () => void;
  onUpdate: () => void;
  onDelete: () => void;
}
```

Where Signal type includes:
```typescript
interface Signal {
  id: string;
  workspaceId: string;
  verbatim: string;
  interpretation?: string | null;
  status: "new" | "reviewed" | "linked" | "archived";
  source: string;
  sourceRef?: string | null;
  sourceMetadata?: Record<string, unknown> | null;
  severity?: string | null;
  frequency?: string | null;
  userSegment?: string | null;
  createdAt: string;
  updatedAt: string;
  processedAt?: string | null;
}
```

State:
- isEditing (boolean, default false)
- editedVerbatim, editedInterpretation, editedStatus (for edit mode)
- showMetadata (boolean, for collapsible technical section)

Update mutation:
```typescript
const updateMutation = useMutation({
  mutationFn: async (data: Partial<Signal>) => {
    const res = await fetch(`/api/signals/${signal.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    if (!res.ok) throw new Error("Failed to update signal");
    return res.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["signals"] });
    setIsEditing(false);
    onUpdate();
  },
});
```

Delete mutation:
```typescript
const deleteMutation = useMutation({
  mutationFn: async () => {
    const res = await fetch(`/api/signals/${signal.id}`, { method: "DELETE" });
    if (!res.ok) throw new Error("Failed to delete signal");
    return res.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["signals"] });
    onDelete();
    onClose();
  },
});
```

View mode layout:
1. Header with signal ID and status badge
2. Verbatim content (full text, scrollable if long)
3. Interpretation (if present)
4. Metadata row: Source badge, Severity badge (if present), Created date
5. Collapsible "Technical Details" section:
   - Signal ID
   - Workspace ID
   - Source Reference (if present)
   - Source Metadata JSON (if present)
   - Created At (full timestamp)
   - Updated At (full timestamp)
   - Processed At (if present)
6. Action buttons: Edit, Delete (red)

Edit mode layout:
1. Verbatim textarea (editable)
2. Interpretation textarea (editable)
3. Status select (new, reviewed, linked, archived)
4. Save / Cancel buttons

Status change from view mode:
- Quick status buttons or dropdown to change status without entering full edit mode
- "Mark as Reviewed", "Archive" quick actions

Dialog structure:
```tsx
<Dialog open={isOpen && !!signal} onOpenChange={(open) => !open && onClose()}>
  <DialogContent className="sm:max-w-[600px] max-h-[80vh] overflow-y-auto">
    <DialogHeader>
      <DialogTitle className="flex items-center gap-2">
        Signal Details
        <Badge className={STATUS_COLORS[signal?.status || "new"]}>
          {signal?.status}
        </Badge>
      </DialogTitle>
    </DialogHeader>

    {isEditing ? (
      /* Edit form */
    ) : (
      /* View mode */
    )}

    <DialogFooter>
      {isEditing ? (
        <>
          <Button variant="outline" onClick={() => setIsEditing(false)}>Cancel</Button>
          <Button onClick={handleSave} disabled={updateMutation.isPending}>
            {updateMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
            Save Changes
          </Button>
        </>
      ) : (
        <>
          <Button
            variant="outline"
            className="text-red-500 hover:text-red-400"
            onClick={() => deleteMutation.mutate()}
            disabled={deleteMutation.isPending}
          >
            {deleteMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
            Delete
          </Button>
          <Button variant="outline" onClick={() => setIsEditing(true)}>
            Edit
          </Button>
          <Button variant="outline" onClick={onClose}>
            Close
          </Button>
        </>
      )}
    </DialogFooter>
  </DialogContent>
</Dialog>
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```
  </verify>
  <done>SignalDetailModal displays signal details, supports edit mode, and has delete action</done>
</task>

<task type="auto">
  <name>Task 3: Wire modals into SignalsPageClient</name>
  <files>orchestrator/src/app/(dashboard)/workspace/[id]/signals/SignalsPageClient.tsx</files>
  <action>
Update SignalsPageClient to use the modal components.

Import modals:
```typescript
import { CreateSignalModal } from "@/components/signals/CreateSignalModal";
import { SignalDetailModal } from "@/components/signals/SignalDetailModal";
```

Import Signal type from @/lib/db (or define locally based on API response).

Update component:
```typescript
"use client";

import { useState } from "react";
import { SignalsTable } from "@/components/signals/SignalsTable";
import { CreateSignalModal } from "@/components/signals/CreateSignalModal";
import { SignalDetailModal } from "@/components/signals/SignalDetailModal";
import type { Signal } from "@/lib/db";

interface SignalsPageClientProps {
  workspaceId: string;
}

export function SignalsPageClient({ workspaceId }: SignalsPageClientProps) {
  const [selectedSignal, setSelectedSignal] = useState<Signal | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);

  return (
    <div className="container mx-auto py-6 px-4">
      <SignalsTable
        workspaceId={workspaceId}
        onViewSignal={(signal) => setSelectedSignal(signal as Signal)}
        onCreateSignal={() => setShowCreateModal(true)}
      />

      <CreateSignalModal
        workspaceId={workspaceId}
        isOpen={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onSuccess={() => setShowCreateModal(false)}
      />

      <SignalDetailModal
        signal={selectedSignal}
        isOpen={!!selectedSignal}
        onClose={() => setSelectedSignal(null)}
        onUpdate={() => {}}
        onDelete={() => setSelectedSignal(null)}
      />
    </div>
  );
}
```

Ensure SignalsTable passes the full signal object to onViewSignal (not just partial data).
  </action>
  <verify>
TypeScript compiles:
```bash
cd orchestrator && npx tsc --noEmit
```

Test manually:
1. Click "Add Signal" -> CreateSignalModal opens
2. Fill form, click "Create Signal" -> modal closes, table refreshes
3. Fill form, click "Create & Add Another" -> form clears, modal stays open
4. Click row action "View Details" -> SignalDetailModal opens
5. Click "Edit" -> edit mode enabled
6. Make changes, click "Save Changes" -> modal updates, exits edit mode
7. Click "Delete" -> signal removed, modal closes
  </verify>
  <done>Modals integrated into page - create modal opens on "Add Signal", detail modal opens on row view action</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
2. "Add Signal" button opens create modal
3. Create modal has verbatim, interpretation, source fields
4. "Create & Add Another" clears form but keeps modal open
5. "Create Signal" creates signal and closes modal
6. Row "View Details" action opens detail modal
7. Detail modal shows full signal data
8. Edit mode allows changing verbatim, interpretation, status
9. Delete action removes signal
</verification>

<success_criteria>
- CreateSignalModal opens when clicking "Add Signal" button
- Form validates verbatim is required
- "Create Signal" creates and closes modal
- "Create & Add Another" creates, clears form, keeps modal open
- SignalDetailModal opens when viewing a signal
- View mode shows all signal fields and collapsible metadata
- Edit mode allows changing verbatim, interpretation, status
- Save updates signal and exits edit mode
- Delete removes signal and closes modal
- Both modals have loading states during mutations
</success_criteria>

<output>
After completion, create `.planning/phases/12-signal-management-ui/12-03-SUMMARY.md`
</output>
