---
phase: 13-webhook-ingestion
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - orchestrator/src/lib/webhooks/auth.ts
  - orchestrator/src/lib/webhooks/processor.ts
  - orchestrator/src/lib/webhooks/index.ts
  - orchestrator/src/app/api/webhooks/signals/route.ts
autonomous: true

must_haves:
  truths:
    - "External systems can POST signals to /api/webhooks/signals"
    - "Webhooks are authenticated via X-API-Key header"
    - "Webhooks are authenticated via X-Webhook-Signature + X-Workspace-ID headers"
    - "Webhook returns 200 immediately, processes signal asynchronously"
    - "Duplicate webhooks with same sourceRef create no duplicate signals"
  artifacts:
    - path: "orchestrator/src/lib/webhooks/auth.ts"
      provides: "verifyWebhookAuth function for dual authentication"
      exports: ["verifyWebhookAuth"]
    - path: "orchestrator/src/lib/webhooks/processor.ts"
      provides: "processSignalWebhook for async signal creation"
      exports: ["processSignalWebhook"]
    - path: "orchestrator/src/app/api/webhooks/signals/route.ts"
      provides: "POST endpoint for signal webhooks"
      exports: ["POST", "GET"]
  key_links:
    - from: "route.ts"
      to: "auth.ts"
      via: "verifyWebhookAuth import"
      pattern: "import.*verifyWebhookAuth.*from.*webhooks/auth"
    - from: "route.ts"
      to: "processor.ts"
      via: "processSignalWebhook in after()"
      pattern: "after.*processSignalWebhook"
    - from: "processor.ts"
      to: "signals table"
      via: "db.insert with onConflictDoNothing"
      pattern: "db\\.insert\\(signals\\)"
---

<objective>
Create the webhook authentication utilities and signal ingestion endpoint.

Purpose: External systems (Ask Elephant, Zapier, etc.) need a secure, reliable endpoint to post user feedback. The queue-first pattern ensures fast acknowledgment while async processing handles signal creation.

Output: /api/webhooks/signals endpoint with dual authentication (API key + HMAC), queue-first pattern using after(), and idempotent signal creation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-webhook-ingestion/13-RESEARCH.md
@.planning/phases/13-webhook-ingestion/13-01-SUMMARY.md
@orchestrator/src/lib/db/schema.ts
@orchestrator/src/app/api/webhooks/ingest/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook authentication utilities</name>
  <files>orchestrator/src/lib/webhooks/auth.ts, orchestrator/src/lib/webhooks/index.ts</files>
  <action>
Create `orchestrator/src/lib/webhooks/` directory and add auth utilities.

**orchestrator/src/lib/webhooks/auth.ts:**

```typescript
/**
 * Webhook authentication utilities
 * Supports both API key and HMAC signature verification
 */
import crypto from "crypto";
import { NextRequest } from "next/server";
import { db } from "@/lib/db";
import { webhookKeys } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";

export interface AuthResult {
  valid: boolean;
  workspaceId?: string;
  webhookKeyId?: string;
  error?: string;
}

/**
 * Verify HMAC-SHA256 signature using timing-safe comparison
 */
export function verifyHmacSignature(
  rawBody: string,
  signature: string,
  secret: string
): boolean {
  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(rawBody)
    .digest("hex");

  // Handle both 'sha256=xxx' and plain 'xxx' formats
  const normalizedSignature = signature.startsWith("sha256=")
    ? signature.slice(7)
    : signature;

  try {
    return crypto.timingSafeEqual(
      Buffer.from(normalizedSignature, "hex"),
      Buffer.from(expectedSignature, "hex")
    );
  } catch {
    // Buffer lengths don't match - invalid signature format
    return false;
  }
}

/**
 * Verify webhook authentication via API key or HMAC signature
 *
 * Supports two authentication methods:
 * 1. API Key: X-API-Key header contains the apiKey from webhookKeys table
 * 2. HMAC Signature: X-Webhook-Signature + X-Workspace-ID headers
 */
export async function verifyWebhookAuth(
  request: NextRequest,
  rawBody: string
): Promise<AuthResult> {
  // Option 1: HMAC Signature (preferred for security)
  const signature = request.headers.get("x-webhook-signature");
  const workspaceIdHeader = request.headers.get("x-workspace-id");

  if (signature && workspaceIdHeader) {
    const webhookKey = await db.query.webhookKeys.findFirst({
      where: and(
        eq(webhookKeys.workspaceId, workspaceIdHeader),
        eq(webhookKeys.isActive, true)
      ),
    });

    if (!webhookKey) {
      return { valid: false, error: "Invalid workspace or inactive key" };
    }

    const isValid = verifyHmacSignature(rawBody, signature, webhookKey.secret);
    if (!isValid) {
      return { valid: false, error: "Invalid signature" };
    }

    return {
      valid: true,
      workspaceId: webhookKey.workspaceId,
      webhookKeyId: webhookKey.id,
    };
  }

  // Option 2: API Key (simpler integration)
  const apiKey = request.headers.get("x-api-key");
  if (apiKey) {
    const webhookKey = await db.query.webhookKeys.findFirst({
      where: and(
        eq(webhookKeys.apiKey, apiKey),
        eq(webhookKeys.isActive, true)
      ),
    });

    if (!webhookKey) {
      return { valid: false, error: "Invalid API key" };
    }

    return {
      valid: true,
      workspaceId: webhookKey.workspaceId,
      webhookKeyId: webhookKey.id,
    };
  }

  return { valid: false, error: "No authentication provided" };
}

/**
 * Generate new webhook credentials
 * Returns prefixed API key and hex-encoded HMAC secret
 */
export function generateWebhookCredentials(): { apiKey: string; secret: string } {
  const { nanoid } = require("nanoid");
  return {
    apiKey: `wk_${nanoid(32)}`,
    secret: crypto.randomBytes(32).toString("hex"),
  };
}
```

**orchestrator/src/lib/webhooks/index.ts:**

```typescript
export { verifyWebhookAuth, verifyHmacSignature, generateWebhookCredentials } from "./auth";
export type { AuthResult } from "./auth";
```

Pattern notes:
- Use crypto.timingSafeEqual() to prevent timing attacks
- Support both "sha256=xxx" and plain "xxx" signature formats
- Always check isActive to allow key deactivation without deletion
  </action>
  <verify>
- File exists: `ls orchestrator/src/lib/webhooks/auth.ts`
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit 2>&1 | grep -E "error|webhooks" | head -10`
  </verify>
  <done>verifyWebhookAuth and generateWebhookCredentials functions created with dual auth support</done>
</task>

<task type="auto">
  <name>Task 2: Create signal webhook processor</name>
  <files>orchestrator/src/lib/webhooks/processor.ts, orchestrator/src/lib/webhooks/index.ts</files>
  <action>
Create the async signal processor that runs in after() context.

**orchestrator/src/lib/webhooks/processor.ts:**

```typescript
/**
 * Async signal processing for webhooks
 * Runs in after() context after immediate 200 response
 */
import { db } from "@/lib/db";
import { signals, webhookKeys, activityLogs } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";

export interface SignalWebhookPayload {
  // Required
  verbatim: string;

  // Optional structured data
  interpretation?: string;
  severity?: "critical" | "high" | "medium" | "low";
  frequency?: "common" | "occasional" | "rare";
  userSegment?: string;

  // Source tracking
  sourceRef?: string;        // External ID for idempotency
  sourceUrl?: string;        // Link to original source

  // Ask Elephant specific
  interviewDate?: string;
  interviewee?: string;
  tags?: string[];
}

export interface ProcessWebhookInput {
  workspaceId: string;
  payload: SignalWebhookPayload;
  receivedAt: Date;
  webhookKeyId?: string;
}

export interface ProcessResult {
  created: boolean;
  signalId?: string;
  duplicate?: boolean;
  error?: string;
}

/**
 * Process a webhook payload into a signal
 * Uses onConflictDoNothing for idempotency
 */
export async function processSignalWebhook(
  input: ProcessWebhookInput
): Promise<ProcessResult> {
  const { workspaceId, payload, receivedAt, webhookKeyId } = input;

  // Generate sourceRef if not provided (timestamp-based for uniqueness)
  const sourceRef = payload.sourceRef || `webhook-${receivedAt.getTime()}-${nanoid(8)}`;

  try {
    // Idempotent insert - database unique constraint handles duplicates
    // Note: signals table doesn't have unique constraint on sourceRef yet,
    // so we check-then-insert with a unique sourceRef pattern
    const existingSignal = await db.query.signals.findFirst({
      where: (signals, { and, eq }) =>
        and(
          eq(signals.workspaceId, workspaceId),
          eq(signals.source, "webhook"),
          eq(signals.sourceRef, sourceRef)
        ),
    });

    if (existingSignal) {
      return { created: false, signalId: existingSignal.id, duplicate: true };
    }

    const [signal] = await db
      .insert(signals)
      .values({
        id: nanoid(),
        workspaceId,
        verbatim: payload.verbatim,
        interpretation: payload.interpretation,
        severity: payload.severity,
        frequency: payload.frequency,
        userSegment: payload.userSegment,
        source: "webhook",
        sourceRef,
        sourceMetadata: {
          sourceUrl: payload.sourceUrl,
          interviewDate: payload.interviewDate,
          interviewee: payload.interviewee,
          webhookKeyId,
          receivedAt: receivedAt.toISOString(),
          tags: payload.tags,
          rawPayload: payload,
        },
        status: "new",
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    // Update webhook key last used timestamp
    if (webhookKeyId) {
      await db
        .update(webhookKeys)
        .set({ lastUsedAt: new Date() })
        .where(eq(webhookKeys.id, webhookKeyId));
    }

    // Log activity
    await db.insert(activityLogs).values({
      id: nanoid(),
      workspaceId,
      action: "signal.created",
      targetType: "signal",
      targetId: signal.id,
      metadata: {
        source: "webhook",
        webhookKeyId,
        verbatimPreview: payload.verbatim.slice(0, 100),
      },
      createdAt: new Date(),
    });

    return { created: true, signalId: signal.id };
  } catch (error) {
    console.error("Webhook processing error:", error);
    // Don't throw - webhook is already ACKed
    // Error is logged for debugging, could create notification for visibility
    return {
      created: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}
```

Update **orchestrator/src/lib/webhooks/index.ts:**

```typescript
export { verifyWebhookAuth, verifyHmacSignature, generateWebhookCredentials } from "./auth";
export type { AuthResult } from "./auth";
export { processSignalWebhook } from "./processor";
export type { SignalWebhookPayload, ProcessWebhookInput, ProcessResult } from "./processor";
```

Pattern notes:
- Use check-then-insert for idempotency (sourceRef uniqueness)
- Never throw in after() context - log errors instead
- Update lastUsedAt for monitoring webhook usage
- Log activity for audit trail
  </action>
  <verify>
- File exists: `ls orchestrator/src/lib/webhooks/processor.ts`
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit 2>&1 | grep -E "error|processor" | head -10`
  </verify>
  <done>processSignalWebhook function creates signals with idempotency handling and activity logging</done>
</task>

<task type="auto">
  <name>Task 3: Create signal webhook endpoint</name>
  <files>orchestrator/src/app/api/webhooks/signals/route.ts</files>
  <action>
Create the /api/webhooks/signals endpoint using queue-first pattern.

**orchestrator/src/app/api/webhooks/signals/route.ts:**

```typescript
/**
 * Signal webhook endpoint
 *
 * POST /api/webhooks/signals
 *
 * Receives signals from external sources (Ask Elephant, Zapier, etc.)
 * Uses queue-first pattern: immediate 200 response, async processing via after()
 *
 * Authentication options:
 * 1. X-API-Key header (simple)
 * 2. X-Webhook-Signature + X-Workspace-ID headers (HMAC-SHA256)
 */
import { after } from "next/server";
import { NextRequest, NextResponse } from "next/server";
import { verifyWebhookAuth } from "@/lib/webhooks/auth";
import { processSignalWebhook, SignalWebhookPayload } from "@/lib/webhooks/processor";

export async function POST(request: NextRequest) {
  const receivedAt = new Date();

  // 1. Read raw body for signature verification (must be before JSON.parse)
  const rawBody = await request.text();

  // 2. Verify authentication (fast - ~20ms with db lookup)
  const auth = await verifyWebhookAuth(request, rawBody);
  if (!auth.valid) {
    return NextResponse.json(
      { error: auth.error, code: "UNAUTHORIZED" },
      { status: 401 }
    );
  }

  // 3. Parse and validate payload
  let payload: SignalWebhookPayload;
  try {
    payload = JSON.parse(rawBody);
  } catch {
    return NextResponse.json(
      { error: "Invalid JSON", code: "INVALID_PAYLOAD" },
      { status: 400 }
    );
  }

  // 4. Validate required fields
  if (!payload.verbatim || typeof payload.verbatim !== "string") {
    return NextResponse.json(
      { error: "Missing required field: verbatim", code: "VALIDATION_ERROR" },
      { status: 400 }
    );
  }

  if (payload.verbatim.trim().length === 0) {
    return NextResponse.json(
      { error: "verbatim cannot be empty", code: "VALIDATION_ERROR" },
      { status: 400 }
    );
  }

  // 5. Queue async processing, return immediately
  after(async () => {
    await processSignalWebhook({
      workspaceId: auth.workspaceId!,
      payload,
      receivedAt,
      webhookKeyId: auth.webhookKeyId,
    });
  });

  // 6. Return success (target: < 100ms total)
  return NextResponse.json({
    success: true,
    message: "Signal received, processing async",
    receivedAt: receivedAt.toISOString(),
  });
}

/**
 * Health check / documentation endpoint
 */
export async function GET() {
  return NextResponse.json({
    status: "ok",
    endpoint: "/api/webhooks/signals",
    version: "1.0",
    authentication: {
      option1: {
        name: "API Key",
        headers: ["X-API-Key"],
        description: "Simple authentication using workspace API key",
      },
      option2: {
        name: "HMAC Signature",
        headers: ["X-Webhook-Signature", "X-Workspace-ID"],
        description: "Secure authentication with payload signature verification",
        signatureFormat: "sha256=<hex-encoded-hmac>",
      },
    },
    payload: {
      required: {
        verbatim: "string - The actual user quote or feedback",
      },
      optional: {
        interpretation: "string - PM interpretation of the feedback",
        severity: "critical | high | medium | low",
        frequency: "common | occasional | rare",
        userSegment: "string - e.g., enterprise, SMB, prosumer",
        sourceRef: "string - External ID for idempotency",
        sourceUrl: "string - Link to original source",
        interviewDate: "string - Date of interview/conversation",
        interviewee: "string - Name or identifier of the person",
        tags: "string[] - Optional tags",
      },
    },
    example: {
      verbatim: "I can never find where my previous conversations went",
      interpretation: "User struggles with conversation history navigation",
      severity: "medium",
      frequency: "common",
      sourceRef: "ae-transcript-12345",
      interviewee: "Customer A",
    },
  });
}
```

Pattern notes:
- Use after() from 'next/server' for queue-first pattern (not waitUntil)
- Read raw body BEFORE parsing for HMAC verification
- Return 200 immediately, process async
- GET endpoint provides API documentation for integrators
  </action>
  <verify>
- File exists: `ls orchestrator/src/app/api/webhooks/signals/route.ts`
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit 2>&1 | grep -E "error|signals" | head -10`
- Exports POST and GET: `grep -E "export async function (POST|GET)" orchestrator/src/app/api/webhooks/signals/route.ts`
  </verify>
  <done>/api/webhooks/signals endpoint accepts POST with auth, returns 200 immediately, processes via after()</done>
</task>

</tasks>

<verification>
1. All files compile: `cd orchestrator && npx tsc --noEmit`
2. Auth module exists with exports: `grep -E "export (function|async)" orchestrator/src/lib/webhooks/auth.ts`
3. Processor module exists with exports: `grep -E "export (function|async|interface)" orchestrator/src/lib/webhooks/processor.ts`
4. Route uses after(): `grep "after(" orchestrator/src/app/api/webhooks/signals/route.ts`
5. Route imports auth: `grep "verifyWebhookAuth" orchestrator/src/app/api/webhooks/signals/route.ts`
6. Route imports processor: `grep "processSignalWebhook" orchestrator/src/app/api/webhooks/signals/route.ts`
</verification>

<success_criteria>
- /api/webhooks/signals POST endpoint exists and compiles
- verifyWebhookAuth supports both X-API-Key and X-Webhook-Signature+X-Workspace-ID
- HMAC verification uses crypto.timingSafeEqual for security
- processSignalWebhook creates signals with source="webhook"
- Duplicate sourceRef values do not create duplicate signals
- after() is used for async processing after immediate response
- GET endpoint returns API documentation
</success_criteria>

<output>
After completion, create `.planning/phases/13-webhook-ingestion/13-02-SUMMARY.md`
</output>
