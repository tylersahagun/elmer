---
phase: 16-classification-and-clustering
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - orchestrator/src/lib/classification/classifier.ts
  - orchestrator/src/lib/classification/index.ts
  - orchestrator/src/lib/db/queries.ts
  - orchestrator/src/lib/signals/processor.ts
autonomous: true

must_haves:
  truths:
    - "Signals can be auto-classified as belonging to existing project or new initiative"
    - "Classification includes confidence score (0-1)"
    - "Two-tier classification: embedding similarity first, LLM for ambiguous cases"
    - "Project embeddings are generated from name + description"
    - "Classification results are stored in signals.classification"
  artifacts:
    - path: "orchestrator/src/lib/classification/classifier.ts"
      provides: "Two-tier hybrid classifier (embedding + LLM)"
      exports: ["classifySignal", "generateProjectEmbedding"]
    - path: "orchestrator/src/lib/classification/index.ts"
      provides: "Barrel export for classification module"
      exports: ["classifySignal"]
    - path: "orchestrator/src/lib/db/queries.ts"
      provides: "Vector similarity query helpers"
      exports: ["findSimilarSignals", "findBestProjectMatch", "updateSignalClassification"]
  key_links:
    - from: "orchestrator/src/lib/classification/classifier.ts"
      to: "orchestrator/src/lib/db/queries.ts"
      via: "findBestProjectMatch query"
      pattern: "findBestProjectMatch"
    - from: "orchestrator/src/lib/signals/processor.ts"
      to: "orchestrator/src/lib/classification/classifier.ts"
      via: "classifySignal call after embedding generation"
      pattern: "classifySignal"
---

<objective>
Build two-tier classification system for auto-routing signals to projects

Purpose: Enable INTL-01 (auto-classify signals) and INTL-02 (confidence scores). Signals should be automatically classified as "belongs to Project X" or "new initiative" with confidence scoring. Use embedding similarity for 90% of cases (free, fast) and LLM only for ambiguous signals (0.5-0.75 similarity range).

Output:
- Hybrid classifier module (embedding + LLM tiers)
- Project embedding generation utility
- Vector similarity query helpers
- Integration into signal processing pipeline
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-classification-and-clustering/16-RESEARCH.md
@.planning/phases/16-classification-and-clustering/16-01-SUMMARY.md
@orchestrator/src/lib/db/schema.ts
@orchestrator/src/lib/db/queries.ts
@orchestrator/src/lib/ai/embeddings.ts
@orchestrator/src/lib/ai/extraction.ts
@orchestrator/src/lib/signals/processor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Vector Query Helpers to queries.ts</name>
  <files>orchestrator/src/lib/db/queries.ts</files>
  <action>
Add new query functions for vector similarity operations. Add near the end of the file, after existing signal queries:

```typescript
// ============================================
// VECTOR SIMILARITY QUERIES (Phase 16)
// ============================================

/**
 * Find signals similar to a given embedding vector.
 * Uses pgvector cosine distance (1 - cosine_similarity).
 *
 * @param workspaceId - Filter to this workspace
 * @param targetVector - The embedding to compare against
 * @param limit - Max results (default 10)
 * @param excludeId - Signal ID to exclude (the query signal itself)
 * @returns Signals ordered by similarity (closest first)
 */
export async function findSimilarSignals(
  workspaceId: string,
  targetVector: number[],
  limit = 10,
  excludeId?: string
) {
  // Build WHERE conditions
  const conditions = [
    eq(signals.workspaceId, workspaceId),
    isNotNull(signals.embeddingVector),
  ];
  if (excludeId) {
    conditions.push(ne(signals.id, excludeId));
  }

  // Use raw SQL for pgvector distance operator
  const vectorStr = `[${targetVector.join(",")}]`;

  const result = await db.execute(sql`
    SELECT
      id,
      verbatim,
      interpretation,
      severity,
      frequency,
      status,
      source,
      created_at,
      embedding_vector <=> ${vectorStr}::vector AS distance
    FROM signals
    WHERE workspace_id = ${workspaceId}
      AND embedding_vector IS NOT NULL
      ${excludeId ? sql`AND id != ${excludeId}` : sql``}
    ORDER BY embedding_vector <=> ${vectorStr}::vector
    LIMIT ${limit}
  `);

  return result.rows.map((row: Record<string, unknown>) => ({
    id: row.id as string,
    verbatim: row.verbatim as string,
    interpretation: row.interpretation as string | null,
    severity: row.severity as string | null,
    frequency: row.frequency as string | null,
    status: row.status as string,
    source: row.source as string,
    createdAt: row.created_at as Date,
    distance: row.distance as number,
    similarity: 1 - (row.distance as number), // Convert distance to similarity
  }));
}

/**
 * Find the best matching project for a signal embedding.
 * Returns the project with lowest cosine distance.
 *
 * @param workspaceId - Filter to this workspace
 * @param signalVector - The signal's embedding vector
 * @returns Best matching project with distance/similarity, or null if no projects have embeddings
 */
export async function findBestProjectMatch(
  workspaceId: string,
  signalVector: number[]
) {
  const vectorStr = `[${signalVector.join(",")}]`;

  const result = await db.execute(sql`
    SELECT
      id,
      name,
      description,
      stage,
      embedding_vector <=> ${vectorStr}::vector AS distance
    FROM projects
    WHERE workspace_id = ${workspaceId}
      AND embedding_vector IS NOT NULL
      AND status = 'active'
    ORDER BY embedding_vector <=> ${vectorStr}::vector
    LIMIT 1
  `);

  if (result.rows.length === 0) {
    return null;
  }

  const row = result.rows[0] as Record<string, unknown>;
  return {
    id: row.id as string,
    name: row.name as string,
    description: row.description as string | null,
    stage: row.stage as string,
    distance: row.distance as number,
    similarity: 1 - (row.distance as number),
  };
}

/**
 * Update a signal's classification result.
 */
export async function updateSignalClassification(
  id: string,
  classification: SignalClassificationResult
) {
  await db
    .update(signals)
    .set({
      classification,
      updatedAt: new Date(),
    })
    .where(eq(signals.id, id));

  return getSignal(id);
}

/**
 * Update a project's embedding vector.
 */
export async function updateProjectEmbedding(
  id: string,
  embeddingVector: number[]
) {
  await db
    .update(projects)
    .set({
      embeddingVector,
      embeddingUpdatedAt: new Date(),
      updatedAt: new Date(),
    })
    .where(eq(projects.id, id));

  return getProject(id);
}

/**
 * Get unlinked signals with embeddings for clustering.
 */
export async function getUnlinkedSignalsWithEmbeddings(
  workspaceId: string,
  limit = 100
) {
  return db.query.signals.findMany({
    where: and(
      eq(signals.workspaceId, workspaceId),
      isNotNull(signals.embeddingVector),
      or(
        eq(signals.status, "new"),
        eq(signals.status, "reviewed")
      )
    ),
    orderBy: [desc(signals.createdAt)],
    limit,
  });
}
```

Also add the import for SignalClassificationResult type at the top if not already imported:
```typescript
import { type SignalClassificationResult } from "./schema";
```

And add sql to the drizzle-orm imports if needed:
```typescript
import { ..., sql } from "drizzle-orm";
```
  </action>
  <verify>TypeScript compiles with `cd orchestrator && npx tsc --noEmit`. New functions are exported.</verify>
  <done>Vector similarity query helpers added: findSimilarSignals, findBestProjectMatch, updateSignalClassification, updateProjectEmbedding</done>
</task>

<task type="auto">
  <name>Task 2: Create Classification Module</name>
  <files>orchestrator/src/lib/classification/classifier.ts, orchestrator/src/lib/classification/index.ts</files>
  <action>
Create lib/classification directory and classifier module:

**classifier.ts:**
```typescript
/**
 * Signal Classification Module
 *
 * Two-tier hybrid classification:
 * - Tier 1: Embedding similarity (fast, free)
 * - Tier 2: LLM verification (for ambiguous 0.5-0.75 range)
 *
 * Thresholds:
 * - > 0.75: High confidence, auto-classify to project
 * - 0.5-0.75: Medium confidence, verify with LLM
 * - < 0.5: Low confidence, classify as "new initiative"
 */

import Anthropic from "@anthropic-ai/sdk";
import { generateEmbedding } from "@/lib/ai/embeddings";
import {
  findBestProjectMatch,
  updateSignalClassification,
  updateProjectEmbedding,
  getProject,
} from "@/lib/db/queries";
import type { SignalClassificationResult } from "@/lib/db/schema";

// Classification thresholds
const HIGH_CONFIDENCE_THRESHOLD = 0.75;
const LOW_CONFIDENCE_THRESHOLD = 0.5;

/**
 * Classify a signal to determine if it belongs to an existing project
 * or represents a new initiative.
 *
 * @param signalId - ID of the signal to classify
 * @param signalVector - The signal's embedding vector
 * @param signalVerbatim - The signal's verbatim text (for LLM tier)
 * @param workspaceId - The workspace to search for projects
 * @returns Classification result
 */
export async function classifySignal(
  signalId: string,
  signalVector: number[],
  signalVerbatim: string,
  workspaceId: string
): Promise<SignalClassificationResult> {
  // Find best matching project
  const bestMatch = await findBestProjectMatch(workspaceId, signalVector);

  const now = new Date().toISOString();

  // No projects with embeddings - mark as new initiative
  if (!bestMatch) {
    const result: SignalClassificationResult = {
      confidence: 0.9,
      method: "embedding",
      isNewInitiative: true,
      reason: "No projects with embeddings found in workspace",
      classifiedAt: now,
    };

    await updateSignalClassification(signalId, result);
    return result;
  }

  // High confidence - auto-classify to project
  if (bestMatch.similarity > HIGH_CONFIDENCE_THRESHOLD) {
    const result: SignalClassificationResult = {
      projectId: bestMatch.id,
      projectName: bestMatch.name,
      confidence: bestMatch.similarity,
      method: "embedding",
      isNewInitiative: false,
      reason: `High similarity (${(bestMatch.similarity * 100).toFixed(1)}%) to project "${bestMatch.name}"`,
      classifiedAt: now,
    };

    await updateSignalClassification(signalId, result);
    return result;
  }

  // Low confidence - mark as new initiative
  if (bestMatch.similarity < LOW_CONFIDENCE_THRESHOLD) {
    const result: SignalClassificationResult = {
      confidence: 1 - bestMatch.similarity, // Confidence in "new initiative"
      method: "embedding",
      isNewInitiative: true,
      reason: `Low similarity (${(bestMatch.similarity * 100).toFixed(1)}%) to any existing project`,
      classifiedAt: now,
    };

    await updateSignalClassification(signalId, result);
    return result;
  }

  // Medium confidence (0.5-0.75) - use LLM verification
  console.log(
    `Signal ${signalId}: Medium confidence (${(bestMatch.similarity * 100).toFixed(1)}%), using LLM verification`
  );

  return llmClassify(signalId, signalVerbatim, bestMatch, now);
}

/**
 * LLM-based classification for ambiguous signals.
 */
async function llmClassify(
  signalId: string,
  signalVerbatim: string,
  bestMatch: {
    id: string;
    name: string;
    description: string | null;
    similarity: number;
  },
  classifiedAt: string
): Promise<SignalClassificationResult> {
  try {
    const anthropic = new Anthropic();

    const response = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 300,
      system: `You are a product manager assistant. Determine if user feedback belongs to an existing project.

Return ONLY valid JSON with these fields:
- belongs: boolean (true if feedback relates to the project)
- confidence: number 0-1 (how confident are you)
- reason: string (brief explanation)`,
      messages: [
        {
          role: "user",
          content: `Does this user feedback relate to the project "${bestMatch.name}"?

Project description: ${bestMatch.description || "No description"}

User feedback:
"${signalVerbatim.slice(0, 500)}"

Return JSON only.`,
        },
      ],
    });

    const content = response.content[0];
    if (content.type !== "text") {
      throw new Error("Unexpected response type");
    }

    const parsed = JSON.parse(content.text) as {
      belongs: boolean;
      confidence: number;
      reason: string;
    };

    const result: SignalClassificationResult = {
      projectId: parsed.belongs ? bestMatch.id : undefined,
      projectName: parsed.belongs ? bestMatch.name : undefined,
      confidence: parsed.confidence,
      method: "llm",
      isNewInitiative: !parsed.belongs,
      reason: parsed.reason,
      classifiedAt,
    };

    await updateSignalClassification(signalId, result);
    return result;
  } catch (error) {
    console.error("LLM classification failed:", error);

    // Fallback to embedding-based decision on LLM failure
    const result: SignalClassificationResult = {
      projectId: bestMatch.similarity > 0.6 ? bestMatch.id : undefined,
      projectName: bestMatch.similarity > 0.6 ? bestMatch.name : undefined,
      confidence: bestMatch.similarity,
      method: "embedding",
      isNewInitiative: bestMatch.similarity <= 0.6,
      reason: `LLM verification failed, using embedding similarity (${(bestMatch.similarity * 100).toFixed(1)}%)`,
      classifiedAt,
    };

    await updateSignalClassification(signalId, result);
    return result;
  }
}

/**
 * Generate and store embedding for a project.
 * Uses project name + description as input text.
 *
 * @param projectId - ID of the project to generate embedding for
 * @returns The updated project, or null if generation failed
 */
export async function generateProjectEmbedding(projectId: string) {
  const project = await getProject(projectId);

  if (!project) {
    console.warn(`Project ${projectId} not found for embedding generation`);
    return null;
  }

  // Combine name and description for embedding
  const text = [project.name, project.description].filter(Boolean).join(". ");

  if (text.trim().length < 5) {
    console.warn(`Project ${projectId} has insufficient text for embedding`);
    return null;
  }

  try {
    const embedding = await generateEmbedding(text);
    await updateProjectEmbedding(projectId, embedding);

    console.log(`Generated embedding for project ${projectId} (${project.name})`);
    return project;
  } catch (error) {
    console.error(`Failed to generate embedding for project ${projectId}:`, error);
    return null;
  }
}
```

**index.ts:**
```typescript
/**
 * Classification Module Barrel Export
 *
 * Provides signal classification and project embedding utilities.
 */

export { classifySignal, generateProjectEmbedding } from "./classifier";
```
  </action>
  <verify>TypeScript compiles with `cd orchestrator && npx tsc --noEmit`. Classification module exports classifySignal and generateProjectEmbedding.</verify>
  <done>Two-tier hybrid classifier created with embedding similarity and LLM verification tiers</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Classification into Signal Processor</name>
  <files>orchestrator/src/lib/signals/processor.ts</files>
  <action>
Update processor.ts to call classification after embedding generation:

1. Add import at top:
```typescript
import { classifySignal } from "@/lib/classification";
```

2. Update processSignalExtraction function to classify after embedding:

After the line that updates the signal with embedding, add classification:

```typescript
// After: await updateSignalProcessing(signalId, { ... });

// Classify signal if embedding was generated
if (embeddingVector && embeddingVector.length === 1536) {
  try {
    // Get the signal's workspace for classification context
    const updatedSignal = await getSignal(signalId);
    if (updatedSignal) {
      await classifySignal(
        signalId,
        embeddingVector,
        signal.verbatim,
        updatedSignal.workspaceId
      );
      console.info(`Signal ${signalId} classified`);
    }
  } catch (classifyError) {
    // Classification failure should not fail the overall processing
    console.error(`Classification failed for signal ${signalId}:`, classifyError);
  }
}
```

The full processSignalExtraction function should now:
1. Extract fields (severity, frequency, userSegment, interpretation)
2. Generate embedding
3. Update signal with extracted data and embedding
4. Classify signal against workspace projects

Classification is a best-effort addition - if it fails, the signal is still processed with its embedding.
  </action>
  <verify>TypeScript compiles. processSignalExtraction now imports and calls classifySignal.</verify>
  <done>Signal processor now auto-classifies signals after embedding generation</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. TypeScript compiles:
   ```bash
   cd orchestrator && npx tsc --noEmit
   ```

2. Query helpers exist:
   ```bash
   grep -n "findSimilarSignals\|findBestProjectMatch" orchestrator/src/lib/db/queries.ts
   ```

3. Classification module exists:
   ```bash
   ls orchestrator/src/lib/classification/
   ```

4. Processor imports classification:
   ```bash
   grep -n "classifySignal" orchestrator/src/lib/signals/processor.ts
   ```
</verification>

<success_criteria>
- Vector similarity query helpers are added to queries.ts
- Two-tier classifier module is created with embedding + LLM tiers
- Project embedding generation utility is available
- Signal processor automatically classifies signals after embedding
- TypeScript compiles without errors
- All files committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/16-classification-and-clustering/16-02-SUMMARY.md`
</output>
