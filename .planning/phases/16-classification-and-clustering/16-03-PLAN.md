---
phase: 16-classification-and-clustering
plan: 03
type: execute
wave: 3
depends_on: ["16-02"]
files_modified:
  - orchestrator/src/lib/classification/clustering.ts
  - orchestrator/src/lib/classification/index.ts
  - orchestrator/src/app/api/signals/synthesize/route.ts
  - orchestrator/src/app/api/signals/[id]/similar/route.ts
  - orchestrator/src/app/api/signals/[id]/classify/route.ts
autonomous: true

must_haves:
  truths:
    - "Related signals cluster together by semantic similarity"
    - "/synthesize command finds patterns and proposes new initiatives"
    - "User can find signals similar to a given signal"
    - "User can manually trigger re-classification of a signal"
    - "Clusters include theme summary and suggested action"
  artifacts:
    - path: "orchestrator/src/lib/classification/clustering.ts"
      provides: "K-NN clustering for signal synthesis"
      exports: ["findSignalClusters", "generateClusterTheme"]
    - path: "orchestrator/src/app/api/signals/synthesize/route.ts"
      provides: "/api/signals/synthesize endpoint"
      exports: ["POST"]
    - path: "orchestrator/src/app/api/signals/[id]/similar/route.ts"
      provides: "Find similar signals endpoint"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/[id]/classify/route.ts"
      provides: "Manual classification trigger endpoint"
      exports: ["POST"]
  key_links:
    - from: "orchestrator/src/app/api/signals/synthesize/route.ts"
      to: "orchestrator/src/lib/classification/clustering.ts"
      via: "findSignalClusters call"
      pattern: "findSignalClusters"
    - from: "orchestrator/src/lib/classification/clustering.ts"
      to: "orchestrator/src/lib/db/queries.ts"
      via: "findSimilarSignals query"
      pattern: "findSimilarSignals"
---

<objective>
Implement K-NN clustering and /synthesize command for pattern discovery

Purpose: Enable INTL-05 (cluster signals by similarity) and INTL-07 (/synthesize command). Users can discover patterns across unlinked signals, find semantic clusters, and get AI-generated suggestions for new initiatives.

Output:
- K-NN clustering module using pgvector similarity queries
- /api/signals/synthesize endpoint for cluster discovery
- /api/signals/[id]/similar endpoint for finding related signals
- /api/signals/[id]/classify endpoint for manual classification trigger
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-classification-and-clustering/16-RESEARCH.md
@.planning/phases/16-classification-and-clustering/16-01-SUMMARY.md
@.planning/phases/16-classification-and-clustering/16-02-SUMMARY.md
@orchestrator/src/lib/db/queries.ts
@orchestrator/src/lib/classification/classifier.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Clustering Module</name>
  <files>orchestrator/src/lib/classification/clustering.ts, orchestrator/src/lib/classification/index.ts</files>
  <action>
Create clustering.ts for K-NN based signal clustering:

**clustering.ts:**
```typescript
/**
 * Signal Clustering Module
 *
 * Uses K-NN queries via pgvector to find semantic clusters in unlinked signals.
 * Clusters are generated on-demand for /synthesize command.
 *
 * Pattern:
 * 1. Get unlinked signals with embeddings
 * 2. For each seed signal, find K nearest neighbors
 * 3. Filter by distance threshold
 * 4. Deduplicate overlapping clusters
 * 5. Generate themes for clusters via LLM
 */

import Anthropic from "@anthropic-ai/sdk";
import { nanoid } from "nanoid";
import {
  findSimilarSignals,
  getUnlinkedSignalsWithEmbeddings,
} from "@/lib/db/queries";
import type { SignalSeverity, SignalFrequency } from "@/lib/db/schema";

// Clustering parameters
const NEIGHBOR_LIMIT = 10;
const DISTANCE_THRESHOLD = 0.3; // cosine distance < 0.3 = similarity > 0.7
const MIN_CLUSTER_SIZE = 2;

export interface ClusterSignal {
  id: string;
  verbatim: string;
  interpretation: string | null;
  severity: SignalSeverity | null;
  frequency: SignalFrequency | null;
  distance: number;
  similarity: number;
}

export interface SignalCluster {
  id: string;
  signals: ClusterSignal[];
  theme: string;
  severity: SignalSeverity;
  frequency: SignalFrequency;
  suggestedAction: "new_project" | "link_to_existing" | "review";
  confidence: number;
  signalCount: number;
}

/**
 * Find clusters of semantically similar unlinked signals.
 *
 * @param workspaceId - Workspace to search
 * @param minClusterSize - Minimum signals to form a cluster (default 2)
 * @returns Array of signal clusters with themes and suggested actions
 */
export async function findSignalClusters(
  workspaceId: string,
  minClusterSize = MIN_CLUSTER_SIZE
): Promise<SignalCluster[]> {
  // Get unlinked signals with embeddings
  const seeds = await getUnlinkedSignalsWithEmbeddings(workspaceId, 100);

  if (seeds.length === 0) {
    return [];
  }

  const clusters: SignalCluster[] = [];
  const processedIds = new Set<string>();

  for (const seed of seeds) {
    // Skip if already part of a cluster
    if (processedIds.has(seed.id)) continue;

    // Skip if no embedding vector
    if (!seed.embeddingVector) continue;

    // Find similar signals
    const neighbors = await findSimilarSignals(
      workspaceId,
      seed.embeddingVector,
      NEIGHBOR_LIMIT,
      seed.id
    );

    // Filter by distance threshold
    const closeNeighbors = neighbors.filter(
      (n) => n.distance < DISTANCE_THRESHOLD
    );

    // Check minimum cluster size (seed + neighbors)
    if (closeNeighbors.length + 1 < minClusterSize) continue;

    // Build cluster signals array
    const clusterSignals: ClusterSignal[] = [
      {
        id: seed.id,
        verbatim: seed.verbatim,
        interpretation: seed.interpretation,
        severity: seed.severity as SignalSeverity | null,
        frequency: seed.frequency as SignalFrequency | null,
        distance: 0,
        similarity: 1,
      },
      ...closeNeighbors.map((n) => ({
        id: n.id,
        verbatim: n.verbatim,
        interpretation: n.interpretation,
        severity: n.severity as SignalSeverity | null,
        frequency: n.frequency as SignalFrequency | null,
        distance: n.distance,
        similarity: n.similarity,
      })),
    ];

    // Mark all signals as processed
    clusterSignals.forEach((s) => processedIds.add(s.id));

    // Generate theme for cluster
    const theme = await generateClusterTheme(clusterSignals);

    // Aggregate severity and frequency
    const severity = aggregateSeverity(clusterSignals);
    const frequency = aggregateFrequency(clusterSignals);

    // Calculate confidence (average similarity of neighbors)
    const avgSimilarity =
      closeNeighbors.reduce((sum, n) => sum + n.similarity, 0) /
      closeNeighbors.length;

    clusters.push({
      id: nanoid(),
      signals: clusterSignals,
      theme,
      severity,
      frequency,
      suggestedAction: determineSuggestedAction(clusterSignals.length, severity),
      confidence: avgSimilarity,
      signalCount: clusterSignals.length,
    });
  }

  // Sort by signal count (largest clusters first)
  return clusters.sort((a, b) => b.signalCount - a.signalCount);
}

/**
 * Generate a theme summary for a cluster of signals.
 */
export async function generateClusterTheme(
  signals: ClusterSignal[]
): Promise<string> {
  try {
    const anthropic = new Anthropic();

    const verbatims = signals
      .slice(0, 5) // Use first 5 for context
      .map((s, i) => `${i + 1}. "${s.verbatim.slice(0, 200)}"`)
      .join("\n");

    const response = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 100,
      system:
        "Generate a short (5-10 word) theme that summarizes what these user feedback signals have in common. Return ONLY the theme, no explanation.",
      messages: [
        {
          role: "user",
          content: `Signals:\n${verbatims}\n\nTheme:`,
        },
      ],
    });

    const content = response.content[0];
    if (content.type === "text") {
      return content.text.trim();
    }

    return "Related user feedback";
  } catch (error) {
    console.error("Failed to generate cluster theme:", error);
    return "Related user feedback";
  }
}

/**
 * Aggregate severity from cluster signals (take highest)
 */
function aggregateSeverity(signals: ClusterSignal[]): SignalSeverity {
  const severityOrder: SignalSeverity[] = ["critical", "high", "medium", "low"];

  for (const severity of severityOrder) {
    if (signals.some((s) => s.severity === severity)) {
      return severity;
    }
  }

  return "medium";
}

/**
 * Aggregate frequency from cluster signals (take highest)
 */
function aggregateFrequency(signals: ClusterSignal[]): SignalFrequency {
  const frequencyOrder: SignalFrequency[] = ["common", "occasional", "rare"];

  for (const frequency of frequencyOrder) {
    if (signals.some((s) => s.frequency === frequency)) {
      return frequency;
    }
  }

  return "occasional";
}

/**
 * Determine suggested action based on cluster characteristics
 */
function determineSuggestedAction(
  signalCount: number,
  severity: SignalSeverity
): "new_project" | "link_to_existing" | "review" {
  // Large clusters with high severity = new project
  if (signalCount >= 5 && (severity === "critical" || severity === "high")) {
    return "new_project";
  }

  // Medium clusters = review for potential project
  if (signalCount >= 3) {
    return "new_project";
  }

  // Small clusters = review
  return "review";
}
```

**Update index.ts to export clustering:**
```typescript
export { classifySignal, generateProjectEmbedding } from "./classifier";
export { findSignalClusters, generateClusterTheme } from "./clustering";
export type { SignalCluster, ClusterSignal } from "./clustering";
```
  </action>
  <verify>TypeScript compiles. clustering.ts exports findSignalClusters and generateClusterTheme.</verify>
  <done>K-NN clustering module created with theme generation and action suggestions</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/signals/synthesize Endpoint</name>
  <files>orchestrator/src/app/api/signals/synthesize/route.ts</files>
  <action>
Create synthesize endpoint for pattern discovery:

```typescript
/**
 * POST /api/signals/synthesize
 *
 * Find patterns in unlinked signals and propose new initiatives.
 * This is the /synthesize command from INTL-07.
 *
 * Request body:
 * - workspaceId: string (required)
 * - minClusterSize?: number (optional, default 2)
 *
 * Response:
 * - clusters: Array of signal clusters with themes and suggested actions
 * - summary: Brief overview of findings
 */

import { NextRequest, NextResponse } from "next/server";
import { requireWorkspaceAccess } from "@/lib/permissions";
import { findSignalClusters } from "@/lib/classification";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { workspaceId, minClusterSize } = body;

    if (!workspaceId) {
      return NextResponse.json(
        { error: "workspaceId is required" },
        { status: 400 }
      );
    }

    // Require member access
    await requireWorkspaceAccess(workspaceId, "member");

    // Find signal clusters
    const clusters = await findSignalClusters(
      workspaceId,
      minClusterSize ?? 2
    );

    // Generate summary
    const summary = generateSummary(clusters);

    return NextResponse.json({
      success: true,
      clusters,
      summary,
      totalClusters: clusters.length,
      totalSignals: clusters.reduce((sum, c) => sum + c.signalCount, 0),
    });
  } catch (error) {
    console.error("Synthesize failed:", error);

    if (error instanceof Error && error.message.includes("permission")) {
      return NextResponse.json({ error: error.message }, { status: 403 });
    }

    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Synthesis failed" },
      { status: 500 }
    );
  }
}

function generateSummary(
  clusters: Awaited<ReturnType<typeof findSignalClusters>>
): string {
  if (clusters.length === 0) {
    return "No signal clusters found. Add more signals with similar themes to discover patterns.";
  }

  const newProjectCount = clusters.filter(
    (c) => c.suggestedAction === "new_project"
  ).length;

  const highPriorityCount = clusters.filter(
    (c) => c.severity === "critical" || c.severity === "high"
  ).length;

  const parts = [];

  parts.push(`Found ${clusters.length} signal cluster${clusters.length === 1 ? "" : "s"}`);

  if (newProjectCount > 0) {
    parts.push(`${newProjectCount} could become new project${newProjectCount === 1 ? "" : "s"}`);
  }

  if (highPriorityCount > 0) {
    parts.push(`${highPriorityCount} high priority`);
  }

  return parts.join(". ") + ".";
}
```
  </action>
  <verify>File exists and TypeScript compiles. Endpoint handles POST with workspaceId body parameter.</verify>
  <done>/api/signals/synthesize endpoint created for pattern discovery and clustering</done>
</task>

<task type="auto">
  <name>Task 3: Create Similar Signals and Manual Classify Endpoints</name>
  <files>orchestrator/src/app/api/signals/[id]/similar/route.ts, orchestrator/src/app/api/signals/[id]/classify/route.ts</files>
  <action>
Create two supporting endpoints:

**/api/signals/[id]/similar/route.ts:**
```typescript
/**
 * GET /api/signals/[id]/similar
 *
 * Find signals semantically similar to the given signal.
 *
 * Query params:
 * - limit?: number (default 10, max 50)
 *
 * Response:
 * - signals: Array of similar signals with similarity scores
 */

import { NextRequest, NextResponse } from "next/server";
import { requireWorkspaceAccess } from "@/lib/permissions";
import { getSignal, findSimilarSignals } from "@/lib/db/queries";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { searchParams } = new URL(request.url);
    const limit = Math.min(parseInt(searchParams.get("limit") || "10"), 50);

    // Get the signal
    const signal = await getSignal(id);
    if (!signal) {
      return NextResponse.json({ error: "Signal not found" }, { status: 404 });
    }

    // Check access
    await requireWorkspaceAccess(signal.workspaceId, "viewer");

    // Check if signal has embedding
    if (!signal.embeddingVector) {
      return NextResponse.json(
        { error: "Signal has no embedding. Wait for processing to complete." },
        { status: 400 }
      );
    }

    // Find similar signals
    const similarSignals = await findSimilarSignals(
      signal.workspaceId,
      signal.embeddingVector,
      limit,
      id
    );

    return NextResponse.json({
      success: true,
      signalId: id,
      similar: similarSignals,
      count: similarSignals.length,
    });
  } catch (error) {
    console.error("Find similar signals failed:", error);

    if (error instanceof Error && error.message.includes("permission")) {
      return NextResponse.json({ error: error.message }, { status: 403 });
    }

    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to find similar signals" },
      { status: 500 }
    );
  }
}
```

**/api/signals/[id]/classify/route.ts:**
```typescript
/**
 * POST /api/signals/[id]/classify
 *
 * Manually trigger (re-)classification of a signal.
 * Useful when projects have been added/updated and user wants fresh classification.
 *
 * Response:
 * - classification: The new classification result
 */

import { NextRequest, NextResponse } from "next/server";
import { requireWorkspaceAccess } from "@/lib/permissions";
import { getSignal } from "@/lib/db/queries";
import { classifySignal } from "@/lib/classification";

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // Get the signal
    const signal = await getSignal(id);
    if (!signal) {
      return NextResponse.json({ error: "Signal not found" }, { status: 404 });
    }

    // Require member access for classification
    await requireWorkspaceAccess(signal.workspaceId, "member");

    // Check if signal has embedding
    if (!signal.embeddingVector) {
      return NextResponse.json(
        { error: "Signal has no embedding. Wait for processing to complete." },
        { status: 400 }
      );
    }

    // Run classification
    const classification = await classifySignal(
      id,
      signal.embeddingVector,
      signal.verbatim,
      signal.workspaceId
    );

    return NextResponse.json({
      success: true,
      signalId: id,
      classification,
    });
  } catch (error) {
    console.error("Manual classification failed:", error);

    if (error instanceof Error && error.message.includes("permission")) {
      return NextResponse.json({ error: error.message }, { status: 403 });
    }

    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Classification failed" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>Both files exist and TypeScript compiles. Endpoints handle correct HTTP methods.</verify>
  <done>Similar signals and manual classify endpoints created</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. TypeScript compiles:
   ```bash
   cd orchestrator && npx tsc --noEmit
   ```

2. Clustering module exists:
   ```bash
   grep -n "findSignalClusters" orchestrator/src/lib/classification/clustering.ts
   ```

3. Synthesize endpoint exists:
   ```bash
   ls orchestrator/src/app/api/signals/synthesize/route.ts
   ```

4. Similar signals endpoint exists:
   ```bash
   ls orchestrator/src/app/api/signals/*/similar/route.ts
   ```

5. Classify endpoint exists:
   ```bash
   ls orchestrator/src/app/api/signals/*/classify/route.ts
   ```
</verification>

<success_criteria>
- K-NN clustering module is created with theme generation
- /api/signals/synthesize endpoint returns clusters with themes and actions
- /api/signals/[id]/similar endpoint returns similar signals
- /api/signals/[id]/classify endpoint allows manual re-classification
- TypeScript compiles without errors
- All files committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/16-classification-and-clustering/16-03-SUMMARY.md`
</output>
