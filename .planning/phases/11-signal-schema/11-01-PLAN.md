---
phase: 11-signal-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/lib/db/schema.ts
  - orchestrator/src/lib/db/index.ts
  - drizzle/*.sql
autonomous: true

must_haves:
  truths:
    - "Signal table exists with all required fields (verbatim, interpretation, severity, frequency, source, status)"
    - "Signals are workspace-scoped (workspaceId foreign key with cascade delete)"
    - "Source attribution captures where signal originated via source column and sourceMetadata JSONB"
    - "Status tracking supports four-state lifecycle (new, reviewed, linked, archived)"
    - "Junction tables enable many-to-many relationships with projects and personas"
  artifacts:
    - path: "orchestrator/src/lib/db/schema.ts"
      provides: "signals table, signal_projects table, signal_personas table, types, interfaces, relations"
      contains: "export const signals = pgTable"
    - path: "orchestrator/src/lib/db/index.ts"
      provides: "Signal and NewSignal type exports"
      contains: "export type Signal"
    - path: "drizzle/*.sql"
      provides: "Migration file for new tables"
      contains: "CREATE TABLE"
  key_links:
    - from: "signals.workspaceId"
      to: "workspaces.id"
      via: "foreign key reference"
      pattern: 'references.*workspaces\\.id'
    - from: "signals.inboxItemId"
      to: "inboxItems.id"
      via: "foreign key reference (provenance)"
      pattern: 'references.*inboxItems\\.id'
    - from: "signalProjects.signalId"
      to: "signals.id"
      via: "foreign key reference"
      pattern: 'references.*signals\\.id'
    - from: "signalProjects.projectId"
      to: "projects.id"
      via: "foreign key reference"
      pattern: 'references.*projects\\.id'
---

<objective>
Create the database schema foundation for the signals system including the signals table, junction tables for project/persona associations, TypeScript types, Drizzle relations, and database migration.

Purpose: Establish the data layer that all subsequent signals phases (12-20) will build upon. This phase is schema-only - no API endpoints or UI.

Output:
- signals table with all core fields
- signal_projects junction table
- signal_personas junction table
- TypeScript union types (SignalStatus, SignalSource, SignalSeverity, SignalFrequency)
- TypeScript interfaces (SignalSourceMetadata, SignalClassification)
- Drizzle relations for query support
- Type exports in index.ts
- Applied database migration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-signal-schema/11-CONTEXT.md
@.planning/phases/11-signal-schema/11-RESEARCH.md
@orchestrator/src/lib/db/schema.ts
@orchestrator/src/lib/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add signal types and interfaces to schema.ts</name>
  <files>orchestrator/src/lib/db/schema.ts</files>
  <action>
Add the following TypeScript types and interfaces BEFORE the signals table definition. Place them in a new section after the inboxItems table and its relations (after line ~1123):

```typescript
// ============================================
// SIGNALS (User Feedback Evidence)
// ============================================

// Union types (not PostgreSQL enums - extensible without migrations)
export type SignalStatus = "new" | "reviewed" | "linked" | "archived";
export type SignalSource = "webhook" | "upload" | "paste" | "video" | "slack" | "pylon" | "email" | "interview" | "other";
export type SignalSeverity = "critical" | "high" | "medium" | "low";
export type SignalFrequency = "common" | "occasional" | "rare";

// Source metadata interface (flexible JSONB)
export interface SignalSourceMetadata {
  // Common fields
  sourceUrl?: string;
  sourceName?: string;
  externalId?: string;

  // Webhook-specific
  webhookId?: string;
  webhookName?: string;

  // Video-specific
  videoUrl?: string;
  videoPlatform?: "youtube" | "loom";
  videoTimestamp?: string;

  // Slack-specific
  channelId?: string;
  channelName?: string;
  messageTs?: string;
  threadTs?: string;

  // Pylon-specific
  ticketId?: string;
  ticketStatus?: string;
  customerEmail?: string;

  // Interview-specific
  interviewDate?: string;
  interviewee?: string;

  // Raw data preservation
  rawPayload?: Record<string, unknown>;
}

// AI classification interface (populated in Phase 15-16)
export interface SignalClassification {
  classifiedAt?: string;
  projectMatches?: Array<{
    projectId: string;
    projectName: string;
    confidence: number;
    matchReason?: string;
  }>;
  isNewInitiative?: boolean;
  suggestedInitiativeName?: string;
  clusterId?: string;
  clusterName?: string;
}
```

Follow existing codebase patterns:
- Use union types with `$type<>()` for type safety (matches ProjectStage, JobType patterns)
- Use interface for JSONB columns (matches InboxItemMetadata pattern)
  </action>
  <verify>
Run `cd orchestrator && npx tsc --noEmit` - should compile without errors.
Verify types are exported (schema.ts uses `export type` and `export interface`).
  </verify>
  <done>
TypeScript union types (SignalStatus, SignalSource, SignalSeverity, SignalFrequency) and interfaces (SignalSourceMetadata, SignalClassification) exist in schema.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add signals table definition</name>
  <files>orchestrator/src/lib/db/schema.ts</files>
  <action>
Add the signals table definition immediately after the types/interfaces from Task 1:

```typescript
export const signals = pgTable("signals", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),

  // Core content
  verbatim: text("verbatim").notNull(),           // Original user quote/feedback
  interpretation: text("interpretation"),          // PM's "what this really means"

  // Structured extraction (populated by AI in Phase 15)
  severity: text("severity").$type<SignalSeverity>(),
  frequency: text("frequency").$type<SignalFrequency>(),
  userSegment: text("user_segment"),              // e.g., "enterprise", "SMB", "prosumer"

  // Source attribution (SGNL-07)
  source: text("source").$type<SignalSource>().notNull(),
  sourceRef: text("source_ref"),                  // External reference (URL, ticket ID, etc.)
  sourceMetadata: jsonb("source_metadata").$type<SignalSourceMetadata>(),

  // Status tracking (SGNL-08)
  status: text("status").$type<SignalStatus>().notNull().default("new"),

  // AI processing fields (populated in Phase 15-16)
  embedding: text("embedding"),                   // Vector embedding (base64)
  aiClassification: jsonb("ai_classification").$type<SignalClassification>(),

  // Provenance (for Phase 18)
  inboxItemId: text("inbox_item_id").references(() => inboxItems.id, { onDelete: "set null" }),

  // Timestamps
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  processedAt: timestamp("processed_at"),         // When AI extraction completed
});
```

Key design decisions:
- `verbatim` is NOT NULL - every signal must have original content
- `source` is NOT NULL - every signal must have attribution
- `status` defaults to "new" - standard lifecycle entry point
- `inboxItemId` uses SET NULL on delete - preserve signals even if inbox item deleted
- AI fields are nullable - populated asynchronously in Phase 15-16
  </action>
  <verify>
Run `cd orchestrator && npx tsc --noEmit` - should compile without errors.
Check table has all required columns: verbatim, interpretation, severity, frequency, source, sourceRef, sourceMetadata, status.
  </verify>
  <done>
signals table exists in schema.ts with all required fields, proper types, and correct foreign key references.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add junction tables (signal_projects, signal_personas)</name>
  <files>orchestrator/src/lib/db/schema.ts</files>
  <action>
Add junction tables immediately after the signals table definition:

```typescript
// ============================================
// SIGNAL ASSOCIATIONS (Junction Tables)
// ============================================

export const signalProjects = pgTable("signal_projects", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  signalId: text("signal_id").notNull().references(() => signals.id, { onDelete: "cascade" }),
  projectId: text("project_id").notNull().references(() => projects.id, { onDelete: "cascade" }),
  linkedAt: timestamp("linked_at").defaultNow().notNull(),
  linkedBy: text("linked_by").references(() => users.id, { onDelete: "set null" }),
  linkReason: text("link_reason"),    // Why this signal relates to this project
  confidence: real("confidence"),      // AI confidence score (0-1) if auto-linked
}, (table) => ({
  uniqueSignalProject: unique().on(table.signalId, table.projectId),
}));

export const signalPersonas = pgTable("signal_personas", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  signalId: text("signal_id").notNull().references(() => signals.id, { onDelete: "cascade" }),
  personaId: text("persona_id").notNull(),  // References persona archetype name (not FK)
  linkedAt: timestamp("linked_at").defaultNow().notNull(),
  linkedBy: text("linked_by").references(() => users.id, { onDelete: "set null" }),
}, (table) => ({
  uniqueSignalPersona: unique().on(table.signalId, table.personaId),
}));
```

Key design decisions:
- Both tables have unique constraints to prevent duplicate associations
- `linkedBy` tracks who created the association (user or null for AI)
- `personaId` is text, not FK - personas are strings in ProjectMetadata.personas[], not a table
- `confidence` on signalProjects supports AI-suggested associations in Phase 17
  </action>
  <verify>
Run `cd orchestrator && npx tsc --noEmit` - should compile without errors.
Verify unique constraints on (signalId, projectId) and (signalId, personaId).
  </verify>
  <done>
signal_projects and signal_personas junction tables exist with unique constraints and proper foreign key references.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add Drizzle relations for signals</name>
  <files>orchestrator/src/lib/db/schema.ts</files>
  <action>
Add relations definitions after the junction tables. Place them in the RELATIONS section alongside other relations (after ~line 841):

```typescript
// ============================================
// SIGNAL RELATIONS
// ============================================

export const signalsRelations = relations(signals, ({ one, many }) => ({
  workspace: one(workspaces, {
    fields: [signals.workspaceId],
    references: [workspaces.id],
  }),
  inboxItem: one(inboxItems, {
    fields: [signals.inboxItemId],
    references: [inboxItems.id],
  }),
  projects: many(signalProjects),
  personas: many(signalPersonas),
}));

export const signalProjectsRelations = relations(signalProjects, ({ one }) => ({
  signal: one(signals, {
    fields: [signalProjects.signalId],
    references: [signals.id],
  }),
  project: one(projects, {
    fields: [signalProjects.projectId],
    references: [projects.id],
  }),
  linkedByUser: one(users, {
    fields: [signalProjects.linkedBy],
    references: [users.id],
  }),
}));

export const signalPersonasRelations = relations(signalPersonas, ({ one }) => ({
  signal: one(signals, {
    fields: [signalPersonas.signalId],
    references: [signals.id],
  }),
  linkedByUser: one(users, {
    fields: [signalPersonas.linkedBy],
    references: [users.id],
  }),
}));
```

Also update workspacesRelations to include signals:

In the existing `workspacesRelations` function (around line 770), add:
```typescript
signals: many(signals),
```

And update projectsRelations to include signal associations:

In the existing `projectsRelations` function (around line 843), add:
```typescript
signalProjects: many(signalProjects),
```
  </action>
  <verify>
Run `cd orchestrator && npx tsc --noEmit` - should compile without errors.
Verify `db.query.signals.findFirst({ with: { workspace: true, projects: true } })` would type-check (relations properly defined).
  </verify>
  <done>
All signal-related relations defined. Signals can be queried with workspace, projects, and personas relations.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add type exports to index.ts</name>
  <files>orchestrator/src/lib/db/index.ts</files>
  <action>
Add type exports at the end of index.ts (after existing type exports, around line 91):

```typescript
// Signal types (Phase 11+)
export type Signal = typeof schema.signals.$inferSelect;
export type NewSignal = typeof schema.signals.$inferInsert;

export type SignalProject = typeof schema.signalProjects.$inferSelect;
export type NewSignalProject = typeof schema.signalProjects.$inferInsert;

export type SignalPersona = typeof schema.signalPersonas.$inferSelect;
export type NewSignalPersona = typeof schema.signalPersonas.$inferInsert;
```

These types enable:
- `Signal` - Full signal object from database queries
- `NewSignal` - Insert type for creating signals (required fields enforced)
- Junction table types for associations
  </action>
  <verify>
Run `cd orchestrator && npx tsc --noEmit` - should compile without errors.
Verify types are importable: `import { Signal, NewSignal } from "@/lib/db"` would work.
  </verify>
  <done>
Signal, NewSignal, SignalProject, NewSignalProject, SignalPersona, NewSignalPersona types exported from index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 6: Generate and apply database migration</name>
  <files>drizzle/*.sql</files>
  <action>
Generate the migration file:

```bash
cd orchestrator && npm run db:generate
```

This will create a new SQL migration file in the `drizzle/` directory.

Review the generated migration to verify it includes:
- CREATE TABLE signals with all columns
- CREATE TABLE signal_projects with unique constraint
- CREATE TABLE signal_personas with unique constraint
- Foreign key constraints

Then apply the migration:

```bash
cd orchestrator && npm run db:push
```

Note: Using `db:push` for development. For production, use `db:migrate`.
  </action>
  <verify>
1. Migration file exists in drizzle/ folder
2. `npm run db:push` completes without errors
3. Run `npm run db:studio` and verify tables exist (optional manual check)
  </verify>
  <done>
Migration generated and applied. signals, signal_projects, and signal_personas tables exist in database.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compilation:** `cd orchestrator && npx tsc --noEmit` passes with no errors
2. **Migration applied:** `npm run db:push` succeeds
3. **Schema exports:** All types and tables are exported from schema.ts
4. **Type exports:** Signal types are exported from index.ts

Quick validation query (run in test file or REPL if needed):
```typescript
import { db, signals, Signal, NewSignal } from "@/lib/db";
import { eq } from "drizzle-orm";

// Type check - this should compile
const testInsert: NewSignal = {
  workspaceId: "test",
  verbatim: "User said something",
  source: "interview",
};

// Query with relations should type-check
const result = await db.query.signals.findFirst({
  with: { workspace: true, projects: true }
});
```
</verification>

<success_criteria>
- [ ] signals table exists with verbatim, interpretation, severity, frequency, source, sourceRef, sourceMetadata, status fields
- [ ] signals table has workspace_id foreign key with cascade delete
- [ ] signal_projects junction table exists with unique(signal_id, project_id) constraint
- [ ] signal_personas junction table exists with unique(signal_id, persona_id) constraint
- [ ] TypeScript types (SignalStatus, SignalSource, SignalSeverity, SignalFrequency) exported
- [ ] TypeScript interfaces (SignalSourceMetadata, SignalClassification) exported
- [ ] Drizzle relations defined for signals, signalProjects, signalPersonas
- [ ] Type exports (Signal, NewSignal, etc.) in index.ts
- [ ] Database migration generated and applied successfully
- [ ] `npm run build` in orchestrator passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-signal-schema/11-01-SUMMARY.md`
</output>
