---
phase: 18-provenance-prd-citation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/app/api/projects/from-cluster/route.ts
  - orchestrator/src/components/signals/CreateProjectFromClusterModal.tsx
  - orchestrator/src/lib/db/queries.ts
  - orchestrator/src/app/api/projects/route.ts
  - orchestrator/src/lib/store.ts
  - orchestrator/src/components/kanban/ProjectCard.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can create new project from a cluster of signals"
    - "All cluster signals are automatically linked to new project"
    - "Project cards show signal count badge"
    - "Signal count updates after link/unlink operations"
    - "Modal shows signal previews before project creation"
  artifacts:
    - path: "orchestrator/src/app/api/projects/from-cluster/route.ts"
      provides: "POST endpoint for creating project from cluster"
      exports: ["POST"]
    - path: "orchestrator/src/components/signals/CreateProjectFromClusterModal.tsx"
      provides: "Modal for cluster-to-project creation"
      exports: ["CreateProjectFromClusterModal"]
    - path: "orchestrator/src/components/kanban/ProjectCard.tsx"
      provides: "Project card with signal count badge"
      contains: "MessageSquare"
  key_links:
    - from: "CreateProjectFromClusterModal"
      to: "/api/projects/from-cluster"
      via: "POST fetch in useMutation"
      pattern: "from-cluster"
    - from: "ProjectCard"
      to: "store.signalCount"
      via: "project prop"
      pattern: "signalCount"
---

<objective>
Enable creating projects from signal clusters and display signal count on project cards.

Purpose: Users can act on discovered patterns by creating projects, and see signal evidence at a glance
Output: Project creation from clusters with automatic signal linking, signal count badges on cards
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-provenance-prd-citation/18-RESEARCH.md
@orchestrator/src/lib/classification/clustering.ts
@orchestrator/src/app/api/signals/synthesize/route.ts
@orchestrator/src/components/kanban/ProjectCard.tsx
@orchestrator/src/lib/store.ts
@orchestrator/src/lib/db/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project-from-cluster API endpoint</name>
  <files>orchestrator/src/app/api/projects/from-cluster/route.ts</files>
  <action>
Create new API endpoint POST /api/projects/from-cluster:

```typescript
/**
 * POST /api/projects/from-cluster
 *
 * Create a new project from a cluster of signals and bulk-link all signals.
 * Used when /synthesize suggests "new_project" action for a cluster.
 *
 * Request body:
 * - workspaceId: string (required)
 * - name: string (required)
 * - description?: string (optional)
 * - signalIds: string[] (required - signals to link)
 * - clusterTheme?: string (optional - for link reason)
 *
 * Response:
 * - success: boolean
 * - projectId: string
 * - linkedSignals: number
 */

import { NextRequest, NextResponse } from "next/server";
import { nanoid } from "nanoid";
import { db } from "@/lib/db";
import { projects, signalProjects, signals } from "@/lib/db/schema";
import { eq, inArray } from "drizzle-orm";
import {
  requireWorkspaceAccess,
  handlePermissionError,
  PermissionError,
} from "@/lib/permissions";
import { logProjectCreated } from "@/lib/activity";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { workspaceId, name, description, signalIds, clusterTheme } = body;

    // Validate required fields
    if (!workspaceId) {
      return NextResponse.json(
        { error: "workspaceId is required" },
        { status: 400 }
      );
    }

    if (!name || typeof name !== "string" || !name.trim()) {
      return NextResponse.json(
        { error: "name is required" },
        { status: 400 }
      );
    }

    if (!signalIds || !Array.isArray(signalIds) || signalIds.length === 0) {
      return NextResponse.json(
        { error: "signalIds array is required" },
        { status: 400 }
      );
    }

    // Require member access
    const membership = await requireWorkspaceAccess(workspaceId, "member");
    const userId = membership.userId;

    const projectId = `proj_${nanoid()}`;
    const now = new Date();

    // Create project
    await db.insert(projects).values({
      id: projectId,
      workspaceId,
      name: name.trim(),
      description: description?.trim() || null,
      stage: "inbox",
      status: "active",
      createdAt: now,
      updatedAt: now,
    });

    // Bulk link signals to project
    const linkReason = clusterTheme
      ? `Created from signal cluster: ${clusterTheme}`
      : "Created from signal cluster";

    await db.insert(signalProjects).values(
      signalIds.map((signalId: string) => ({
        id: nanoid(),
        signalId,
        projectId,
        linkedBy: userId,
        linkReason,
        confidence: null, // User-initiated, not AI
        linkedAt: now,
      }))
    );

    // Update signal statuses to "linked"
    await db
      .update(signals)
      .set({ status: "linked", updatedAt: now })
      .where(inArray(signals.id, signalIds));

    // Log activity
    await logProjectCreated(workspaceId, userId, projectId, name);

    return NextResponse.json({
      success: true,
      projectId,
      linkedSignals: signalIds.length,
    });
  } catch (error) {
    if (error instanceof PermissionError) {
      const { error: message, status } = handlePermissionError(error);
      return NextResponse.json({ error: message }, { status });
    }

    console.error("Failed to create project from cluster:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to create project" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
1. TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
2. API endpoint accessible (dev server)
  </verify>
  <done>POST /api/projects/from-cluster creates project and bulk-links signals</done>
</task>

<task type="auto">
  <name>Task 2: Add signal count to project queries</name>
  <files>orchestrator/src/lib/db/queries.ts, orchestrator/src/lib/store.ts</files>
  <action>
Update getProjects to include signal count:

1. First, verify the `sql` import exists at top of queries.ts. Look for:
   ```typescript
   import { sql } from "drizzle-orm";
   ```
   If not present, add it to the existing drizzle-orm import line (may already have eq, inArray, etc).

2. In queries.ts, add signalProjects import if not present:
   ```typescript
   import { signalProjects } from "@/lib/db/schema";
   ```

3. Add a new helper function after getProjects:
   ```typescript
   export async function getProjectsWithCounts(workspaceId: string, options: { includeArchived?: boolean } = {}) {
     const projectList = await getProjects(workspaceId, options);

     // Get signal counts for all projects in one query
     const signalCounts = await db
       .select({
         projectId: signalProjects.projectId,
         count: sql<number>`count(*)::int`,
       })
       .from(signalProjects)
       .where(
         inArray(
           signalProjects.projectId,
           projectList.map((p) => p.id)
         )
       )
       .groupBy(signalProjects.projectId);

     // Create lookup map
     const countMap = new Map(signalCounts.map((c) => [c.projectId, c.count]));

     // Merge counts into projects
     return projectList.map((project) => ({
       ...project,
       signalCount: countMap.get(project.id) || 0,
       documentCount: project.documents?.length || 0,
       prototypeCount: project.prototypes?.length || 0,
     }));
   }
   ```

4. In store.ts, add signalCount to ProjectCard interface:
   ```typescript
   export interface ProjectCard {
     // ... existing fields ...
     documentCount?: number;
     prototypeCount?: number;
     signalCount?: number;  // ADD THIS
     // ... rest of fields ...
   }
   ```
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>
- sql import verified/added from drizzle-orm
- getProjectsWithCounts returns projects with signal counts
- ProjectCard interface includes signalCount field
  </done>
</task>

<task type="auto">
  <name>Task 3: Update projects API to include signal counts</name>
  <files>orchestrator/src/app/api/projects/route.ts</files>
  <action>
Update GET /api/projects to use getProjectsWithCounts:

1. Update import:
   ```typescript
   import { getProjectsWithCounts, createProject, getWorkspace, createJob } from "@/lib/db/queries";
   ```

2. Update GET handler:
   ```typescript
   const projects = await getProjectsWithCounts(workspaceId, { includeArchived });
   ```

This ensures kanban cards receive signal counts.
  </action>
  <verify>API returns projects with signalCount field</verify>
  <done>GET /api/projects returns signalCount for each project</done>
</task>

<task type="auto">
  <name>Task 4: Add signal count badge to ProjectCard</name>
  <files>orchestrator/src/components/kanban/ProjectCard.tsx</files>
  <action>
Add signal count badge to ProjectCard footer:

1. Add MessageSquare import:
   ```typescript
   import {
     FileText,
     Layers,
     MessageSquare,  // ADD THIS
     MoreHorizontal,
     // ... rest
   } from "lucide-react";
   ```

2. In the footer div where documentCount and prototypeCount badges appear, add signal count:
   ```typescript
   {/* Signal count badge */}
   {project.signalCount !== undefined && project.signalCount > 0 && (
     <span className="flex items-center gap-1" title="Linked signals">
       <MessageSquare className="w-3 h-3" />
       {project.signalCount}
     </span>
   )}
   ```

Place it AFTER the prototypeCount badge for visual consistency.

3. No need to update ProjectCard interface - already updated in store.ts
  </action>
  <verify>
1. Dev server shows signal count badges on project cards
2. Lint passes: `cd orchestrator && npm run lint`
  </verify>
  <done>ProjectCard shows signal count badge with MessageSquare icon</done>
</task>

<task type="auto">
  <name>Task 5: Create CreateProjectFromClusterModal component</name>
  <files>orchestrator/src/components/signals/CreateProjectFromClusterModal.tsx</files>
  <action>
Create the modal component that allows users to create a project from a signal cluster.

Reference: 18-RESEARCH.md lines 326-431 provides implementation example.

```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { ScrollArea } from "@/components/ui/scroll-area";

// SignalCluster type matches what clustering.ts returns
interface ClusterSignal {
  id: string;
  verbatim: string;
  source?: string;
  severity?: string;
}

interface SignalCluster {
  id: string;
  theme: string;
  signals: ClusterSignal[];
  signalCount: number;
}

interface CreateProjectFromClusterModalProps {
  isOpen: boolean;
  onClose: () => void;
  cluster: SignalCluster;
  workspaceId: string;
}

export function CreateProjectFromClusterModal({
  isOpen,
  onClose,
  cluster,
  workspaceId,
}: CreateProjectFromClusterModalProps) {
  const [name, setName] = useState(cluster.theme);
  const [description, setDescription] = useState("");
  const queryClient = useQueryClient();
  const router = useRouter();

  const createMutation = useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/projects/from-cluster", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          workspaceId,
          signalIds: cluster.signals.map((s) => s.id),
          name,
          description,
          clusterTheme: cluster.theme,
        }),
      });
      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.error || "Failed to create project");
      }
      return res.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["projects"] });
      queryClient.invalidateQueries({ queryKey: ["signals"] });
      onClose();
      router.push(`/projects/${data.projectId}`);
    },
  });

  // Reset form when modal opens with new cluster
  const handleOpenChange = (open: boolean) => {
    if (!open) {
      onClose();
    } else {
      setName(cluster.theme);
      setDescription("");
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Create Project from Cluster</DialogTitle>
          <DialogDescription>
            Create a new project and link {cluster.signalCount} signals as evidence.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label htmlFor="project-name">Project Name</Label>
            <Input
              id="project-name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Enter project name"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="project-description">Description (optional)</Label>
            <Textarea
              id="project-description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Describe the initiative..."
              rows={3}
            />
          </div>

          {/* Preview of signals being linked */}
          <div className="space-y-2">
            <Label className="text-muted-foreground">
              Signals to link ({cluster.signalCount})
            </Label>
            <ScrollArea className="h-[150px] border rounded-lg p-2">
              {cluster.signals.slice(0, 5).map((signal, i) => (
                <div key={signal.id} className="text-xs text-muted-foreground py-1 border-b last:border-b-0">
                  <span className="font-medium">{i + 1}.</span>{" "}
                  &ldquo;{signal.verbatim.length > 80 ? `${signal.verbatim.slice(0, 80)}...` : signal.verbatim}&rdquo;
                  {signal.source && (
                    <span className="ml-2 text-muted-foreground/60">({signal.source})</span>
                  )}
                </div>
              ))}
              {cluster.signalCount > 5 && (
                <div className="text-xs text-muted-foreground italic pt-2">
                  ...and {cluster.signalCount - 5} more signals
                </div>
              )}
            </ScrollArea>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={createMutation.isPending}>
            Cancel
          </Button>
          <Button
            onClick={() => createMutation.mutate()}
            disabled={!name.trim() || createMutation.isPending}
          >
            {createMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
            Create Project
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

Key behaviors:
- Accepts cluster with id, theme, signals array, and signalCount
- Pre-fills project name with cluster theme
- Shows preview of first 5 signals with verbatim and source
- Calls POST /api/projects/from-cluster with signalIds array
- Invalidates projects and signals queries on success
- Navigates to new project page on success
- Handles loading state with disabled button and spinner
  </action>
  <verify>
1. TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
2. Component exports correctly: grep for "export function CreateProjectFromClusterModal"
3. Modal can be imported in other components
  </verify>
  <done>
- CreateProjectFromClusterModal component created
- Modal displays signal previews (verbatim, source)
- Calls POST /api/projects/from-cluster on submit
- Navigates to new project on success
- Invalidates relevant queries
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
2. Lint passes: `cd orchestrator && npm run lint`
3. Project cards display signal count badges
4. Test POST /api/projects/from-cluster creates project with linked signals
5. Signal statuses update to "linked" after bulk linking
6. CreateProjectFromClusterModal renders correctly and calls API
</verification>

<success_criteria>
- POST /api/projects/from-cluster works correctly
- Projects query returns signal counts
- Project cards show signal count badges
- CreateProjectFromClusterModal component exists and functions
- All signals are linked when project created from cluster
- Signal statuses update to "linked"
- No TypeScript or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-provenance-prd-citation/18-03-SUMMARY.md`
</output>
