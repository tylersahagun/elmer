---
phase: 17-smart-association
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/lib/db/schema.ts
  - orchestrator/src/lib/db/queries.ts
  - orchestrator/src/app/api/signals/suggestions/route.ts
  - orchestrator/src/app/api/signals/[id]/suggestions/dismiss/route.ts
autonomous: true

must_haves:
  truths:
    - "System can query unlinked signals with classification suggestions"
    - "User can dismiss a suggestion for a specific signal"
    - "Dismissed suggestions do not reappear in suggestions list"
  artifacts:
    - path: "orchestrator/src/lib/db/schema.ts"
      provides: "suggestionDismissedAt and suggestionDismissedBy columns on signals table"
      contains: "suggestionDismissedAt"
    - path: "orchestrator/src/app/api/signals/suggestions/route.ts"
      provides: "GET endpoint for AI suggestions"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/[id]/suggestions/dismiss/route.ts"
      provides: "POST endpoint to dismiss suggestion"
      exports: ["POST"]
  key_links:
    - from: "suggestions/route.ts"
      to: "signals.classification"
      via: "JSONB query on classification->>'projectId'"
      pattern: "classification.*projectId"
    - from: "dismiss/route.ts"
      to: "signals table"
      via: "update suggestionDismissedAt"
      pattern: "suggestionDismissedAt"
---

<objective>
Add schema support for suggestion dismissal and create API endpoints to fetch AI suggestions and dismiss them.

Purpose: Enable the system to surface classification-based project suggestions for unlinked signals and let users dismiss unwanted suggestions.

Output: Database columns for dismiss tracking, suggestions query endpoint, and dismiss mutation endpoint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-smart-association/17-RESEARCH.md

# Key prior work
@.planning/phases/16-classification-and-clustering/16-02-SUMMARY.md
@.planning/phases/12.5-manual-association/12.5-01-SUMMARY.md

# Source files
@orchestrator/src/lib/db/schema.ts
@orchestrator/src/lib/db/queries.ts
@orchestrator/src/app/api/signals/[id]/projects/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Suggestion Dismiss Columns to Schema</name>
  <files>orchestrator/src/lib/db/schema.ts</files>
  <action>
Add two new columns to the `signals` table definition:

```typescript
// In signals table definition, after processedAt:
suggestionDismissedAt: timestamp("suggestion_dismissed_at"),
suggestionDismissedBy: text("suggestion_dismissed_by").references(() => users.id, { onDelete: "set null" }),
```

These columns track when a user dismisses the AI suggestion for a signal, preventing it from reappearing in the suggestions list.

No migration file needed - Drizzle Kit will generate it on next `drizzle-kit generate`.
  </action>
  <verify>
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
- Schema is valid: `cd orchestrator && npx drizzle-kit check`
  </verify>
  <done>
- signals table has suggestionDismissedAt (timestamp) column
- signals table has suggestionDismissedBy (text, FK to users) column
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Suggestions API Endpoint</name>
  <files>
    orchestrator/src/lib/db/queries.ts
    orchestrator/src/app/api/signals/suggestions/route.ts
  </files>
  <action>
**First, add query function to queries.ts:**

```typescript
/**
 * Get unlinked signals with classification suggestions
 * Returns signals that:
 * - Have classification.projectId set (AI suggested a project)
 * - Are NOT already linked to that suggested project
 * - Have not been dismissed (suggestionDismissedAt is null)
 * - Were created in the last 30 days
 * - classification.isNewInitiative is not true
 */
export async function getSignalSuggestions(
  workspaceId: string,
  limit: number = 20
): Promise<Array<{
  signalId: string;
  verbatim: string;
  source: string;
  projectId: string;
  projectName: string;
  confidence: number;
  reason?: string;
  createdAt: Date;
}>> {
  // Use raw SQL for JSONB query performance
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

  const result = await db.execute(sql`
    SELECT
      s.id as signal_id,
      s.verbatim,
      s.source,
      s.classification->>'projectId' as project_id,
      s.classification->>'projectName' as project_name,
      (s.classification->>'confidence')::float as confidence,
      s.classification->>'reason' as reason,
      s.created_at
    FROM signals s
    LEFT JOIN signal_projects sp ON s.id = sp.signal_id
      AND sp.project_id = s.classification->>'projectId'
    WHERE s.workspace_id = ${workspaceId}
      AND s.classification->>'projectId' IS NOT NULL
      AND COALESCE(s.classification->>'isNewInitiative', 'false') != 'true'
      AND sp.id IS NULL
      AND s.suggestion_dismissed_at IS NULL
      AND s.created_at > ${thirtyDaysAgo.toISOString()}
    ORDER BY (s.classification->>'confidence')::float DESC
    LIMIT ${limit}
  `);

  return result.rows.map((row: any) => ({
    signalId: row.signal_id,
    verbatim: row.verbatim,
    source: row.source,
    projectId: row.project_id,
    projectName: row.project_name,
    confidence: row.confidence,
    reason: row.reason || undefined,
    createdAt: new Date(row.created_at),
  }));
}
```

**Then create the API route:**

Create `orchestrator/src/app/api/signals/suggestions/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getSignalSuggestions } from "@/lib/db/queries";
import {
  requireWorkspaceAccess,
  handlePermissionError,
  PermissionError,
} from "@/lib/permissions";

/**
 * GET /api/signals/suggestions?workspaceId=xxx
 * Get AI suggestions for unlinked signals
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const workspaceId = searchParams.get("workspaceId");
    const limit = parseInt(searchParams.get("limit") || "20", 10);

    if (!workspaceId) {
      return NextResponse.json(
        { error: "workspaceId required" },
        { status: 400 }
      );
    }

    // Verify workspace access (viewer can read suggestions)
    await requireWorkspaceAccess(workspaceId, "viewer");

    const suggestions = await getSignalSuggestions(workspaceId, Math.min(limit, 50));

    return NextResponse.json({ suggestions });
  } catch (error) {
    if (error instanceof PermissionError) {
      const { error: message, status } = handlePermissionError(error);
      return NextResponse.json({ error: message }, { status });
    }
    console.error("Failed to get signal suggestions:", error);
    return NextResponse.json(
      { error: "Failed to get signal suggestions" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
- Dev server starts without error: `cd orchestrator && npm run dev` (background, check for startup)
- API returns empty array for workspace with no suggestions: `curl "http://localhost:3000/api/signals/suggestions?workspaceId=YOUR_WORKSPACE_ID"` (requires auth cookie)
  </verify>
  <done>
- getSignalSuggestions query function exists in queries.ts
- GET /api/signals/suggestions endpoint returns suggestions array
- Suggestions exclude dismissed signals and already-linked signals
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Dismiss Suggestion Endpoint</name>
  <files>
    orchestrator/src/lib/db/queries.ts
    orchestrator/src/app/api/signals/[id]/suggestions/dismiss/route.ts
  </files>
  <action>
**Add dismiss query function to queries.ts:**

```typescript
/**
 * Dismiss suggestion for a signal
 * Sets suggestionDismissedAt and suggestionDismissedBy
 */
export async function dismissSignalSuggestion(
  signalId: string,
  userId: string
): Promise<void> {
  await db
    .update(signals)
    .set({
      suggestionDismissedAt: new Date(),
      suggestionDismissedBy: userId,
      updatedAt: new Date(),
    })
    .where(eq(signals.id, signalId));
}
```

**Create the dismiss API route:**

Create directory and file `orchestrator/src/app/api/signals/[id]/suggestions/dismiss/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getSignal, dismissSignalSuggestion } from "@/lib/db/queries";
import {
  requireWorkspaceAccess,
  handlePermissionError,
  PermissionError,
} from "@/lib/permissions";

type RouteContext = { params: Promise<{ id: string }> };

/**
 * POST /api/signals/[id]/suggestions/dismiss
 * Dismiss the AI suggestion for this signal
 */
export async function POST(request: NextRequest, context: RouteContext) {
  try {
    const { id: signalId } = await context.params;

    // Get signal to verify it exists and get workspaceId
    const signal = await getSignal(signalId);
    if (!signal) {
      return NextResponse.json({ error: "Signal not found" }, { status: 404 });
    }

    // Verify membership (member can dismiss suggestions)
    const membership = await requireWorkspaceAccess(signal.workspaceId, "member");

    // Dismiss the suggestion
    await dismissSignalSuggestion(signalId, membership.userId);

    return NextResponse.json({ success: true });
  } catch (error) {
    if (error instanceof PermissionError) {
      const { error: message, status } = handlePermissionError(error);
      return NextResponse.json({ error: message }, { status });
    }
    console.error("Failed to dismiss suggestion:", error);
    return NextResponse.json(
      { error: "Failed to dismiss suggestion" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
- Directory structure correct: `ls -la orchestrator/src/app/api/signals/[id]/suggestions/dismiss/`
  </verify>
  <done>
- dismissSignalSuggestion query function exists in queries.ts
- POST /api/signals/[id]/suggestions/dismiss endpoint works
- Dismissing sets suggestionDismissedAt and suggestionDismissedBy
  </done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors
- [ ] Schema includes suggestionDismissedAt and suggestionDismissedBy columns
- [ ] GET /api/signals/suggestions returns suggestions array
- [ ] POST /api/signals/[id]/suggestions/dismiss marks signal as dismissed
- [ ] Dismissed signals do not appear in suggestions query
</verification>

<success_criteria>
- Schema supports suggestion dismiss tracking (two new columns)
- Suggestions API returns unlinked signals with classification suggestions
- Dismiss API updates signal to prevent suggestion from reappearing
- All endpoints follow existing permission patterns (viewer for GET, member for POST)
</success_criteria>

<output>
After completion, create `.planning/phases/17-smart-association/17-01-SUMMARY.md`
</output>
