---
phase: 17-smart-association
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/lib/db/queries.ts
  - orchestrator/src/app/api/signals/bulk/route.ts
autonomous: true

must_haves:
  truths:
    - "User can link multiple signals to a project in one request"
    - "User can unlink multiple signals from a project in one request"
    - "Bulk operations skip already-linked or already-unlinked signals"
    - "Signal status updates correctly after bulk link/unlink"
  artifacts:
    - path: "orchestrator/src/app/api/signals/bulk/route.ts"
      provides: "POST endpoint for bulk link/unlink operations"
      exports: ["POST"]
    - path: "orchestrator/src/lib/db/queries.ts"
      provides: "bulkLinkSignalsToProject and bulkUnlinkSignalsFromProject functions"
      contains: "bulkLinkSignalsToProject"
  key_links:
    - from: "bulk/route.ts"
      to: "signalProjects table"
      via: "batch insert/delete"
      pattern: "signalProjects"
    - from: "bulk/route.ts"
      to: "signals.status"
      via: "status update after bulk operation"
      pattern: "status.*linked"
---

<objective>
Create a bulk operations API endpoint for linking and unlinking multiple signals at once.

Purpose: Enable efficient bulk association operations that respect existing links and maintain status invariants.

Output: POST /api/signals/bulk endpoint supporting atomic bulk link/unlink operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-smart-association/17-RESEARCH.md

# Key prior work
@.planning/phases/12.5-manual-association/12.5-01-SUMMARY.md

# Source files
@orchestrator/src/lib/db/schema.ts
@orchestrator/src/lib/db/queries.ts
@orchestrator/src/app/api/signals/[id]/projects/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Bulk Query Functions</name>
  <files>orchestrator/src/lib/db/queries.ts</files>
  <action>
Add bulk link/unlink query functions to queries.ts:

```typescript
/**
 * Bulk link signals to a project
 * Skips signals already linked to the project
 * Updates signal status to "linked" for newly linked signals
 * Returns count of newly linked signals
 */
export async function bulkLinkSignalsToProject(
  signalIds: string[],
  projectId: string,
  userId: string,
  linkReason?: string
): Promise<{ linked: number; skipped: number }> {
  if (signalIds.length === 0) {
    return { linked: 0, skipped: 0 };
  }

  // Find which signals are already linked to this project
  const existingLinks = await db.query.signalProjects.findMany({
    where: and(
      inArray(signalProjects.signalId, signalIds),
      eq(signalProjects.projectId, projectId)
    ),
    columns: { signalId: true },
  });
  const alreadyLinked = new Set(existingLinks.map((l) => l.signalId));

  // Filter to signals that need linking
  const toLink = signalIds.filter((id) => !alreadyLinked.has(id));

  if (toLink.length === 0) {
    return { linked: 0, skipped: signalIds.length };
  }

  // Batch insert new links
  await db.insert(signalProjects).values(
    toLink.map((signalId) => ({
      signalId,
      projectId,
      linkedBy: userId,
      linkReason: linkReason || "Bulk linked",
    }))
  );

  // Update status to "linked" for signals that weren't already linked
  await db
    .update(signals)
    .set({ status: "linked", updatedAt: new Date() })
    .where(
      and(
        inArray(signals.id, toLink),
        ne(signals.status, "linked")
      )
    );

  return { linked: toLink.length, skipped: alreadyLinked.size };
}

/**
 * Bulk unlink signals from a project
 * Returns count of unlinked signals
 * Updates signal status to "reviewed" if no remaining project links
 */
export async function bulkUnlinkSignalsFromProject(
  signalIds: string[],
  projectId: string
): Promise<{ unlinked: number; skipped: number }> {
  if (signalIds.length === 0) {
    return { unlinked: 0, skipped: 0 };
  }

  // Find which signals are actually linked to this project
  const existingLinks = await db.query.signalProjects.findMany({
    where: and(
      inArray(signalProjects.signalId, signalIds),
      eq(signalProjects.projectId, projectId)
    ),
    columns: { signalId: true },
  });
  const linkedSignalIds = existingLinks.map((l) => l.signalId);

  if (linkedSignalIds.length === 0) {
    return { unlinked: 0, skipped: signalIds.length };
  }

  // Delete the links
  await db
    .delete(signalProjects)
    .where(
      and(
        inArray(signalProjects.signalId, linkedSignalIds),
        eq(signalProjects.projectId, projectId)
      )
    );

  // For each unlinked signal, check if it has any remaining project links
  // If not, revert status to "reviewed"
  for (const signalId of linkedSignalIds) {
    const remainingLinks = await db.query.signalProjects.findMany({
      where: eq(signalProjects.signalId, signalId),
      columns: { id: true },
      limit: 1,
    });

    if (remainingLinks.length === 0) {
      // No more project links, revert to reviewed
      await db
        .update(signals)
        .set({ status: "reviewed", updatedAt: new Date() })
        .where(
          and(
            eq(signals.id, signalId),
            eq(signals.status, "linked")
          )
        );
    }
  }

  return {
    unlinked: linkedSignalIds.length,
    skipped: signalIds.length - linkedSignalIds.length,
  };
}
```

Also add necessary imports at the top of queries.ts if not already present:
```typescript
import { inArray, ne } from "drizzle-orm";
```
  </action>
  <verify>
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
- Functions are exported (check in file)
  </verify>
  <done>
- bulkLinkSignalsToProject function exists and handles duplicates
- bulkUnlinkSignalsFromProject function exists and updates status correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Bulk Operations API Endpoint</name>
  <files>orchestrator/src/app/api/signals/bulk/route.ts</files>
  <action>
Create `orchestrator/src/app/api/signals/bulk/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
import {
  getSignal,
  bulkLinkSignalsToProject,
  bulkUnlinkSignalsFromProject,
} from "@/lib/db/queries";
import {
  requireWorkspaceAccess,
  handlePermissionError,
  PermissionError,
} from "@/lib/permissions";

const MAX_BULK_SIZE = 50;

interface BulkLinkRequest {
  action: "link";
  signalIds: string[];
  projectId: string;
  linkReason?: string;
}

interface BulkUnlinkRequest {
  action: "unlink";
  signalIds: string[];
  projectId: string;
}

type BulkRequest = BulkLinkRequest | BulkUnlinkRequest;

/**
 * POST /api/signals/bulk
 * Bulk link or unlink signals
 *
 * Body for link: { action: "link", signalIds: string[], projectId: string, linkReason?: string }
 * Body for unlink: { action: "unlink", signalIds: string[], projectId: string }
 */
export async function POST(request: NextRequest) {
  try {
    const body: BulkRequest = await request.json();
    const { action, signalIds, projectId } = body;

    // Validate request
    if (!action || !["link", "unlink"].includes(action)) {
      return NextResponse.json(
        { error: "action must be 'link' or 'unlink'" },
        { status: 400 }
      );
    }

    if (!Array.isArray(signalIds) || signalIds.length === 0) {
      return NextResponse.json(
        { error: "signalIds must be a non-empty array" },
        { status: 400 }
      );
    }

    if (signalIds.length > MAX_BULK_SIZE) {
      return NextResponse.json(
        { error: `Maximum ${MAX_BULK_SIZE} signals per bulk operation` },
        { status: 400 }
      );
    }

    if (!projectId) {
      return NextResponse.json(
        { error: "projectId required" },
        { status: 400 }
      );
    }

    // Get first signal to determine workspace (all signals must be in same workspace)
    const firstSignal = await getSignal(signalIds[0]);
    if (!firstSignal) {
      return NextResponse.json(
        { error: "Signal not found" },
        { status: 404 }
      );
    }

    // Verify membership (member can perform bulk operations)
    const membership = await requireWorkspaceAccess(firstSignal.workspaceId, "member");

    // Perform the bulk operation
    if (action === "link") {
      const linkReason = (body as BulkLinkRequest).linkReason;
      const result = await bulkLinkSignalsToProject(
        signalIds,
        projectId,
        membership.userId,
        linkReason
      );

      return NextResponse.json({
        success: true,
        action: "link",
        linked: result.linked,
        skipped: result.skipped,
        message: `Linked ${result.linked} signal${result.linked !== 1 ? "s" : ""}${
          result.skipped > 0 ? `, skipped ${result.skipped} already linked` : ""
        }`,
      });
    } else {
      const result = await bulkUnlinkSignalsFromProject(signalIds, projectId);

      return NextResponse.json({
        success: true,
        action: "unlink",
        unlinked: result.unlinked,
        skipped: result.skipped,
        message: `Unlinked ${result.unlinked} signal${result.unlinked !== 1 ? "s" : ""}${
          result.skipped > 0 ? `, skipped ${result.skipped} not linked` : ""
        }`,
      });
    }
  } catch (error) {
    if (error instanceof PermissionError) {
      const { error: message, status } = handlePermissionError(error);
      return NextResponse.json({ error: message }, { status });
    }
    console.error("Bulk operation failed:", error);
    return NextResponse.json(
      { error: "Bulk operation failed" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
- TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
- File exists: `ls orchestrator/src/app/api/signals/bulk/route.ts`
  </verify>
  <done>
- POST /api/signals/bulk endpoint exists
- Supports action: "link" and action: "unlink"
- Enforces 50 signal limit per operation
- Returns linked/unlinked and skipped counts
  </done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors
- [ ] bulkLinkSignalsToProject function exists in queries.ts
- [ ] bulkUnlinkSignalsFromProject function exists in queries.ts
- [ ] POST /api/signals/bulk endpoint exists
- [ ] Bulk link skips already-linked signals
- [ ] Bulk unlink updates status to "reviewed" when no links remain
</verification>

<success_criteria>
- Bulk link operation links multiple signals atomically, skipping duplicates
- Bulk unlink operation removes multiple links atomically
- Signal status transitions correctly (linked/reviewed) after bulk operations
- Maximum 50 signals per operation enforced
- Response includes counts of linked/unlinked and skipped signals
</success_criteria>

<output>
After completion, create `.planning/phases/17-smart-association/17-02-SUMMARY.md`
</output>
