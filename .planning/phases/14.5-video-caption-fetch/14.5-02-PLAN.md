---
phase: 14.5-video-caption-fetch
plan: 02
type: execute
wave: 2
depends_on: ["14.5-01"]
files_modified:
  - orchestrator/src/app/api/signals/video/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/signals/video accepts videoUrl and workspaceId"
    - "YouTube captions are fetched and stored as signal verbatim"
    - "Loom URLs return helpful 'coming soon' message"
    - "Invalid URLs return 400 with descriptive error"
    - "Signal created with source='video' and video metadata"
  artifacts:
    - path: "orchestrator/src/app/api/signals/video/route.ts"
      provides: "Video caption fetch API endpoint"
      exports: ["POST"]
  key_links:
    - from: "orchestrator/src/app/api/signals/video/route.ts"
      to: "orchestrator/src/lib/video"
      via: "parseVideoUrl and extractYouTubeCaptions imports"
      pattern: "import.*from.*lib/video"
    - from: "orchestrator/src/app/api/signals/video/route.ts"
      to: "orchestrator/src/lib/db/queries"
      via: "createSignal import"
      pattern: "import.*createSignal.*queries"
    - from: "orchestrator/src/app/api/signals/video/route.ts"
      to: "orchestrator/src/lib/permissions"
      via: "requireWorkspaceAccess import"
      pattern: "import.*requireWorkspaceAccess.*permissions"
---

<objective>
Create /api/signals/video endpoint for fetching YouTube captions and creating signals.

Purpose: Enable users to submit video URLs and have captions automatically fetched and stored as signals. Follows the same patterns established in /api/signals/upload from Phase 14.

Output: POST /api/signals/video endpoint that validates URLs, fetches captions, creates signals with video source attribution.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14.5-video-caption-fetch/14.5-RESEARCH.md
@orchestrator/src/app/api/signals/upload/route.ts
@orchestrator/src/lib/db/schema.ts (SignalSourceMetadata interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /api/signals/video route</name>
  <files>orchestrator/src/app/api/signals/video/route.ts</files>
  <action>
Create POST endpoint following Phase 14 upload route pattern:

1. Imports:
   - NextRequest, NextResponse from "next/server"
   - after from "next/server" (for async activity logging)
   - nanoid from "nanoid"
   - requireWorkspaceAccess, handlePermissionError, PermissionError from "@/lib/permissions"
   - parseVideoUrl, extractYouTubeCaptions from "@/lib/video"
   - createSignal from "@/lib/db/queries"
   - db from "@/lib/db"
   - activityLogs from "@/lib/db/schema"

2. POST handler:
   - Parse JSON body: { videoUrl, workspaceId, interpretation?, language? }
   - Validate required fields (videoUrl, workspaceId) - return 400 if missing
   - Call parseVideoUrl(videoUrl) to validate and extract videoId
   - If !isValid, return 400 with parsed.error
   - Call requireWorkspaceAccess(workspaceId, "member")

3. Platform-specific handling:
   - If platform === "youtube": call extractYouTubeCaptions(videoId, language || "en")
   - If platform === "loom": return 400 with message "Loom video support coming soon. Please use YouTube videos for now."
   - Wrap extraction in try/catch - return 400 with error message on failure

4. Create signal:
   - sourceRef format: `video-${platform}-${Date.now()}-${nanoid(6)}`
   - source: "video"
   - verbatim: extraction.text (transcript with timestamps)
   - sourceMetadata: {
       videoUrl: extraction.metadata.videoUrl,
       videoPlatform: extraction.metadata.platform,
       sourceName: extraction.metadata.videoTitle || `${platform} video`,
       rawPayload: { videoId, language, segmentCount, charCount }
     }

5. Activity logging (after() pattern from Phase 13):
   - Log signal.created with source="video", platform, videoUrl

6. Response (201):
   - { success: true, signal: { id, verbatim (truncated to 200 chars), source, status }, extraction: { platform, videoTitle, segmentCount, charCount } }

7. Error handling:
   - PermissionError: use handlePermissionError
   - Generic errors: 500 with message
  </action>
  <verify>
    - `ls orchestrator/src/app/api/signals/video/` shows route.ts
    - `cd orchestrator && npx tsc --noEmit` passes
    - Test with curl (requires running dev server):
      ```bash
      curl -X POST http://localhost:3000/api/signals/video \
        -H "Content-Type: application/json" \
        -d '{"videoUrl": "invalid", "workspaceId": "test"}'
      ```
      Should return 400 with "URL not recognized" error
  </verify>
  <done>
    - /api/signals/video/route.ts exists with POST handler
    - Validates videoUrl and workspaceId
    - Extracts YouTube captions via lib/video
    - Creates signal with source="video" and video metadata
    - Returns helpful error for Loom URLs
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
- [ ] `cat orchestrator/src/app/api/signals/video/route.ts` shows POST handler
- [ ] Route imports from lib/video and lib/db/queries
- [ ] Route uses after() for activity logging (Phase 13 pattern)
- [ ] `npx tsc --noEmit` passes in orchestrator/
</verification>

<success_criteria>
- POST /api/signals/video endpoint accepts JSON body with videoUrl, workspaceId
- YouTube URLs trigger caption fetch and signal creation
- Loom URLs return 400 with "coming soon" message
- Invalid URLs return 400 with descriptive error
- Signal created with source="video" and proper sourceMetadata (videoUrl, videoPlatform)
</success_criteria>

<output>
After completion, create `.planning/phases/14.5-video-caption-fetch/14.5-02-SUMMARY.md`
</output>
