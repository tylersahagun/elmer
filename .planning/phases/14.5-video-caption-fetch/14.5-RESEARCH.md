# Phase 14.5: Video Caption Fetch - Research

**Researched:** 2026-01-23
**Domain:** Video platform API integration, caption/transcript extraction, YouTube Data API, Loom integration
**Confidence:** MEDIUM (YouTube HIGH, Loom LOW)

## Summary

Phase 14.5 extends signal ingestion to support video links (YouTube, Loom) by fetching existing captions/transcripts from platform APIs. This is NOT transcription - we retrieve pre-existing captions that video platforms have already generated.

Key findings:

1. **YouTube: Reliable with npm library** - The `youtube-caption-extractor` package provides serverless-compatible caption extraction with timestamps. No API key required for public videos. Works in Vercel serverless environments.

2. **Loom: Challenging - No Official API** - Loom does not provide a public API for transcript access. Available options require either: (a) third-party scraping services (Apify), or (b) browser automation (Puppeteer). Both approaches are fragile and add complexity.

3. **Architecture Pattern** - Follow Phase 14's pattern: Create `lib/video/` module with extractors, new API endpoint `/api/signals/video`, extend CreateSignalModal with "Video Link" tab.

**Primary recommendation:** Implement YouTube caption fetch in Phase 14.5 using `youtube-caption-extractor`. Defer Loom support pending official API availability or accept third-party service dependency.

## Standard Stack

### New Dependencies Required
| Library | Version | Purpose | Why This Library |
|---------|---------|---------|------------------|
| youtube-caption-extractor | ^1.9.x | YouTube caption extraction | Serverless-compatible, TypeScript support, no API key needed, dual extraction with automatic fallback |

### Loom Options (Requires Decision)
| Option | Type | Reliability | Complexity | Cost |
|--------|------|-------------|------------|------|
| Defer Loom | None | N/A | None | None |
| Apify Loom Transcript Scraper | Third-party API | Medium | Low | Pay-per-use |
| Custom Puppeteer scraping | Browser automation | Low | High | Infrastructure |

### Existing (No Changes Needed)
| Library | Version | Purpose |
|---------|---------|---------|
| @tanstack/react-query | ^5.90.18 | Mutations for video fetch |
| next | 16.1.3 | API routes, after() for async processing |
| @radix-ui/react-tabs | ^1.1.13 | Already in CreateSignalModal from Phase 14 |
| nanoid | existing | Source reference generation |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| youtube-caption-extractor | youtube-transcript | youtube-transcript is 2+ years old, less maintained |
| youtube-caption-extractor | YouTube Data API v3 | Requires API key, OAuth for caption downloads |
| youtube-caption-extractor | youtube-transcript-plus | More complex, similar functionality |

**Installation:**
```bash
npm install youtube-caption-extractor
```

## Architecture Patterns

### Recommended Project Structure
```
orchestrator/src/
├── app/api/
│   └── signals/
│       └── video/
│           └── route.ts           # Video link processing + signal creation
├── components/signals/
│   ├── CreateSignalModal.tsx      # MODIFY: Add "Video Link" tab
│   └── VideoLinkTab.tsx           # NEW: Video URL input component
└── lib/
    └── video/
        ├── index.ts               # Barrel exports
        ├── extractCaptions.ts     # Platform-specific caption extraction
        ├── formatters.ts          # Timestamp formatting utilities
        └── validators.ts          # URL validation and video ID extraction
```

### Pattern 1: Caption Extraction Result Interface
**What:** Standardized result interface matching Phase 14's ExtractionResult pattern
**When to use:** Return type for all caption extraction functions
**Example:**
```typescript
// lib/video/extractCaptions.ts
export interface CaptionSegment {
  start: number;      // Start time in seconds
  duration: number;   // Duration in seconds
  text: string;       // Caption text
}

export interface CaptionExtractionResult {
  text: string;       // Full transcript as single string (for signal verbatim)
  segments: CaptionSegment[];  // Individual segments with timestamps
  metadata: {
    platform: "youtube" | "loom";
    videoId: string;
    videoUrl: string;
    videoTitle?: string;
    language: string;
    segmentCount: number;
    charCount: number;
  };
}
```

### Pattern 2: YouTube Caption Extraction
**What:** Fetch YouTube captions using youtube-caption-extractor
**When to use:** When user provides YouTube URL
**Example:**
```typescript
// lib/video/extractCaptions.ts
import { getVideoDetails, Subtitle } from "youtube-caption-extractor";

export async function extractYouTubeCaptions(
  videoId: string,
  lang: string = "en"
): Promise<CaptionExtractionResult> {
  const details = await getVideoDetails({ videoID: videoId, lang });

  if (!details.subtitles || details.subtitles.length === 0) {
    throw new Error("No captions available for this video");
  }

  // Convert Subtitle[] to CaptionSegment[]
  const segments: CaptionSegment[] = details.subtitles.map((sub: Subtitle) => ({
    start: parseFloat(sub.start),
    duration: parseFloat(sub.dur),
    text: sub.text,
  }));

  // Build full transcript with timestamps
  const text = segments
    .map(seg => `[${formatTimestamp(seg.start)}] ${seg.text}`)
    .join("\n");

  return {
    text,
    segments,
    metadata: {
      platform: "youtube",
      videoId,
      videoUrl: `https://www.youtube.com/watch?v=${videoId}`,
      videoTitle: details.title,
      language: lang,
      segmentCount: segments.length,
      charCount: text.length,
    },
  };
}
```

### Pattern 3: Video URL Validation and ID Extraction
**What:** Validate URLs and extract video IDs for supported platforms
**When to use:** Before attempting caption fetch
**Example:**
```typescript
// lib/video/validators.ts
export type VideoPlatform = "youtube" | "loom" | "unknown";

export interface VideoUrlParseResult {
  platform: VideoPlatform;
  videoId: string | null;
  isValid: boolean;
  error?: string;
}

// YouTube URL patterns: watch?v=, youtu.be/, embed/, shorts/
const YOUTUBE_REGEX = /(?:youtube(?:-nocookie)?\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?|shorts)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;

// Loom URL pattern: loom.com/share/[32-char-hex-id]
const LOOM_REGEX = /loom\.com\/share\/([a-f0-9]{32})/;

export function parseVideoUrl(url: string): VideoUrlParseResult {
  // Try YouTube first
  const youtubeMatch = url.match(YOUTUBE_REGEX);
  if (youtubeMatch && youtubeMatch[1]) {
    return {
      platform: "youtube",
      videoId: youtubeMatch[1],
      isValid: true,
    };
  }

  // Try Loom
  const loomMatch = url.match(LOOM_REGEX);
  if (loomMatch && loomMatch[1]) {
    return {
      platform: "loom",
      videoId: loomMatch[1],
      isValid: true,
    };
  }

  return {
    platform: "unknown",
    videoId: null,
    isValid: false,
    error: "URL not recognized as YouTube or Loom video",
  };
}
```

### Pattern 4: Timestamp Formatting
**What:** Convert seconds to human-readable timestamps
**When to use:** Building transcript text with timestamps for signal verbatim
**Example:**
```typescript
// lib/video/formatters.ts

/**
 * Convert seconds to HH:MM:SS or MM:SS format
 * For videos under 1 hour, omit hours portion
 */
export function formatTimestamp(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hrs > 0) {
    return `${hrs}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

/**
 * Build full transcript text from segments with timestamps
 * Each line: "[0:15] Caption text here"
 */
export function buildTranscriptWithTimestamps(segments: CaptionSegment[]): string {
  return segments
    .map(seg => `[${formatTimestamp(seg.start)}] ${seg.text}`)
    .join("\n");
}

/**
 * Build plain transcript without timestamps
 * Use when user prefers clean text
 */
export function buildPlainTranscript(segments: CaptionSegment[]): string {
  return segments.map(seg => seg.text).join(" ");
}
```

### Pattern 5: Video API Route
**What:** API endpoint for video caption fetch and signal creation
**When to use:** POST /api/signals/video
**Example:**
```typescript
// app/api/signals/video/route.ts
import { NextRequest, NextResponse } from "next/server";
import { after } from "next/server";
import { nanoid } from "nanoid";
import { requireWorkspaceAccess, handlePermissionError, PermissionError } from "@/lib/permissions";
import { parseVideoUrl, extractYouTubeCaptions } from "@/lib/video";
import { createSignal } from "@/lib/db/queries";
import { db } from "@/lib/db";
import { activityLogs } from "@/lib/db/schema";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { videoUrl, workspaceId, interpretation, language = "en" } = body;

    // Validate required fields
    if (!videoUrl || !workspaceId) {
      return NextResponse.json(
        { error: "videoUrl and workspaceId are required" },
        { status: 400 }
      );
    }

    // Parse and validate video URL
    const parsed = parseVideoUrl(videoUrl);
    if (!parsed.isValid || !parsed.videoId) {
      return NextResponse.json(
        { error: parsed.error || "Invalid video URL" },
        { status: 400 }
      );
    }

    // Permission check
    await requireWorkspaceAccess(workspaceId, "member");

    // Fetch captions based on platform
    let extraction;
    try {
      if (parsed.platform === "youtube") {
        extraction = await extractYouTubeCaptions(parsed.videoId, language);
      } else if (parsed.platform === "loom") {
        // Loom support deferred - return clear error
        return NextResponse.json(
          { error: "Loom video support coming soon. Please use YouTube videos for now." },
          { status: 400 }
        );
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : "Failed to fetch captions";
      return NextResponse.json({ error: message }, { status: 400 });
    }

    if (!extraction?.text) {
      return NextResponse.json(
        { error: "No captions found for this video" },
        { status: 400 }
      );
    }

    // Create signal with extracted transcript
    const sourceRef = `video-${parsed.platform}-${Date.now()}-${nanoid(6)}`;
    const signal = await createSignal({
      workspaceId,
      verbatim: extraction.text,
      interpretation: interpretation?.trim() || undefined,
      source: "video",
      sourceRef,
      sourceMetadata: {
        videoUrl: extraction.metadata.videoUrl,
        videoPlatform: extraction.metadata.platform,
        sourceName: extraction.metadata.videoTitle || `${parsed.platform} video`,
        rawPayload: {
          videoId: extraction.metadata.videoId,
          language: extraction.metadata.language,
          segmentCount: extraction.metadata.segmentCount,
          charCount: extraction.metadata.charCount,
        },
      },
    });

    // Log activity asynchronously
    after(async () => {
      try {
        await db.insert(activityLogs).values({
          id: nanoid(),
          workspaceId,
          action: "signal.created",
          targetType: "signal",
          targetId: signal!.id,
          metadata: {
            source: "video",
            platform: extraction.metadata.platform,
            videoUrl: extraction.metadata.videoUrl,
          },
          createdAt: new Date(),
        });
      } catch (logError) {
        console.error("Failed to log video activity:", logError);
      }
    });

    return NextResponse.json(
      {
        success: true,
        signal: {
          id: signal!.id,
          verbatim: signal!.verbatim.length > 200
            ? signal!.verbatim.slice(0, 200) + "..."
            : signal!.verbatim,
          source: signal!.source,
          status: signal!.status,
        },
        extraction: {
          platform: extraction.metadata.platform,
          videoTitle: extraction.metadata.videoTitle,
          segmentCount: extraction.metadata.segmentCount,
          charCount: extraction.metadata.charCount,
        },
      },
      { status: 201 }
    );
  } catch (error) {
    if (error instanceof PermissionError) {
      const { error: message, status } = handlePermissionError(error);
      return NextResponse.json({ error: message }, { status });
    }
    console.error("Video caption fetch failed:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to process video" },
      { status: 500 }
    );
  }
}
```

### Anti-Patterns to Avoid
- **Don't use YouTube Data API for basic caption fetch:** Requires API key and OAuth for downloads. The `youtube-caption-extractor` library doesn't need this.
- **Don't assume all videos have captions:** Many videos have no captions, or only auto-generated ones in certain languages.
- **Don't store video files:** We only need the text transcript, not the video itself.
- **Don't use Puppeteer for YouTube:** It's unnecessary complexity when a simple library exists.
- **Don't scrape Loom without considering reliability:** Scraping approaches break when Loom updates their UI.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| YouTube caption extraction | Custom fetch to YouTube | youtube-caption-extractor | Handles format conversion, fallback methods, edge cases |
| YouTube URL parsing | Simple regex | Comprehensive regex with validation | Many URL formats exist (watch, youtu.be, embed, shorts) |
| Timestamp formatting | Date object manipulation | Simple math function | More readable, handles edge cases |
| Video ID validation | Length check only | Platform-specific regex | YouTube IDs are 11 chars, Loom IDs are 32 hex chars |

**Key insight:** Video platform APIs change frequently. Use well-maintained libraries that track these changes.

## Common Pitfalls

### Pitfall 1: Video Has No Captions
**What goes wrong:** User provides video link, but video has no captions available
**Why it happens:** Not all YouTube videos have captions; some creators disable them
**How to avoid:** Catch the specific error and return user-friendly message: "No captions available for this video"
**Warning signs:** Empty subtitle array from youtube-caption-extractor

### Pitfall 2: Auto-Generated Captions Quality
**What goes wrong:** Auto-generated captions have poor accuracy (typos, wrong words)
**Why it happens:** YouTube's auto-transcription isn't perfect, especially for technical terms
**How to avoid:** Inform user that caption quality depends on the original video's transcription
**Warning signs:** Unusual spellings, missing punctuation, run-on text

### Pitfall 3: Language Not Available
**What goes wrong:** User requests English captions, but video only has Spanish captions
**Why it happens:** Captions are language-specific
**How to avoid:** Catch `YoutubeTranscriptNotAvailableLanguageError` and suggest trying without language filter
**Warning signs:** Error about language availability

### Pitfall 4: Rate Limiting on Cloud Deployments
**What goes wrong:** Caption fetch works locally but fails on Vercel with "TranscriptsDisabled" error
**Why it happens:** YouTube may rate-limit or block requests from cloud IP ranges
**How to avoid:** Add retry logic with exponential backoff, consider caching successful fetches
**Warning signs:** Works locally, fails in production with inconsistent errors

### Pitfall 5: Loom URL But No Loom Support
**What goes wrong:** User provides Loom link expecting it to work
**Why it happens:** Loom doesn't have public API for transcript access
**How to avoid:** Detect Loom URLs and return clear message: "Loom support coming soon"
**Warning signs:** Loom regex matches but no handler exists

### Pitfall 6: Long Videos Create Massive Signals
**What goes wrong:** 3-hour video transcript creates 100KB+ signal verbatim
**Why it happens:** No length limit on transcript extraction
**How to avoid:** Consider truncating very long transcripts with "... [truncated, see full video]" or warn user
**Warning signs:** Signals with verbatim > 50KB

## Code Examples

### Complete VideoLinkTab Component
```typescript
// components/signals/VideoLinkTab.tsx
"use client";

import { useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Loader2, Link, Video } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { DialogFooter } from "@/components/ui/dialog";

interface VideoLinkTabProps {
  workspaceId: string;
  onSuccess: () => void;
  onClose: () => void;
}

export function VideoLinkTab({ workspaceId, onSuccess, onClose }: VideoLinkTabProps) {
  const queryClient = useQueryClient();
  const [videoUrl, setVideoUrl] = useState("");
  const [interpretation, setInterpretation] = useState("");
  const [error, setError] = useState<string | null>(null);

  const fetchMutation = useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/signals/video", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          videoUrl: videoUrl.trim(),
          workspaceId,
          interpretation: interpretation.trim() || undefined,
        }),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to fetch video captions");
      }

      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["signals", workspaceId] });
      setVideoUrl("");
      setInterpretation("");
      setError(null);
      onSuccess();
      onClose();
    },
    onError: (err: Error) => {
      setError(err.message);
    },
  });

  const handleSubmit = () => {
    setError(null);
    fetchMutation.mutate();
  };

  // Basic URL validation (more thorough validation happens server-side)
  const isValidUrl = videoUrl.includes("youtube") || videoUrl.includes("youtu.be") || videoUrl.includes("loom.com");

  return (
    <div className="space-y-4 py-4">
      <div className="space-y-2">
        <Label htmlFor="video-url">Video URL</Label>
        <div className="relative">
          <Link className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
          <Input
            id="video-url"
            placeholder="https://www.youtube.com/watch?v=..."
            value={videoUrl}
            onChange={(e) => {
              setVideoUrl(e.target.value);
              setError(null);
            }}
            className="pl-10"
            disabled={fetchMutation.isPending}
          />
        </div>
        <p className="text-xs text-muted-foreground">
          Paste a YouTube video link. We'll fetch the existing captions.
        </p>
        {error && <p className="text-sm text-red-500">{error}</p>}
      </div>

      <div className="space-y-2">
        <Label htmlFor="video-interpretation">Interpretation (optional)</Label>
        <Textarea
          id="video-interpretation"
          placeholder="What does this video feedback tell us?"
          value={interpretation}
          onChange={(e) => setInterpretation(e.target.value)}
          rows={2}
          disabled={fetchMutation.isPending}
          className="resize-none"
        />
      </div>

      <DialogFooter>
        <Button variant="outline" onClick={onClose} disabled={fetchMutation.isPending}>
          Cancel
        </Button>
        <Button
          onClick={handleSubmit}
          disabled={!videoUrl.trim() || !isValidUrl || fetchMutation.isPending}
        >
          {fetchMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
          <Video className="w-4 h-4 mr-2" />
          Fetch Captions
        </Button>
      </DialogFooter>
    </div>
  );
}
```

### Extending CreateSignalModal with Video Tab
```typescript
// In CreateSignalModal.tsx - Add VideoLinkTab
import { VideoLinkTab } from "./VideoLinkTab";

// Inside the Tabs component, add new tab:
<TabsList className="grid w-full grid-cols-3">
  <TabsTrigger value="paste">Paste Text</TabsTrigger>
  <TabsTrigger value="upload">Upload File</TabsTrigger>
  <TabsTrigger value="video">Video Link</TabsTrigger>
</TabsList>

<TabsContent value="video">
  <VideoLinkTab
    workspaceId={workspaceId}
    onSuccess={onSuccess}
    onClose={onClose}
  />
</TabsContent>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| YouTube Data API v3 | youtube-caption-extractor | 2024+ | No API key needed, simpler |
| Custom YouTube scraping | Library with fallbacks | 2025+ | More reliable, maintained |
| Loom scraping | Third-party APIs (Apify) | 2025 | Loom still has no public API |
| Store full video | Extract text only | Domain-specific | Signals are text-based |

**Deprecated/outdated:**
- `youtube-transcript` npm package - Not updated in 2+ years, consider alternatives
- Direct Loom DOM scraping - Breaks frequently with UI updates
- YouTube Data API for caption download - Overly complex for this use case

## Open Questions

Things that couldn't be fully resolved:

1. **Loom Support Strategy**
   - What we know: Loom has no public transcript API
   - What's unclear: Will they add one? Is third-party dependency acceptable?
   - Recommendation: **Defer Loom support to a future phase.** Implement YouTube now, revisit Loom when official API becomes available or business need is confirmed.

2. **Transcript Length Limits**
   - What we know: Long videos create very long transcripts
   - What's unclear: What's the practical limit for signal verbatim? Should we truncate?
   - Recommendation: **Warn on very long transcripts (>50KB) but allow.** Let user decide if they want the full transcript or should break it into multiple signals.

3. **Language Selection UI**
   - What we know: youtube-caption-extractor supports language parameter
   - What's unclear: Should we auto-detect available languages? Provide language dropdown?
   - Recommendation: **Default to English for v1.** Add language selection in future iteration if users request it.

4. **Rate Limiting Strategy**
   - What we know: YouTube may rate-limit cloud requests
   - What's unclear: How aggressive? What's the threshold?
   - Recommendation: **Implement basic retry logic.** Monitor for issues in production.

## Gap Analysis: Requirements Review

| Requirement | Research Finding | Recommendation |
|-------------|------------------|----------------|
| INGST-06: YouTube link fetch captions | youtube-caption-extractor provides this | Full implementation with library |
| INGST-06: Loom link fetch captions | No official API available | Defer or use third-party service |
| INGST-07: Timestamp extraction | Library returns start/duration for each segment | Format timestamps in verbatim |

**YouTube: All requirements can be met. Loom: Blocked by lack of official API.**

## Loom Decision Required

Before planning, a decision is needed on Loom support:

**Option A: Defer Loom (Recommended)**
- Implement YouTube only in Phase 14.5
- Add Loom when official API becomes available
- Pros: Simple, reliable, no third-party dependency
- Cons: Doesn't fulfill INGST-06 for Loom

**Option B: Third-Party Service (Apify)**
- Use Apify Loom Transcript Scraper API
- Pay-per-use cost model
- Pros: Works today, structured output
- Cons: External dependency, cost, may break if Loom changes

**Option C: Custom Scraping**
- Build Puppeteer-based scraper
- Pros: No external dependency
- Cons: High complexity, fragile, serverless challenges

**Recommendation:** Option A - Defer Loom support. The phase can deliver value with YouTube support alone. Loom can be added when a more reliable solution emerges.

## Roadmap Implications

Based on this research, the phase should be structured as:

1. **Plan 1: Video Caption Infrastructure**
   - Add youtube-caption-extractor dependency
   - Create lib/video/validators.ts (URL parsing)
   - Create lib/video/formatters.ts (timestamp formatting)
   - Create lib/video/extractCaptions.ts (YouTube extraction)

2. **Plan 2: Video API Endpoint**
   - Create /api/signals/video route
   - Handle YouTube URL processing
   - Create signal with source="video"
   - Use existing sourceMetadata.videoPlatform, videoUrl fields

3. **Plan 3: Video Link UI**
   - Create VideoLinkTab component
   - Extend CreateSignalModal with third tab
   - Wire to video API endpoint

**Phase ordering rationale:**
- Infrastructure first (validators, formatters, extractors) enables testing
- API second enables manual testing via curl before UI
- UI last, integrates with working backend

## Sources

### Primary (HIGH confidence)
- [youtube-caption-extractor GitHub](https://github.com/devhims/youtube-caption-extractor) - API documentation, type definitions
- [youtube-caption-extractor npm](https://www.npmjs.com/package/youtube-caption-extractor) - Package details, version 1.9.x
- Existing codebase: lib/files/extractText.ts, app/api/signals/upload/route.ts, db/schema.ts SignalSourceMetadata

### Secondary (MEDIUM confidence)
- [YouTube Data API v3 Captions](https://developers.google.com/youtube/v3/docs/captions) - Official API reference (not used but verified library doesn't need it)
- [Loom Developer Portal](https://dev.loom.com/) - Confirmed no public transcript API
- [Apify Loom Transcript Scraper](https://apify.com/neatrat/loom-transcript-scraper) - Third-party option for Loom

### Tertiary (LOW confidence)
- WebSearch results for Loom internal API endpoints - No official documentation found
- Community discussions on rate limiting - Anecdotal, needs production validation

## Metadata

**Confidence breakdown:**
- YouTube stack: HIGH - Library verified, serverless-compatible, well-documented
- YouTube patterns: HIGH - Based on existing Phase 14 codebase patterns
- Loom options: LOW - No official API, only third-party scrapers
- Rate limiting: LOW - Needs production validation

**Research date:** 2026-01-23
**Valid until:** 60 days (video platform APIs can change)
