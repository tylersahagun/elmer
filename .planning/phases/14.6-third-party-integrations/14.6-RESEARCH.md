# Phase 14.6: Third-Party Integrations - Research

**Researched:** 2026-01-23
**Domain:** Pylon webhook integration, Slack Events API integration, OAuth token storage
**Confidence:** MEDIUM (Pylon docs limited; Slack docs comprehensive)

## Summary

Phase 14.6 integrates two third-party platforms for signal ingestion: Pylon (support tickets) and Slack (channel messages). Research confirms that both platforms use webhook-style delivery with HMAC signature verification, aligning with the existing webhook infrastructure from Phase 13. However, the authentication models differ significantly:

1. **Pylon Integration**: Uses outbound webhooks configured in Pylon's admin panel. Pylon sends events to our endpoint when ticket events occur. Authentication uses HMAC-SHA256 signatures (similar to our existing webhook auth). This is a "push" model - Pylon pushes data to us.

2. **Slack Integration**: More complex. Requires creating a Slack App, completing OAuth 2.0 flow to install in customer workspaces, and handling the Events API. Slack sends events to our endpoint when messages are posted. Authentication uses HMAC-SHA256 with a signing secret. This requires storing OAuth tokens per workspace.

**Primary recommendation:** Create dedicated endpoints for each integration (`/api/webhooks/pylon`, `/api/webhooks/slack`) rather than overloading the generic `/api/webhooks/signals` endpoint. This allows platform-specific payload parsing, signature verification, and URL verification (Slack requirement). Store integration credentials in a new `integrations` table with encrypted tokens.

## Standard Stack

No new packages required. The existing stack handles everything needed.

### Core (Already in Use)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| next | 16.1.3 | API routes with `after()` for background processing | Built-in, queue-first pattern |
| crypto (Node.js built-in) | N/A | HMAC-SHA256 signature verification | Timing-safe comparison, no dependencies |
| drizzle-orm | 0.45.1 | Database operations, credential storage | Already established pattern |

### Supporting (No New Dependencies)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| next/server | (part of next) | `after()` function | Background processing after response |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom Slack integration | @slack/bolt | Bolt adds significant complexity for our simple webhook-receiving use case |
| Database token storage | Environment variables | Env vars don't support per-workspace credentials |
| Dedicated endpoints | Single generic endpoint | Dedicated endpoints allow platform-specific handling |

**Installation:**
No new packages needed.

## Architecture Patterns

### Recommended Project Structure
```
orchestrator/src/
├── app/api/webhooks/
│   ├── signals/route.ts           # Existing generic webhook
│   ├── pylon/route.ts             # NEW: Pylon-specific endpoint
│   └── slack/
│       ├── events/route.ts        # NEW: Slack Events API endpoint
│       └── oauth/route.ts         # NEW: Slack OAuth callback (future)
├── lib/
│   ├── webhooks/
│   │   ├── auth.ts                # Existing auth utilities
│   │   └── processor.ts           # Existing signal processor
│   └── integrations/
│       ├── index.ts               # NEW: Integration utilities export
│       ├── pylon.ts               # NEW: Pylon signature verification
│       ├── slack.ts               # NEW: Slack signature verification
│       └── types.ts               # NEW: Integration type definitions
└── lib/db/
    └── schema.ts                  # ADD: integrations table
```

### Pattern 1: Platform-Specific Webhook Endpoints
**What:** Dedicated endpoints per integration platform
**When to use:** When platforms have different payload formats, auth mechanisms, or requirements (like URL verification)
**Example:**
```typescript
// Source: Slack Events API documentation
// /api/webhooks/slack/events/route.ts

import { after } from "next/server";
import { NextRequest, NextResponse } from "next/server";
import { verifySlackSignature } from "@/lib/integrations/slack";
import { processSignalWebhook } from "@/lib/webhooks/processor";

export async function POST(request: NextRequest) {
  const receivedAt = new Date();
  const rawBody = await request.text();

  // 1. Verify Slack signature
  const timestamp = request.headers.get("x-slack-request-timestamp");
  const signature = request.headers.get("x-slack-signature");

  if (!verifySlackSignature(rawBody, timestamp, signature)) {
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  const payload = JSON.parse(rawBody);

  // 2. Handle URL verification challenge (Slack requirement)
  if (payload.type === "url_verification") {
    return NextResponse.json({ challenge: payload.challenge });
  }

  // 3. Handle event callbacks
  if (payload.type === "event_callback" && payload.event?.type === "message") {
    // Queue for async processing
    after(async () => {
      await processSlackMessage({
        teamId: payload.team_id,
        event: payload.event,
        receivedAt,
      });
    });
  }

  return NextResponse.json({ ok: true });
}
```

### Pattern 2: Slack Signature Verification
**What:** HMAC-SHA256 verification with v0: prefix and timestamp validation
**When to use:** All Slack webhook requests
**Example:**
```typescript
// Source: https://docs.slack.dev/authentication/verifying-requests-from-slack/
import crypto from "crypto";

export function verifySlackSignature(
  rawBody: string,
  timestamp: string | null,
  signature: string | null,
  signingSecret: string
): boolean {
  if (!timestamp || !signature) return false;

  // Reject requests older than 5 minutes (replay attack prevention)
  const fiveMinutesAgo = Math.floor(Date.now() / 1000) - 60 * 5;
  if (parseInt(timestamp, 10) < fiveMinutesAgo) return false;

  // Create base string: v0:{timestamp}:{body}
  const baseString = `v0:${timestamp}:${rawBody}`;

  // Compute expected signature
  const expectedSignature = "v0=" + crypto
    .createHmac("sha256", signingSecret)
    .update(baseString)
    .digest("hex");

  // Timing-safe comparison
  try {
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  } catch {
    return false;
  }
}
```

### Pattern 3: Pylon Signature Verification
**What:** HMAC-SHA256 with timestamp.payload format
**When to use:** All Pylon webhook requests
**Example:**
```typescript
// Source: https://getpylon.com/developers/guides/using-webhooks/
import crypto from "crypto";

export function verifyPylonSignature(
  rawBody: string,
  timestamp: string | null,
  signature: string | null,
  secret: string
): boolean {
  if (!timestamp || !signature) return false;

  // Pylon signature format: hs256={hash}
  const normalizedSignature = signature.startsWith("hs256=")
    ? signature.slice(6)
    : signature;

  // Create base string: {timestamp}.{body}
  const baseString = `${timestamp}.${rawBody}`;

  // Compute expected signature
  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(baseString)
    .digest("hex");

  // Timing-safe comparison
  try {
    return crypto.timingSafeEqual(
      Buffer.from(normalizedSignature, "hex"),
      Buffer.from(expectedSignature, "hex")
    );
  } catch {
    return false;
  }
}
```

### Pattern 4: Integration Credentials Table
**What:** Store third-party OAuth tokens and webhook secrets per workspace
**When to use:** Any integration requiring per-workspace credentials
**Example:**
```typescript
// Source: Existing webhookKeys pattern + OAuth best practices
export const integrations = pgTable("integrations", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),

  // Integration identification
  platform: text("platform").$type<"pylon" | "slack">().notNull(),
  name: text("name").notNull(),               // User-friendly name

  // Pylon: webhook secret from Pylon admin panel
  // Slack: signing secret from Slack app settings
  webhookSecret: text("webhook_secret"),

  // Slack OAuth tokens (null for Pylon)
  accessToken: text("access_token"),          // xoxb-* bot token
  refreshToken: text("refresh_token"),        // For token rotation
  tokenExpiresAt: timestamp("token_expires_at"),

  // Slack-specific
  slackTeamId: text("slack_team_id"),         // Slack workspace ID
  slackTeamName: text("slack_team_name"),
  slackBotUserId: text("slack_bot_user_id"),

  // Pylon-specific
  pylonAccountId: text("pylon_account_id"),

  // Configuration
  isActive: boolean("is_active").default(true),
  config: jsonb("config").$type<IntegrationConfig>(),

  // Metadata
  lastUsedAt: timestamp("last_used_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  createdBy: text("created_by").references(() => users.id, { onDelete: "set null" }),
});

interface IntegrationConfig {
  // Slack: which channels to listen to
  slackChannels?: Array<{ id: string; name: string }>;
  // Pylon: which ticket events to capture
  pylonEvents?: Array<"issue.created" | "issue.updated" | "issue.closed">;
}
```

### Anti-Patterns to Avoid
- **Single endpoint for all integrations:** Different platforms have different auth, payloads, and requirements (Slack URL verification)
- **Storing tokens in environment variables:** Doesn't scale to per-workspace installations
- **Ignoring timestamp validation:** Enables replay attacks
- **Using Slack verification token:** Deprecated; use signing secret with HMAC
- **Fetching integration config per request:** Cache credentials with appropriate TTL

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Slack signature verification | Custom string concat | Standard v0:{ts}:{body} format | Exact format required by Slack |
| Timestamp validation | Custom date math | Unix timestamp comparison | Standard 5-minute window |
| Token encryption | Custom encryption | Database-level encryption or secrets manager | Don't roll your own crypto |
| OAuth flow | Custom HTTP requests | Existing oauth.v2.access endpoint | Slack's documented flow |
| Webhook retries | Custom retry logic | Let platform handle retries | Platforms retry on non-200 |

**Key insight:** Both Pylon and Slack handle retries on their end. Our job is to return 200 quickly and process async. The existing `after()` pattern from Phase 13 is perfect.

## Common Pitfalls

### Pitfall 1: Slack URL Verification Failure
**What goes wrong:** Slack can't verify endpoint, Events API doesn't activate
**Why it happens:** Endpoint doesn't handle `url_verification` type or returns wrong format
**How to avoid:** Check for `type: "url_verification"` BEFORE signature validation (verification token deprecated)
**Warning signs:** "URL verification failed" in Slack app settings

### Pitfall 2: Signature Mismatch Due to Body Parsing
**What goes wrong:** All Pylon/Slack webhooks rejected with 401
**Why it happens:** Body was parsed/modified before signature verification
**How to avoid:** Use `request.text()` to get raw body, parse JSON AFTER verification
**Warning signs:** Signatures never match despite correct secret

### Pitfall 3: Slack Token Expiration
**What goes wrong:** Slack API calls fail after 12 hours
**Why it happens:** Token rotation enabled but refresh not implemented
**How to avoid:** Store refresh token, implement token refresh logic, handle refresh failures
**Warning signs:** "token_expired" or "invalid_auth" errors after working initially

### Pitfall 4: Missing Team ID Mapping
**What goes wrong:** Can't determine which workspace a Slack event belongs to
**Why it happens:** Multiple Slack workspaces could install the app
**How to avoid:** Store `team_id` during OAuth, look up integration by `team_id` in webhook
**Warning signs:** Events received but no matching workspace found

### Pitfall 5: Pylon Webhook Deactivation
**What goes wrong:** Webhooks stop arriving after 7 days
**Why it happens:** Pylon deactivates endpoints with no successful deliveries for 7 days
**How to avoid:** Always return 200, even if processing fails (use `after()`)
**Warning signs:** Sudden silence from Pylon, endpoint shows "inactive" in Pylon settings

### Pitfall 6: Processing Bot Messages
**What goes wrong:** Slack bot's own messages create signals, infinite loops possible
**Why it happens:** Bot receives events for all messages, including its own
**How to avoid:** Filter out messages where `user` equals `bot_user_id`
**Warning signs:** Duplicate signals, signals from "Elmer Bot"

## Code Examples

Verified patterns from official sources:

### Complete Slack Webhook Handler
```typescript
// Source: Slack Events API docs + Phase 13 patterns
import { after } from "next/server";
import { NextRequest, NextResponse } from "next/server";
import { verifySlackSignature } from "@/lib/integrations/slack";
import { db } from "@/lib/db";
import { integrations, signals } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";

export async function POST(request: NextRequest) {
  const receivedAt = new Date();
  const rawBody = await request.text();

  // Parse payload to check type (before full validation for url_verification)
  let payload: SlackEventPayload;
  try {
    payload = JSON.parse(rawBody);
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }

  // Handle URL verification (no signature check per Slack docs)
  if (payload.type === "url_verification") {
    return NextResponse.json({ challenge: payload.challenge });
  }

  // For all other requests, verify signature
  const timestamp = request.headers.get("x-slack-request-timestamp");
  const signature = request.headers.get("x-slack-signature");

  // Look up integration by team_id
  const integration = await db.query.integrations.findFirst({
    where: and(
      eq(integrations.platform, "slack"),
      eq(integrations.slackTeamId, payload.team_id),
      eq(integrations.isActive, true)
    ),
  });

  if (!integration?.webhookSecret) {
    return NextResponse.json({ error: "Unknown team" }, { status: 401 });
  }

  if (!verifySlackSignature(rawBody, timestamp, signature, integration.webhookSecret)) {
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  // Handle message events
  if (payload.type === "event_callback" && payload.event?.type === "message") {
    const event = payload.event;

    // Filter out bot messages (prevent self-processing)
    if (event.bot_id || event.user === integration.slackBotUserId) {
      return NextResponse.json({ ok: true, filtered: "bot_message" });
    }

    // Filter out message subtypes (edits, deletes, etc.)
    if (event.subtype) {
      return NextResponse.json({ ok: true, filtered: "subtype" });
    }

    // Queue async processing
    after(async () => {
      await createSignalFromSlack({
        workspaceId: integration.workspaceId,
        event,
        teamId: payload.team_id,
        receivedAt,
      });
    });
  }

  return NextResponse.json({ ok: true });
}

interface SlackEventPayload {
  type: "url_verification" | "event_callback";
  challenge?: string;
  team_id?: string;
  event?: {
    type: string;
    channel: string;
    user: string;
    text: string;
    ts: string;
    thread_ts?: string;
    bot_id?: string;
    subtype?: string;
  };
}
```

### Complete Pylon Webhook Handler
```typescript
// Source: Pylon webhook docs + Phase 13 patterns
import { after } from "next/server";
import { NextRequest, NextResponse } from "next/server";
import { verifyPylonSignature } from "@/lib/integrations/pylon";
import { db } from "@/lib/db";
import { integrations } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";

export async function POST(request: NextRequest) {
  const receivedAt = new Date();
  const rawBody = await request.text();

  // Get Pylon headers
  const timestamp = request.headers.get("pylon-webhook-timestamp");
  const signature = request.headers.get("pylon-webhook-signature");
  const version = request.headers.get("pylon-webhook-version");

  let payload: PylonWebhookPayload;
  try {
    payload = JSON.parse(rawBody);
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }

  // Look up integration (need identifier from payload or query param)
  // Pylon doesn't include workspace identifier in payload by default
  // Option 1: Include integration_id in webhook URL as query param
  // Option 2: Store Pylon account ID and match
  const integrationId = new URL(request.url).searchParams.get("integration_id");

  if (!integrationId) {
    return NextResponse.json({ error: "Missing integration_id" }, { status: 400 });
  }

  const integration = await db.query.integrations.findFirst({
    where: and(
      eq(integrations.id, integrationId),
      eq(integrations.platform, "pylon"),
      eq(integrations.isActive, true)
    ),
  });

  if (!integration?.webhookSecret) {
    return NextResponse.json({ error: "Unknown integration" }, { status: 401 });
  }

  if (!verifyPylonSignature(rawBody, timestamp, signature, integration.webhookSecret)) {
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  // Process ticket event
  after(async () => {
    await createSignalFromPylon({
      workspaceId: integration.workspaceId,
      payload: payload.data,
      receivedAt,
    });
  });

  return NextResponse.json({ success: true });
}

interface PylonWebhookPayload {
  data: {
    id: string;
    title?: string;
    body_html?: string;
    state?: string;
    priority?: string;
    requester?: {
      email: string;
      name?: string;
    };
    account?: {
      id: string;
      name?: string;
    };
    link?: string;
    created_at?: string;
  };
}
```

### Signal Creation from Slack
```typescript
// Source: Existing processSignalWebhook pattern
import { db } from "@/lib/db";
import { signals, activityLogs } from "@/lib/db/schema";
import { nanoid } from "nanoid";

interface SlackMessageInput {
  workspaceId: string;
  event: {
    channel: string;
    user: string;
    text: string;
    ts: string;
    thread_ts?: string;
  };
  teamId: string;
  receivedAt: Date;
}

export async function createSignalFromSlack(input: SlackMessageInput) {
  const { workspaceId, event, teamId, receivedAt } = input;

  // Generate unique sourceRef for idempotency
  const sourceRef = `slack-${teamId}-${event.channel}-${event.ts}`;

  try {
    // Check for existing (idempotency)
    const existing = await db.query.signals.findFirst({
      where: (signals, { and, eq }) =>
        and(
          eq(signals.workspaceId, workspaceId),
          eq(signals.source, "slack"),
          eq(signals.sourceRef, sourceRef)
        ),
    });

    if (existing) {
      return { created: false, duplicate: true };
    }

    const [signal] = await db.insert(signals).values({
      id: nanoid(),
      workspaceId,
      verbatim: event.text,
      source: "slack",
      sourceRef,
      sourceMetadata: {
        channelId: event.channel,
        messageTs: event.ts,
        threadTs: event.thread_ts,
        externalId: `${teamId}/${event.channel}/${event.ts}`,
        rawPayload: event,
      },
      status: "new",
      createdAt: new Date(),
      updatedAt: new Date(),
    }).returning();

    await db.insert(activityLogs).values({
      id: nanoid(),
      workspaceId,
      action: "signal.created",
      targetType: "signal",
      targetId: signal.id,
      metadata: {
        source: "slack",
        channelId: event.channel,
        verbatimPreview: event.text.slice(0, 100),
      },
      createdAt: new Date(),
    });

    return { created: true, signalId: signal.id };
  } catch (error) {
    console.error("Slack signal creation error:", error);
    return { created: false, error: String(error) };
  }
}
```

### Signal Creation from Pylon
```typescript
// Source: Existing processSignalWebhook pattern
import { db } from "@/lib/db";
import { signals, activityLogs } from "@/lib/db/schema";
import { nanoid } from "nanoid";

interface PylonTicketInput {
  workspaceId: string;
  payload: {
    id: string;
    title?: string;
    body_html?: string;
    state?: string;
    priority?: string;
    requester?: {
      email: string;
      name?: string;
    };
    link?: string;
  };
  receivedAt: Date;
}

export async function createSignalFromPylon(input: PylonTicketInput) {
  const { workspaceId, payload, receivedAt } = input;

  // Generate unique sourceRef
  const sourceRef = `pylon-${payload.id}`;

  // Convert HTML to plain text (simple approach)
  const verbatim = payload.body_html
    ? payload.body_html.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim()
    : payload.title || "No content";

  try {
    const existing = await db.query.signals.findFirst({
      where: (signals, { and, eq }) =>
        and(
          eq(signals.workspaceId, workspaceId),
          eq(signals.source, "pylon"),
          eq(signals.sourceRef, sourceRef)
        ),
    });

    if (existing) {
      return { created: false, duplicate: true };
    }

    const [signal] = await db.insert(signals).values({
      id: nanoid(),
      workspaceId,
      verbatim,
      source: "pylon",
      sourceRef,
      sourceMetadata: {
        ticketId: payload.id,
        ticketStatus: payload.state,
        customerEmail: payload.requester?.email,
        sourceName: payload.requester?.name,
        sourceUrl: payload.link,
        rawPayload: payload,
      },
      status: "new",
      createdAt: new Date(),
      updatedAt: new Date(),
    }).returning();

    await db.insert(activityLogs).values({
      id: nanoid(),
      workspaceId,
      action: "signal.created",
      targetType: "signal",
      targetId: signal.id,
      metadata: {
        source: "pylon",
        ticketId: payload.id,
        verbatimPreview: verbatim.slice(0, 100),
      },
      createdAt: new Date(),
    });

    return { created: true, signalId: signal.id };
  } catch (error) {
    console.error("Pylon signal creation error:", error);
    return { created: false, error: String(error) };
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Slack verification token | HMAC signing secret | 2019 | Always use signing secret |
| Long-lived Slack tokens | Token rotation (12hr expiry) | 2018 | Optional but recommended |
| Slack RTM API | Events API | 2016+ | Events API preferred for webhooks |
| Outgoing webhooks | Events API | Deprecated | Events API is the standard |

**Deprecated/outdated:**
- Slack verification token (use signing secret)
- Slack RTM API for receiving messages (use Events API)
- Slack legacy OAuth (use OAuth v2)
- Outgoing webhooks (use Events API)

## Open Questions

Things that couldn't be fully resolved:

1. **Pylon Event Types**
   - What we know: Webhooks are configured with event types in Pylon admin
   - What's unclear: Exact list of available event types and payload schemas (docs are limited)
   - Recommendation: **Start with generic ticket handler.** Accept any payload, extract what we can. Refine as we see real payloads.

2. **Slack OAuth Full Flow (Deferred)**
   - What we know: Slack requires OAuth 2.0 for multi-workspace distribution
   - What's unclear: Whether to implement full OAuth flow in Phase 14.6 or defer
   - Recommendation: **Defer OAuth UI to future phase.** For MVP, manually configure integration credentials. OAuth flow can be added when needed.

3. **Token Encryption at Rest**
   - What we know: Slack tokens should be encrypted
   - What's unclear: Whether to use database-level encryption, application-level, or secrets manager
   - Recommendation: **Use database column encryption or application-level AES-256.** Postgres pgcrypto or Node.js crypto module. Can upgrade to secrets manager later.

4. **Slack Channel Filtering**
   - What we know: We may not want signals from every channel
   - What's unclear: How to configure which channels to listen to
   - Recommendation: **Store allowed channels in integration config.** Filter in webhook handler. Can add UI later.

5. **Workspace-to-Integration Mapping for Pylon**
   - What we know: Pylon webhooks don't include a workspace identifier
   - What's unclear: How to map incoming Pylon webhooks to our workspaces
   - Recommendation: **Use query parameter in webhook URL.** When configuring webhook in Pylon, use URL like `/api/webhooks/pylon?integration_id=xxx`.

## Sources

### Primary (HIGH confidence)
- [Slack Events API Documentation](https://docs.slack.dev/apis/events-api/) - Event payload structure, retry behavior
- [Slack Request Verification](https://docs.slack.dev/authentication/verifying-requests-from-slack/) - HMAC signature verification
- [Slack Token Rotation](https://docs.slack.dev/authentication/using-token-rotation/) - OAuth token lifecycle
- [Slack URL Verification](https://api.slack.com/events/url_verification) - Challenge response requirement
- Existing Phase 13 implementation - Queue-first pattern, auth utilities

### Secondary (MEDIUM confidence)
- [Pylon Webhook Guide](https://getpylon.com/developers/guides/using-webhooks/) - Signature verification, headers
- [Pylon Issues API](https://docs.usepylon.com/pylon-docs/developer/api/api-reference/issues) - Ticket object structure
- [Slack Security Best Practices](https://docs.slack.dev/authentication/best-practices-for-security/) - Token storage recommendations

### Tertiary (LOW confidence)
- Pylon webhook payload structure - Based on generic examples, not complete schema
- Specific Pylon event types - Not fully documented

## Metadata

**Confidence breakdown:**
- Slack integration: HIGH - Comprehensive official documentation
- Pylon integration: MEDIUM - Signature verification documented, payload schema limited
- Credential storage: MEDIUM - Best practices known, specific implementation TBD
- Architecture patterns: HIGH - Builds on verified Phase 13 patterns

**Research date:** 2026-01-23
**Valid until:** 60 days (webhook APIs are stable)

---

## Gap Analysis: Requirements Review

| Requirement | Research Finding | Recommendation |
|-------------|------------------|----------------|
| INGST-08: Pylon integration | Use dedicated `/api/webhooks/pylon` endpoint with HMAC verification | Implement with integration_id query param for workspace mapping |
| INGST-09: Slack integration | Use `/api/webhooks/slack/events` with URL verification and signing secret | Handle url_verification, filter bot messages |
| Credentials per workspace | New `integrations` table with platform, webhookSecret, tokens | Encrypt tokens at rest |
| Source attribution | Use `source: "pylon"` or `source: "slack"` (already in schema) | Store platform-specific metadata in sourceMetadata |

**All requirements can be met with existing stack plus new integrations table. OAuth UI deferred to future phase.**
