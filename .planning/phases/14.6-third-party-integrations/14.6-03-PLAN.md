---
phase: 14.6-third-party-integrations
plan: 03
type: execute
wave: 2
depends_on: ["14.6-01"]
files_modified:
  - orchestrator/src/app/api/webhooks/pylon/route.ts
  - orchestrator/src/app/api/webhooks/slack/events/route.ts
autonomous: true
user_setup:
  - service: pylon
    why: "Support ticket ingestion"
    env_vars: []
    dashboard_config:
      - task: "Create webhook endpoint"
        location: "Pylon Dashboard -> Settings -> Webhooks"
        details: "Add webhook URL: https://your-domain.com/api/webhooks/pylon?integration_id={id}"
      - task: "Copy webhook secret"
        location: "Pylon Dashboard -> Settings -> Webhooks"
        details: "Save the signing secret to configure in Elmer"
  - service: slack
    why: "Channel message ingestion"
    env_vars: []
    dashboard_config:
      - task: "Create Slack App"
        location: "https://api.slack.com/apps -> Create New App"
        details: "From scratch, select workspace, name it 'Elmer Signals'"
      - task: "Enable Events API"
        location: "Slack App -> Event Subscriptions"
        details: "Toggle On, set Request URL to https://your-domain.com/api/webhooks/slack/events"
      - task: "Subscribe to message events"
        location: "Slack App -> Event Subscriptions -> Subscribe to bot events"
        details: "Add message.channels and message.groups"
      - task: "Copy signing secret"
        location: "Slack App -> Basic Information -> Signing Secret"
        details: "Save to configure as integration webhook secret in Elmer"
      - task: "Install app to workspace"
        location: "Slack App -> Install App"
        details: "Install and authorize, note the team_id for Elmer configuration"

must_haves:
  truths:
    - "Pylon endpoint accepts POST with HMAC signature verification"
    - "Slack endpoint handles url_verification challenge response"
    - "Slack endpoint filters bot messages and message subtypes"
    - "Both endpoints use queue-first pattern with after() for async processing"
  artifacts:
    - path: "orchestrator/src/app/api/webhooks/pylon/route.ts"
      provides: "Pylon webhook endpoint"
      exports: ["POST"]
    - path: "orchestrator/src/app/api/webhooks/slack/events/route.ts"
      provides: "Slack Events API endpoint"
      exports: ["POST"]
  key_links:
    - from: "/api/webhooks/pylon"
      to: "integrations table"
      via: "lookup by integration_id query param"
      pattern: "searchParams.get.*integration_id"
    - from: "/api/webhooks/slack/events"
      to: "integrations table"
      via: "lookup by team_id from payload"
      pattern: "eq.*integrations.slackTeamId.*team_id"
---

<objective>
Create dedicated webhook endpoints for Pylon (/api/webhooks/pylon) and Slack (/api/webhooks/slack/events) integrations.

Purpose: External platforms push events to these endpoints. Each endpoint handles platform-specific authentication, payload parsing, and routes to signal creation using the utilities from Plan 02. Following Phase 13's queue-first pattern - return 200 immediately, process via after().

Output: Two webhook endpoints ready to receive Pylon ticket events and Slack messages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14.6-third-party-integrations/14.6-RESEARCH.md
@orchestrator/src/app/api/webhooks/signals/route.ts
@orchestrator/src/lib/webhooks/auth.ts
@orchestrator/src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pylon webhook endpoint</name>
  <files>orchestrator/src/app/api/webhooks/pylon/route.ts</files>
  <action>
Create orchestrator/src/app/api/webhooks/pylon/route.ts:

```typescript
/**
 * Pylon webhook endpoint for support ticket ingestion
 *
 * Authentication: HMAC-SHA256 signature verification
 * Workspace mapping: Via integration_id query parameter
 *
 * POST /api/webhooks/pylon?integration_id={id}
 */
import { after } from "next/server";
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { integrations } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";
import {
  verifyPylonSignature,
  createSignalFromPylon,
  type PylonWebhookPayload,
} from "@/lib/integrations";

export async function POST(request: NextRequest) {
  const receivedAt = new Date();
  const rawBody = await request.text();

  // Get integration_id from query params (required for workspace mapping)
  const integrationId = new URL(request.url).searchParams.get("integration_id");
  if (!integrationId) {
    return NextResponse.json(
      { error: "Missing integration_id query parameter" },
      { status: 400 }
    );
  }

  // Parse payload
  let payload: PylonWebhookPayload;
  try {
    payload = JSON.parse(rawBody);
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }

  // Look up integration
  const integration = await db.query.integrations.findFirst({
    where: and(
      eq(integrations.id, integrationId),
      eq(integrations.platform, "pylon"),
      eq(integrations.isActive, true)
    ),
  });

  if (!integration) {
    return NextResponse.json(
      { error: "Unknown or inactive integration" },
      { status: 401 }
    );
  }

  if (!integration.webhookSecret) {
    return NextResponse.json(
      { error: "Integration not configured (missing webhook secret)" },
      { status: 500 }
    );
  }

  // Verify signature
  const timestamp = request.headers.get("pylon-webhook-timestamp");
  const signature = request.headers.get("pylon-webhook-signature");

  if (!verifyPylonSignature(rawBody, timestamp, signature, integration.webhookSecret)) {
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  // Queue async processing
  after(async () => {
    try {
      const result = await createSignalFromPylon({
        workspaceId: integration.workspaceId,
        payload: payload.data,
        receivedAt,
      });

      // Update lastUsedAt
      await db
        .update(integrations)
        .set({ lastUsedAt: new Date() })
        .where(eq(integrations.id, integrationId));

      if (result.error) {
        console.error("Pylon signal creation failed:", result.error);
      }
    } catch (error) {
      console.error("Pylon webhook processing error:", error);
      // Don't throw - webhook is already acknowledged
    }
  });

  return NextResponse.json({
    success: true,
    message: "Ticket received, processing async",
    receivedAt: receivedAt.toISOString(),
  });
}
```

Key details:
- integration_id comes from URL query param (configured when setting up webhook in Pylon)
- Signature headers: pylon-webhook-timestamp, pylon-webhook-signature
- Returns 200 immediately, processes via after() (queue-first pattern)
- Updates lastUsedAt for integration tracking
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Pylon webhook endpoint created with signature verification and async processing</done>
</task>

<task type="auto">
  <name>Task 2: Create Slack Events API endpoint</name>
  <files>orchestrator/src/app/api/webhooks/slack/events/route.ts</files>
  <action>
Create directory and file orchestrator/src/app/api/webhooks/slack/events/route.ts:

```typescript
/**
 * Slack Events API endpoint for message ingestion
 *
 * Authentication: HMAC-SHA256 signature verification (v0 format)
 * URL Verification: Handles Slack's url_verification challenge
 * Workspace mapping: Via team_id from payload
 *
 * POST /api/webhooks/slack/events
 */
import { after } from "next/server";
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { integrations } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";
import {
  verifySlackSignature,
  createSignalFromSlack,
  type SlackEventPayload,
} from "@/lib/integrations";

export async function POST(request: NextRequest) {
  const receivedAt = new Date();
  const rawBody = await request.text();

  // Parse payload first (needed for url_verification check)
  let payload: SlackEventPayload;
  try {
    payload = JSON.parse(rawBody);
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }

  // Handle URL verification challenge (no signature check for this)
  // This is sent when configuring the Events API endpoint in Slack
  if (payload.type === "url_verification") {
    return NextResponse.json({ challenge: payload.challenge });
  }

  // For all other requests, team_id is required
  if (!payload.team_id) {
    return NextResponse.json(
      { error: "Missing team_id in payload" },
      { status: 400 }
    );
  }

  // Look up integration by Slack team_id
  const integration = await db.query.integrations.findFirst({
    where: and(
      eq(integrations.platform, "slack"),
      eq(integrations.slackTeamId, payload.team_id),
      eq(integrations.isActive, true)
    ),
  });

  if (!integration) {
    return NextResponse.json(
      { error: "Unknown Slack team or inactive integration" },
      { status: 401 }
    );
  }

  if (!integration.webhookSecret) {
    return NextResponse.json(
      { error: "Integration not configured (missing signing secret)" },
      { status: 500 }
    );
  }

  // Verify Slack signature
  const timestamp = request.headers.get("x-slack-request-timestamp");
  const signature = request.headers.get("x-slack-signature");

  if (!verifySlackSignature(rawBody, timestamp, signature, integration.webhookSecret)) {
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  // Handle event callbacks
  if (payload.type === "event_callback" && payload.event?.type === "message") {
    const event = payload.event;

    // Filter out bot messages (prevent self-processing and bot spam)
    if (event.bot_id || event.user === integration.slackBotUserId) {
      return NextResponse.json({
        ok: true,
        filtered: "bot_message",
        reason: "Bot messages are not processed as signals",
      });
    }

    // Filter out message subtypes (edits, deletes, channel joins, etc.)
    if (event.subtype) {
      return NextResponse.json({
        ok: true,
        filtered: "subtype",
        reason: `Message subtype '${event.subtype}' not processed`,
      });
    }

    // Filter out empty messages
    if (!event.text || event.text.trim() === "") {
      return NextResponse.json({
        ok: true,
        filtered: "empty",
        reason: "Empty messages are not processed as signals",
      });
    }

    // Queue async processing
    after(async () => {
      try {
        const result = await createSignalFromSlack({
          workspaceId: integration.workspaceId,
          event,
          teamId: payload.team_id!,
          receivedAt,
        });

        // Update lastUsedAt
        await db
          .update(integrations)
          .set({ lastUsedAt: new Date() })
          .where(eq(integrations.id, integration.id));

        if (result.error) {
          console.error("Slack signal creation failed:", result.error);
        }
      } catch (error) {
        console.error("Slack webhook processing error:", error);
        // Don't throw - webhook is already acknowledged
      }
    });
  }

  return NextResponse.json({ ok: true });
}
```

Key details:
- URL verification: Returns challenge for Slack's endpoint setup
- Signature headers: x-slack-request-timestamp, x-slack-signature
- Workspace lookup via team_id from payload (stored during manual configuration)
- Filters: bot messages, message subtypes, empty messages
- Returns 200 immediately, processes via after() (queue-first pattern)
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Slack Events API endpoint created with URL verification, signature checking, and message filtering</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
- [ ] /api/webhooks/pylon/route.ts exports POST handler
- [ ] /api/webhooks/slack/events/route.ts exports POST handler
- [ ] Pylon endpoint requires integration_id query parameter
- [ ] Slack endpoint handles url_verification challenge
- [ ] Slack endpoint filters bot messages and subtypes
- [ ] Both endpoints use after() for async processing
- [ ] Both endpoints update integration lastUsedAt
</verification>

<success_criteria>
1. Pylon endpoint verifies signature and creates signals from tickets
2. Slack endpoint handles URL verification challenge for setup
3. Slack endpoint verifies v0 signature format correctly
4. Slack endpoint filters bot messages and message subtypes
5. Both endpoints follow queue-first pattern (200 immediate, process async)
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14.6-third-party-integrations/14.6-03-SUMMARY.md`
</output>
