---
phase: 14.6-third-party-integrations
plan: 02
type: execute
wave: 2
depends_on: ["14.6-01"]
files_modified:
  - orchestrator/src/lib/integrations/types.ts
  - orchestrator/src/lib/integrations/slack.ts
  - orchestrator/src/lib/integrations/pylon.ts
  - orchestrator/src/lib/integrations/index.ts
autonomous: true

must_haves:
  truths:
    - "Slack signature verification uses v0:{timestamp}:{body} format with HMAC-SHA256"
    - "Pylon signature verification uses {timestamp}.{body} format with HMAC-SHA256"
    - "Signal creation from Slack includes channelId, messageTs, and filters bot messages"
    - "Signal creation from Pylon extracts text from HTML and includes ticket metadata"
  artifacts:
    - path: "orchestrator/src/lib/integrations/slack.ts"
      provides: "Slack signature verification and signal creation"
      exports: ["verifySlackSignature", "createSignalFromSlack"]
    - path: "orchestrator/src/lib/integrations/pylon.ts"
      provides: "Pylon signature verification and signal creation"
      exports: ["verifyPylonSignature", "createSignalFromPylon"]
    - path: "orchestrator/src/lib/integrations/types.ts"
      provides: "Slack and Pylon payload type definitions"
      contains: "SlackEventPayload"
    - path: "orchestrator/src/lib/integrations/index.ts"
      provides: "Barrel exports for integrations module"
  key_links:
    - from: "createSignalFromSlack"
      to: "signals table"
      via: "db.insert with source='slack'"
      pattern: "source: \"slack\""
    - from: "createSignalFromPylon"
      to: "signals table"
      via: "db.insert with source='pylon'"
      pattern: "source: \"pylon\""
---

<objective>
Create integration utility library with platform-specific signature verification and signal creation functions for Slack and Pylon.

Purpose: The webhook endpoints need verified authentication before processing. This plan creates the core utilities following the research patterns for Slack's v0:{ts}:{body} signature format and Pylon's {ts}.{body} format, plus signal creation functions that use existing patterns from processSignalWebhook.

Output: lib/integrations module with verified signature verification and signal creation utilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14.6-third-party-integrations/14.6-RESEARCH.md
@orchestrator/src/lib/webhooks/auth.ts
@orchestrator/src/lib/webhooks/processor.ts
@orchestrator/src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create type definitions for Slack and Pylon payloads</name>
  <files>orchestrator/src/lib/integrations/types.ts</files>
  <action>
Create orchestrator/src/lib/integrations/types.ts with type definitions:

```typescript
/**
 * Type definitions for third-party integration payloads
 */

// ============================================
// SLACK TYPES
// ============================================

export interface SlackEventPayload {
  type: "url_verification" | "event_callback";
  challenge?: string;  // For url_verification
  token?: string;      // Deprecated verification token (ignored)
  team_id?: string;
  api_app_id?: string;
  event?: SlackMessageEvent;
  event_id?: string;
  event_time?: number;
}

export interface SlackMessageEvent {
  type: string;         // "message"
  channel: string;      // Channel ID (e.g., "C1234567890")
  user: string;         // User ID who sent message
  text: string;         // Message content
  ts: string;           // Message timestamp (e.g., "1234567890.123456")
  thread_ts?: string;   // Thread timestamp if reply
  bot_id?: string;      // Present if sent by a bot
  subtype?: string;     // Message subtype (message_changed, message_deleted, etc.)
}

export interface SlackMessageInput {
  workspaceId: string;
  event: SlackMessageEvent;
  teamId: string;
  receivedAt: Date;
}

// ============================================
// PYLON TYPES
// ============================================

export interface PylonWebhookPayload {
  data: PylonTicketData;
  event_type?: string;  // "issue.created", "issue.updated", etc.
}

export interface PylonTicketData {
  id: string;
  title?: string;
  body_html?: string;
  body_text?: string;   // Plain text version if available
  state?: string;       // "open", "closed", etc.
  priority?: string;
  requester?: {
    email: string;
    name?: string;
  };
  account?: {
    id: string;
    name?: string;
  };
  link?: string;        // URL to ticket in Pylon
  created_at?: string;
  updated_at?: string;
}

export interface PylonTicketInput {
  workspaceId: string;
  payload: PylonTicketData;
  receivedAt: Date;
}

// ============================================
// COMMON TYPES
// ============================================

export interface SignalCreateResult {
  created: boolean;
  signalId?: string;
  duplicate?: boolean;
  filtered?: string;    // Reason if filtered out (bot_message, subtype)
  error?: string;
}
```
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Type definitions created for Slack and Pylon integration payloads</done>
</task>

<task type="auto">
  <name>Task 2: Create Slack signature verification and signal creation</name>
  <files>orchestrator/src/lib/integrations/slack.ts</files>
  <action>
Create orchestrator/src/lib/integrations/slack.ts:

```typescript
/**
 * Slack integration utilities
 * - Signature verification using v0:{timestamp}:{body} format
 * - Signal creation from Slack messages
 */
import crypto from "crypto";
import { db } from "@/lib/db";
import { signals, activityLogs } from "@/lib/db/schema";
import { nanoid } from "nanoid";
import type { SlackMessageInput, SignalCreateResult } from "./types";

/**
 * Verify Slack request signature
 * Format: v0={HMAC-SHA256(v0:{timestamp}:{body})}
 *
 * @see https://docs.slack.dev/authentication/verifying-requests-from-slack/
 */
export function verifySlackSignature(
  rawBody: string,
  timestamp: string | null,
  signature: string | null,
  signingSecret: string
): boolean {
  if (!timestamp || !signature) return false;

  // Reject requests older than 5 minutes (replay attack prevention)
  const fiveMinutesAgo = Math.floor(Date.now() / 1000) - 60 * 5;
  if (parseInt(timestamp, 10) < fiveMinutesAgo) return false;

  // Create base string: v0:{timestamp}:{body}
  const baseString = `v0:${timestamp}:${rawBody}`;

  // Compute expected signature
  const expectedSignature =
    "v0=" +
    crypto.createHmac("sha256", signingSecret).update(baseString).digest("hex");

  // Timing-safe comparison
  try {
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  } catch {
    // Buffer lengths don't match
    return false;
  }
}

/**
 * Create signal from Slack message
 * Uses check-then-insert for idempotency via sourceRef
 */
export async function createSignalFromSlack(
  input: SlackMessageInput
): Promise<SignalCreateResult> {
  const { workspaceId, event, teamId, receivedAt } = input;

  // Generate unique sourceRef for idempotency
  const sourceRef = `slack-${teamId}-${event.channel}-${event.ts}`;

  try {
    // Check for existing (idempotency)
    const existing = await db.query.signals.findFirst({
      where: (signals, { and, eq }) =>
        and(
          eq(signals.workspaceId, workspaceId),
          eq(signals.source, "slack"),
          eq(signals.sourceRef, sourceRef)
        ),
    });

    if (existing) {
      return { created: false, signalId: existing.id, duplicate: true };
    }

    const signalId = nanoid();
    const [signal] = await db
      .insert(signals)
      .values({
        id: signalId,
        workspaceId,
        verbatim: event.text,
        source: "slack",
        sourceRef,
        sourceMetadata: {
          channelId: event.channel,
          messageTs: event.ts,
          threadTs: event.thread_ts,
          externalId: `${teamId}/${event.channel}/${event.ts}`,
          rawPayload: event as unknown as Record<string, unknown>,
        },
        status: "new",
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    // Log activity
    await db.insert(activityLogs).values({
      id: nanoid(),
      workspaceId,
      action: "signal.created",
      targetType: "signal",
      targetId: signalId,
      metadata: {
        source: "slack",
        channelId: event.channel,
        verbatimPreview: event.text.slice(0, 100),
      },
      createdAt: new Date(),
    });

    return { created: true, signalId };
  } catch (error) {
    console.error("Slack signal creation error:", error);
    return {
      created: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}
```

Key implementation details:
- Signature format: v0={hash} where hash = HMAC-SHA256(v0:{timestamp}:{body})
- 5-minute timestamp window to prevent replay attacks
- Timing-safe comparison using crypto.timingSafeEqual
- Idempotency via sourceRef pattern: slack-{teamId}-{channel}-{ts}
- Store channel, message timestamp, and thread context in sourceMetadata
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Slack signature verification and signal creation functions implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create Pylon signature verification and signal creation</name>
  <files>orchestrator/src/lib/integrations/pylon.ts, orchestrator/src/lib/integrations/index.ts</files>
  <action>
Create orchestrator/src/lib/integrations/pylon.ts:

```typescript
/**
 * Pylon integration utilities
 * - Signature verification using {timestamp}.{body} format
 * - Signal creation from Pylon tickets
 */
import crypto from "crypto";
import { db } from "@/lib/db";
import { signals, activityLogs } from "@/lib/db/schema";
import { nanoid } from "nanoid";
import type { PylonTicketInput, SignalCreateResult } from "./types";

/**
 * Verify Pylon webhook signature
 * Format: HMAC-SHA256({timestamp}.{body})
 * Signature header format: hs256={hash} or plain {hash}
 *
 * @see https://getpylon.com/developers/guides/using-webhooks/
 */
export function verifyPylonSignature(
  rawBody: string,
  timestamp: string | null,
  signature: string | null,
  secret: string
): boolean {
  if (!timestamp || !signature) return false;

  // Normalize signature (remove hs256= prefix if present)
  const normalizedSignature = signature.startsWith("hs256=")
    ? signature.slice(6)
    : signature;

  // Create base string: {timestamp}.{body}
  const baseString = `${timestamp}.${rawBody}`;

  // Compute expected signature
  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(baseString)
    .digest("hex");

  // Timing-safe comparison
  try {
    return crypto.timingSafeEqual(
      Buffer.from(normalizedSignature, "hex"),
      Buffer.from(expectedSignature, "hex")
    );
  } catch {
    // Buffer lengths don't match or invalid hex
    return false;
  }
}

/**
 * Strip HTML tags and normalize whitespace
 * Simple approach - not a full HTML parser
 */
function stripHtml(html: string): string {
  return html
    .replace(/<[^>]*>/g, " ")  // Replace tags with spaces
    .replace(/&nbsp;/g, " ")    // Handle non-breaking spaces
    .replace(/&amp;/g, "&")     // Handle ampersands
    .replace(/&lt;/g, "<")      // Handle less than
    .replace(/&gt;/g, ">")      // Handle greater than
    .replace(/&quot;/g, '"')    // Handle quotes
    .replace(/&#39;/g, "'")     // Handle apostrophes
    .replace(/\s+/g, " ")       // Collapse whitespace
    .trim();
}

/**
 * Create signal from Pylon ticket
 * Uses check-then-insert for idempotency via sourceRef
 */
export async function createSignalFromPylon(
  input: PylonTicketInput
): Promise<SignalCreateResult> {
  const { workspaceId, payload, receivedAt } = input;

  // Generate unique sourceRef
  const sourceRef = `pylon-${payload.id}`;

  // Extract text content - prefer plain text, fall back to stripped HTML
  const verbatim = payload.body_text
    ? payload.body_text.trim()
    : payload.body_html
      ? stripHtml(payload.body_html)
      : payload.title || "No content";

  // Skip empty content
  if (!verbatim || verbatim === "No content") {
    return { created: false, filtered: "empty_content" };
  }

  try {
    // Check for existing (idempotency)
    const existing = await db.query.signals.findFirst({
      where: (signals, { and, eq }) =>
        and(
          eq(signals.workspaceId, workspaceId),
          eq(signals.source, "pylon"),
          eq(signals.sourceRef, sourceRef)
        ),
    });

    if (existing) {
      return { created: false, signalId: existing.id, duplicate: true };
    }

    const signalId = nanoid();
    const [signal] = await db
      .insert(signals)
      .values({
        id: signalId,
        workspaceId,
        verbatim,
        source: "pylon",
        sourceRef,
        sourceMetadata: {
          ticketId: payload.id,
          ticketStatus: payload.state,
          customerEmail: payload.requester?.email,
          sourceName: payload.requester?.name,
          sourceUrl: payload.link,
          rawPayload: payload as unknown as Record<string, unknown>,
        },
        status: "new",
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    // Log activity
    await db.insert(activityLogs).values({
      id: nanoid(),
      workspaceId,
      action: "signal.created",
      targetType: "signal",
      targetId: signalId,
      metadata: {
        source: "pylon",
        ticketId: payload.id,
        verbatimPreview: verbatim.slice(0, 100),
      },
      createdAt: new Date(),
    });

    return { created: true, signalId };
  } catch (error) {
    console.error("Pylon signal creation error:", error);
    return {
      created: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}
```

Then create orchestrator/src/lib/integrations/index.ts:

```typescript
/**
 * Third-party integration utilities
 * Exports for Slack and Pylon webhook handling
 */

// Types
export type {
  SlackEventPayload,
  SlackMessageEvent,
  SlackMessageInput,
  PylonWebhookPayload,
  PylonTicketData,
  PylonTicketInput,
  SignalCreateResult,
} from "./types";

// Slack
export { verifySlackSignature, createSignalFromSlack } from "./slack";

// Pylon
export { verifyPylonSignature, createSignalFromPylon } from "./pylon";
```

Key implementation details:
- Pylon signature: {timestamp}.{body} with optional hs256= prefix
- HTML stripping for body_html content with entity decoding
- Idempotency via sourceRef pattern: pylon-{ticketId}
- Store ticket ID, status, customer email, and link in sourceMetadata
  </action>
  <verify>TypeScript compiles: `cd orchestrator && npx tsc --noEmit`</verify>
  <done>Pylon utilities and barrel exports created</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles: `cd orchestrator && npx tsc --noEmit`
- [ ] lib/integrations/types.ts defines Slack and Pylon payload types
- [ ] lib/integrations/slack.ts exports verifySlackSignature and createSignalFromSlack
- [ ] lib/integrations/pylon.ts exports verifyPylonSignature and createSignalFromPylon
- [ ] lib/integrations/index.ts barrel exports all utilities
- [ ] Slack signature uses v0:{timestamp}:{body} format
- [ ] Pylon signature uses {timestamp}.{body} format
- [ ] Both use crypto.timingSafeEqual for timing-safe comparison
- [ ] Both signal creators use idempotent check-then-insert pattern
</verification>

<success_criteria>
1. Slack signature verification correctly implements v0 format from Slack documentation
2. Pylon signature verification correctly implements timestamp.body format
3. Signal creation functions use existing patterns (sourceRef idempotency, activity logging)
4. All types properly defined for Slack events and Pylon tickets
5. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14.6-third-party-integrations/14.6-02-SUMMARY.md`
</output>
