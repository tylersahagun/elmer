# Plan 01-01: Database Schema Extensions

## Frontmatter

```yaml
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/lib/db/schema.ts
  - orchestrator/package.json
  - orchestrator/package-lock.json
  - drizzle/*.sql
autonomous: true
estimated_duration: 30min
```

## Objective

Extend the database schema with authentication and collaboration tables required for multi-user support: users, accounts, sessions, verification_tokens, workspace_members, invitations, and activity_logs.

## Context

The existing schema in `orchestrator/src/lib/db/schema.ts` contains workspaces, projects, documents, and other PM orchestrator tables. We need to add Auth.js-compatible tables and collaboration tables that reference the existing workspaces table.

## Tasks

<task name="Install bcryptjs dependency">

Install bcryptjs for password hashing (Edge-compatible, no native bindings):

```bash
cd orchestrator
npm install bcryptjs
npm install -D @types/bcryptjs
```

**Verification:**
- [ ] `bcryptjs` appears in package.json dependencies
- [ ] `@types/bcryptjs` appears in devDependencies

</task>

<task name="Add users table to schema">

Add the users table to `orchestrator/src/lib/db/schema.ts`:

```typescript
// ============================================
// USERS (Authentication)
// ============================================

export const users = pgTable("users", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  email: text("email").notNull().unique(),
  name: text("name"),
  image: text("image"),
  passwordHash: text("password_hash"), // null for OAuth-only users
  emailVerified: timestamp("email_verified"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
```

**Verification:**
- [ ] `users` table definition exists in schema.ts
- [ ] Email has unique constraint
- [ ] passwordHash column is nullable (for OAuth users)

</task>

<task name="Add Auth.js required tables">

Add sessions, accounts, and verification_tokens tables for Auth.js adapter:

```typescript
// ============================================
// AUTH.JS ADAPTER TABLES
// ============================================

export const sessions = pgTable("sessions", {
  sessionToken: text("session_token").primaryKey(),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  expires: timestamp("expires").notNull(),
});

export const accounts = pgTable("accounts", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  type: text("type").notNull(),
  provider: text("provider").notNull(),
  providerAccountId: text("provider_account_id").notNull(),
  refresh_token: text("refresh_token"),
  access_token: text("access_token"),
  expires_at: integer("expires_at"),
  token_type: text("token_type"),
  scope: text("scope"),
  id_token: text("id_token"),
  session_state: text("session_state"),
}, (table) => ({
  providerUnique: unique().on(table.provider, table.providerAccountId),
}));

export const verificationTokens = pgTable("verification_tokens", {
  identifier: text("identifier").notNull(),
  token: text("token").notNull(),
  expires: timestamp("expires").notNull(),
}, (table) => ({
  pk: primaryKey({ columns: [table.identifier, table.token] }),
}));
```

**Verification:**
- [ ] `sessions` table with sessionToken as primary key
- [ ] `accounts` table with composite unique on (provider, providerAccountId)
- [ ] `verificationTokens` table with composite primary key

</task>

<task name="Add workspace_members table">

Add the workspace_members table for role-based access:

```typescript
// ============================================
// WORKSPACE MEMBERS (Collaboration)
// ============================================

export type WorkspaceRole = "admin" | "member" | "viewer";

export const workspaceMembers = pgTable("workspace_members", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  role: text("role").$type<WorkspaceRole>().notNull().default("member"),
  joinedAt: timestamp("joined_at").defaultNow().notNull(),
}, (table) => ({
  uniqueMembership: unique().on(table.workspaceId, table.userId),
}));
```

**Verification:**
- [ ] `workspace_members` table exists
- [ ] Composite unique constraint on (workspaceId, userId)
- [ ] Both foreign keys have cascade delete

</task>

<task name="Add invitations table">

Add the invitations table for email invites:

```typescript
// ============================================
// INVITATIONS
// ============================================

export const invitations = pgTable("invitations", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  email: text("email").notNull(),
  role: text("role").$type<WorkspaceRole>().notNull().default("member"),
  token: text("token").notNull().unique(),
  invitedBy: text("invited_by").notNull().references(() => users.id, { onDelete: "cascade" }),
  expiresAt: timestamp("expires_at").notNull(),
  acceptedAt: timestamp("accepted_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});
```

**Verification:**
- [ ] `invitations` table exists
- [ ] Token has unique constraint
- [ ] expiresAt column for expiration enforcement
- [ ] acceptedAt nullable for one-time use tracking

</task>

<task name="Add activity_logs table">

Add the activity_logs table for audit trail:

```typescript
// ============================================
// ACTIVITY LOGS (Audit Trail)
// ============================================

export const activityLogs = pgTable("activity_logs", {
  id: text("id").primaryKey().$defaultFn(() => nanoid()),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  userId: text("user_id").references(() => users.id, { onDelete: "set null" }),
  action: text("action").notNull(), // e.g., 'project.created', 'member.invited'
  targetType: text("target_type"), // 'project', 'workspace', 'member'
  targetId: text("target_id"),
  metadata: jsonb("metadata").$type<Record<string, unknown>>(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});
```

**Verification:**
- [ ] `activity_logs` table exists
- [ ] userId uses set null on delete (preserve history)
- [ ] metadata column is JSONB type

</task>

<task name="Add Drizzle relations for new tables">

Add relations for the new tables:

```typescript
// ============================================
// NEW RELATIONS
// ============================================

export const usersRelations = relations(users, ({ many }) => ({
  accounts: many(accounts),
  sessions: many(sessions),
  workspaceMembers: many(workspaceMembers),
  invitationsSent: many(invitations),
  activityLogs: many(activityLogs),
}));

export const sessionsRelations = relations(sessions, ({ one }) => ({
  user: one(users, {
    fields: [sessions.userId],
    references: [users.id],
  }),
}));

export const accountsRelations = relations(accounts, ({ one }) => ({
  user: one(users, {
    fields: [accounts.userId],
    references: [users.id],
  }),
}));

export const workspaceMembersRelations = relations(workspaceMembers, ({ one }) => ({
  workspace: one(workspaces, {
    fields: [workspaceMembers.workspaceId],
    references: [workspaces.id],
  }),
  user: one(users, {
    fields: [workspaceMembers.userId],
    references: [users.id],
  }),
}));

export const invitationsRelations = relations(invitations, ({ one }) => ({
  workspace: one(workspaces, {
    fields: [invitations.workspaceId],
    references: [workspaces.id],
  }),
  inviter: one(users, {
    fields: [invitations.invitedBy],
    references: [users.id],
  }),
}));

export const activityLogsRelations = relations(activityLogs, ({ one }) => ({
  workspace: one(workspaces, {
    fields: [activityLogs.workspaceId],
    references: [workspaces.id],
  }),
  user: one(users, {
    fields: [activityLogs.userId],
    references: [users.id],
  }),
}));
```

Also update `workspacesRelations` to include new relations:

```typescript
export const workspacesRelations = relations(workspaces, ({ many }) => ({
  projects: many(projects),
  jobs: many(jobs),
  memoryEntries: many(memoryEntries),
  columnConfigs: many(columnConfigs),
  knowledgebaseEntries: many(knowledgebaseEntries),
  knowledgeSources: many(knowledgeSources),
  notifications: many(notifications),
  // NEW
  members: many(workspaceMembers),
  invitations: many(invitations),
  activityLogs: many(activityLogs),
}));
```

**Verification:**
- [ ] All new tables have relations defined
- [ ] workspacesRelations updated with new relations
- [ ] No TypeScript errors in schema file

</task>

<task name="Add required imports">

Ensure all necessary imports are at the top of schema.ts:

```typescript
import { pgTable, text, integer, real, timestamp, boolean, jsonb, unique, primaryKey } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { nanoid } from "nanoid";
```

Note: `unique` and `primaryKey` are new imports needed for constraints.

**Verification:**
- [ ] `unique` imported from drizzle-orm/pg-core
- [ ] `primaryKey` imported from drizzle-orm/pg-core
- [ ] No import errors

</task>

<task name="Generate database migration">

Generate the migration file:

```bash
cd orchestrator
npm run db:generate
```

This creates a new migration file in `drizzle/` directory.

**Verification:**
- [ ] New migration file created in drizzle/ folder
- [ ] Migration includes CREATE TABLE statements for all 7 new tables
- [ ] Migration includes foreign key constraints
- [ ] Migration includes unique constraints

</task>

<task name="Run database migration">

Apply the migration to the database:

```bash
cd orchestrator
npm run db:migrate
```

**Verification:**
- [ ] Migration completes without errors
- [ ] Tables exist in database (check with `npm run db:studio`)

</task>

## Verification Criteria

After all tasks complete, verify:

1. **Schema file compiles:** `cd orchestrator && npx tsc --noEmit` passes
2. **Migration generated:** New SQL file exists in `drizzle/`
3. **Migration applied:** `npm run db:migrate` succeeds
4. **Tables exist:** All 7 new tables visible in Drizzle Studio

## Must Haves

- [ ] Users table with passwordHash column (nullable)
- [ ] Workspace members table with unique (workspaceId, userId) constraint
- [ ] Invitations table with unique token constraint
- [ ] Activity logs table with JSONB metadata
- [ ] All Auth.js adapter tables (accounts, sessions, verification_tokens)
- [ ] Migration runs successfully

## Rollback

If migration fails:

```bash
# Connect to database and drop new tables
DROP TABLE IF EXISTS activity_logs CASCADE;
DROP TABLE IF EXISTS invitations CASCADE;
DROP TABLE IF EXISTS workspace_members CASCADE;
DROP TABLE IF EXISTS verification_tokens CASCADE;
DROP TABLE IF EXISTS sessions CASCADE;
DROP TABLE IF EXISTS accounts CASCADE;
DROP TABLE IF EXISTS users CASCADE;
```

---
*Plan 01-01: Database Schema Extensions*
