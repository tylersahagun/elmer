---
phase: 12.5-manual-association
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/app/api/signals/[id]/projects/route.ts
  - orchestrator/src/app/api/signals/[id]/personas/route.ts
  - orchestrator/src/app/api/projects/[id]/signals/route.ts
  - orchestrator/src/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/signals/:id/projects creates a link between signal and project"
    - "DELETE /api/signals/:id/projects removes a link between signal and project"
    - "POST /api/signals/:id/personas creates a link between signal and persona"
    - "DELETE /api/signals/:id/personas removes a link between signal and persona"
    - "GET /api/projects/:id/signals returns all signals linked to a project"
    - "Signal status auto-updates to 'linked' when first project linked"
    - "Signal status auto-updates to 'reviewed' when last project unlinked"
  artifacts:
    - path: "orchestrator/src/app/api/signals/[id]/projects/route.ts"
      provides: "Link/unlink signals to projects API"
      exports: ["POST", "DELETE", "GET"]
    - path: "orchestrator/src/app/api/signals/[id]/personas/route.ts"
      provides: "Link/unlink signals to personas API"
      exports: ["POST", "DELETE", "GET"]
    - path: "orchestrator/src/app/api/projects/[id]/signals/route.ts"
      provides: "Get signals for a project API"
      exports: ["GET"]
  key_links:
    - from: "orchestrator/src/app/api/signals/[id]/projects/route.ts"
      to: "signalProjects junction table"
      via: "db.insert/delete"
      pattern: "signalProjects"
    - from: "orchestrator/src/app/api/signals/[id]/personas/route.ts"
      to: "signalPersonas junction table"
      via: "db.insert/delete"
      pattern: "signalPersonas"
---

<objective>
Create API routes for linking and unlinking signals to projects and personas.

Purpose: Enable bidirectional signal association workflow - the foundation for the provenance chain linking product decisions back to user evidence.

Output: REST API endpoints for CRUD operations on signal-project and signal-persona associations, plus a project-centric endpoint for fetching linked signals.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.5-manual-association/12.5-CONTEXT.md
@.planning/phases/12.5-manual-association/12.5-RESEARCH.md

Key patterns from prior phases:
- Signal API pattern established in 12-01: `/api/signals/[id]/route.ts` uses `requireWorkspaceAccess(signal.workspaceId, "member")`
- Junction tables `signalProjects` and `signalPersonas` exist from Phase 11 (see schema.ts lines 1227-1247)
- Status invariant: `linked` status iff linkedProjects.length > 0

Reference files:
@orchestrator/src/app/api/signals/[id]/route.ts
@orchestrator/src/lib/db/schema.ts (lines 1227-1290 for junction tables)
@orchestrator/src/lib/permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add query functions for signal associations</name>
  <files>orchestrator/src/lib/db/queries.ts</files>
  <action>
Add query functions to queries.ts for signal association operations:

1. `getSignalWithLinks(id: string)` - Get signal with linked projects and personas using Drizzle `with` clause:
   - Use `db.query.signals.findFirst` with `where: eq(signals.id, id)`
   - Include `with: { projects: { with: { project: true } }, personas: true }`
   - Returns full signal with nested project details and persona IDs

2. `linkSignalToProject(signalId: string, projectId: string, linkedBy: string, linkReason?: string)`:
   - Insert into signalProjects with signalId, projectId, linkedBy, linkReason
   - Return the inserted record
   - Use `db.insert(signalProjects).values(...).returning()`

3. `unlinkSignalFromProject(signalId: string, projectId: string)`:
   - Delete from signalProjects where signalId AND projectId match
   - Use `db.delete(signalProjects).where(and(eq(...), eq(...)))`
   - Return { deleted: true }

4. `linkSignalToPersona(signalId: string, personaId: string, linkedBy: string)`:
   - Insert into signalPersonas with signalId, personaId, linkedBy
   - Return the inserted record

5. `unlinkSignalFromPersona(signalId: string, personaId: string)`:
   - Delete from signalPersonas where signalId AND personaId match
   - Return { deleted: true }

6. `getSignalsForProject(projectId: string, options?: { limit?: number, offset?: number })`:
   - Query signalProjects where projectId matches
   - Join with signals table to get full signal data
   - Order by linkedAt DESC (recently linked first)
   - Support pagination with limit/offset
   - Return signals with linkedAt timestamp

7. `countSignalProjectLinks(signalId: string)`:
   - Count rows in signalProjects where signalId matches
   - Used to determine if status should change on unlink

Import signalProjects and signalPersonas from schema.ts if not already imported.
  </action>
  <verify>
Run `cd /Users/tylersahagun/Source/elmer/orchestrator && npm run build` - should compile without TypeScript errors.
  </verify>
  <done>
Seven new query functions exported from queries.ts for signal association operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /api/signals/[id]/projects route</name>
  <files>orchestrator/src/app/api/signals/[id]/projects/route.ts</files>
  <action>
Create new API route file at `orchestrator/src/app/api/signals/[id]/projects/route.ts`:

**GET handler** - List projects linked to a signal:
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id: signalId } = await params;

  // Get signal to verify it exists and get workspaceId
  const signal = await getSignal(signalId);
  if (!signal) {
    return NextResponse.json({ error: "Signal not found" }, { status: 404 });
  }

  // Verify membership (viewer can read)
  await requireWorkspaceAccess(signal.workspaceId, "viewer");

  // Get signal with linked projects
  const signalWithLinks = await getSignalWithLinks(signalId);

  return NextResponse.json({
    projects: signalWithLinks?.projects.map(p => ({
      id: p.project.id,
      name: p.project.name,
      linkedAt: p.linkedAt,
      linkReason: p.linkReason,
    })) || []
  });
}
```

**POST handler** - Link signal to project:
```typescript
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id: signalId } = await params;
  const { projectId, linkReason } = await request.json();

  if (!projectId) {
    return NextResponse.json({ error: "projectId required" }, { status: 400 });
  }

  // Get signal to verify it exists and get workspaceId
  const signal = await getSignal(signalId);
  if (!signal) {
    return NextResponse.json({ error: "Signal not found" }, { status: 404 });
  }

  // Verify membership (member can write)
  const membership = await requireWorkspaceAccess(signal.workspaceId, "member");

  // Create link
  await linkSignalToProject(signalId, projectId, membership.userId, linkReason);

  // Update signal status to "linked" if not already
  if (signal.status !== "linked") {
    await updateSignal(signalId, { status: "linked" });
  }

  return NextResponse.json({ success: true });
}
```

**DELETE handler** - Unlink signal from project:
```typescript
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id: signalId } = await params;
  const { projectId } = await request.json();

  if (!projectId) {
    return NextResponse.json({ error: "projectId required" }, { status: 400 });
  }

  const signal = await getSignal(signalId);
  if (!signal) {
    return NextResponse.json({ error: "Signal not found" }, { status: 404 });
  }

  await requireWorkspaceAccess(signal.workspaceId, "member");

  // Delete link
  await unlinkSignalFromProject(signalId, projectId);

  // Check if any projects remain linked
  const remainingCount = await countSignalProjectLinks(signalId);

  // Update status to "reviewed" if no projects linked and current status is "linked"
  if (remainingCount === 0 && signal.status === "linked") {
    await updateSignal(signalId, { status: "reviewed" });
  }

  return NextResponse.json({ success: true });
}
```

Import from:
- `NextRequest, NextResponse` from "next/server"
- Query functions from "@/lib/db/queries"
- `requireWorkspaceAccess` from "@/lib/permissions"
  </action>
  <verify>
Run `cd /Users/tylersahagun/Source/elmer/orchestrator && npm run build` - route compiles.
Test with curl once dev server running:
- `curl -X GET http://localhost:3000/api/signals/{signalId}/projects` returns projects array
  </verify>
  <done>
API route at /api/signals/[id]/projects handles GET (list), POST (link), DELETE (unlink) with proper permission checks and status invariant enforcement.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create /api/signals/[id]/personas and /api/projects/[id]/signals routes</name>
  <files>
    orchestrator/src/app/api/signals/[id]/personas/route.ts
    orchestrator/src/app/api/projects/[id]/signals/route.ts
  </files>
  <action>
**File 1: `orchestrator/src/app/api/signals/[id]/personas/route.ts`**

Similar pattern to projects route:

**GET handler** - List personas linked to signal:
- Get signal, verify workspace access (viewer)
- Return personas array from getSignalWithLinks

**POST handler** - Link signal to persona:
- Validate personaId in body
- Get signal, verify workspace access (member)
- Call linkSignalToPersona(signalId, personaId, membership.userId)
- Return success

**DELETE handler** - Unlink signal from persona:
- Validate personaId in body
- Get signal, verify workspace access (member)
- Call unlinkSignalFromPersona(signalId, personaId)
- Return success

Note: Persona linking does NOT affect signal status (only project linking does).

---

**File 2: `orchestrator/src/app/api/projects/[id]/signals/route.ts`**

**GET handler** - List signals linked to a project:
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id: projectId } = await params;
  const { searchParams } = new URL(request.url);
  const limit = parseInt(searchParams.get("limit") || "50");
  const offset = parseInt(searchParams.get("offset") || "0");

  // Get project to verify it exists and get workspaceId
  const project = await getProject(projectId);
  if (!project) {
    return NextResponse.json({ error: "Project not found" }, { status: 404 });
  }

  // Verify membership (viewer can read)
  await requireWorkspaceAccess(project.workspaceId, "viewer");

  // Get signals for project
  const signals = await getSignalsForProject(projectId, { limit, offset });

  return NextResponse.json({ signals });
}
```

Import getProject from queries.ts.
  </action>
  <verify>
Run `cd /Users/tylersahagun/Source/elmer/orchestrator && npm run build` - all routes compile without error.
  </verify>
  <done>
Personas route handles GET/POST/DELETE for signal-persona associations. Projects signals route handles GET for fetching signals linked to a project with pagination.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes in orchestrator directory
2. All new route files exist and export correct HTTP methods
3. Query functions added to queries.ts compile correctly
</verification>

<success_criteria>
- POST /api/signals/:id/projects successfully creates junction record and updates status to "linked"
- DELETE /api/signals/:id/projects removes junction record and updates status to "reviewed" when last project unlinked
- POST/DELETE /api/signals/:id/personas manages persona associations without status changes
- GET /api/projects/:id/signals returns paginated signals linked to the project
- All endpoints enforce workspace membership permissions
</success_criteria>

<output>
After completion, create `.planning/phases/12.5-manual-association/12.5-01-SUMMARY.md`
</output>
