---
phase: 20-maintenance-agents
plan: 04
type: execute
wave: 2
depends_on: ["20-01", "20-02"]
files_modified:
  - orchestrator/src/lib/db/queries.ts
  - orchestrator/src/app/api/cron/maintenance/route.ts
  - orchestrator/src/app/api/signals/orphans/route.ts
  - orchestrator/src/app/api/signals/duplicates/route.ts
  - orchestrator/src/app/api/signals/archive/route.ts
  - orchestrator/src/app/api/signals/merge/route.ts
  - orchestrator/src/app/api/signals/[id]/suggestions/route.ts
autonomous: true

must_haves:
  truths:
    - "Maintenance cron runs periodically to detect orphans/duplicates"
    - "API endpoint returns orphan signals for a workspace"
    - "API endpoint returns duplicate signal pairs"
    - "API endpoint archives signals"
    - "API endpoint merges duplicate signals"
    - "API endpoint suggests project associations for orphan signals"
  artifacts:
    - path: "orchestrator/src/app/api/cron/maintenance/route.ts"
      provides: "GET cron handler for maintenance"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/orphans/route.ts"
      provides: "GET orphan signals"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/duplicates/route.ts"
      provides: "GET duplicate pairs"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/archive/route.ts"
      provides: "POST archive signals"
      exports: ["POST"]
    - path: "orchestrator/src/app/api/signals/merge/route.ts"
      provides: "POST merge signals"
      exports: ["POST"]
    - path: "orchestrator/src/app/api/signals/[id]/suggestions/route.ts"
      provides: "GET project suggestions for signal"
      exports: ["GET"]
  key_links:
    - from: "orchestrator/src/app/api/cron/maintenance/route.ts"
      to: "orchestrator/src/lib/maintenance"
      via: "import and call detection/archival functions"
      pattern: "from \"@/lib/maintenance\""
    - from: "orchestrator/src/lib/db/queries.ts"
      to: "orchestrator/src/lib/db/schema.ts"
      via: "getWorkspaceMaintenanceSettings"
      pattern: "DEFAULT_MAINTENANCE_SETTINGS"
    - from: "orchestrator/src/app/api/signals/[id]/suggestions/route.ts"
      to: "orchestrator/src/lib/db/queries.ts"
      via: "findBestProjectMatches for embedding similarity"
      pattern: "findBestProjectMatches"
---

<objective>
Create maintenance cron job and API endpoints for signal hygiene operations

Purpose: Enable periodic automated maintenance checks and expose APIs for manual maintenance operations. Follows Phase 19 cron pattern for signal-automation. Includes cleanup agent endpoint for project association suggestions (MAINT-01).

Output: Cron endpoint for periodic maintenance, plus REST APIs for orphans, duplicates, archive, merge, and project suggestions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-maintenance-agents/20-RESEARCH.md

# Required prior plans
@.planning/phases/20-maintenance-agents/20-01-SUMMARY.md (settings)
@.planning/phases/20-maintenance-agents/20-02-SUMMARY.md (detection)

# Pattern references
@orchestrator/src/app/api/cron/signal-automation/route.ts (cron pattern)
@orchestrator/src/lib/db/queries.ts (getWorkspaceAutomationSettings pattern, findBestProjectMatch pattern)
@orchestrator/src/lib/classification/classifier.ts (classification thresholds)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getWorkspaceMaintenanceSettings and findBestProjectMatches query functions</name>
  <files>orchestrator/src/lib/db/queries.ts</files>
  <action>
Add two query functions:

1. getWorkspaceMaintenanceSettings (follows getWorkspaceAutomationSettings pattern):

Add to imports at top of file:
```typescript
import {
  // ... existing imports ...
  type MaintenanceSettings,
  DEFAULT_MAINTENANCE_SETTINGS,
} from "./schema";
```

Add function after getWorkspaceAutomationSettings (around line 1450):

```typescript
/**
 * Get workspace maintenance settings, merging with defaults.
 */
export async function getWorkspaceMaintenanceSettings(
  workspaceId: string
): Promise<MaintenanceSettings> {
  const workspace = await db.query.workspaces.findFirst({
    where: eq(workspaces.id, workspaceId),
    columns: {
      settings: true,
    },
  });

  const workspaceSettings = workspace?.settings?.maintenance;

  // Merge with defaults (workspace settings override defaults)
  return {
    ...DEFAULT_MAINTENANCE_SETTINGS,
    ...workspaceSettings,
  };
}
```

2. findBestProjectMatches (similar to findBestProjectMatch but returns multiple):

```typescript
/**
 * Find multiple best matching projects for a signal vector.
 * Used for cleanup agent suggestions (MAINT-01).
 *
 * @param workspaceId - Workspace to search
 * @param signalVector - Signal embedding vector
 * @param limit - Number of matches to return (default: 3)
 * @returns Array of matching projects with similarity scores
 */
export async function findBestProjectMatches(
  workspaceId: string,
  signalVector: number[],
  limit = 3
): Promise<Array<{
  id: string;
  name: string;
  description: string | null;
  stage: string;
  similarity: number;
}>> {
  const vectorStr = `[${signalVector.join(",")}]`;

  const result = await db.execute(sql`
    SELECT
      id,
      name,
      description,
      stage,
      1 - (embedding_vector <=> ${vectorStr}::vector) AS similarity
    FROM projects
    WHERE workspace_id = ${workspaceId}
      AND embedding_vector IS NOT NULL
      AND status = 'active'
    ORDER BY embedding_vector <=> ${vectorStr}::vector
    LIMIT ${limit}
  `);

  return result.rows.map((row: Record<string, unknown>) => ({
    id: row.id as string,
    name: row.name as string,
    description: row.description as string | null,
    stage: row.stage as string,
    similarity: row.similarity as number,
  }));
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `grep -n "getWorkspaceMaintenanceSettings\|findBestProjectMatches" src/lib/db/queries.ts`
  </verify>
  <done>Both getWorkspaceMaintenanceSettings and findBestProjectMatches functions exist</done>
</task>

<task type="auto">
  <name>Task 2: Create maintenance cron endpoint</name>
  <files>orchestrator/src/app/api/cron/maintenance/route.ts</files>
  <action>
Create directory and cron endpoint following signal-automation pattern:

```typescript
/**
 * GET /api/cron/maintenance
 *
 * Cron endpoint for periodic signal maintenance checks.
 * Runs daily to:
 * - Detect orphan signals
 * - Detect duplicate signals
 * - Auto-archive if enabled
 * - Send notifications if thresholds exceeded
 *
 * Protected by CRON_SECRET header (Vercel sets this automatically).
 *
 * Configure in vercel.json:
 * {
 *   "crons": [{
 *     "path": "/api/cron/maintenance",
 *     "schedule": "0 0 * * *"
 *   }]
 * }
 */

import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { workspaces } from "@/lib/db/schema";
import { getWorkspaceMaintenanceSettings } from "@/lib/db/queries";
import {
  findOrphanSignals,
  findDuplicateSignals,
  archiveSignals,
} from "@/lib/maintenance";
import { createThresholdAwareNotification } from "@/lib/notifications";

export const maxDuration = 300; // 5 minutes max
export const dynamic = "force-dynamic";

interface WorkspaceMaintenanceResult {
  workspaceId: string;
  orphanCount?: number;
  duplicatePairs?: number;
  archivedCount?: number;
  notified?: boolean;
  error?: string;
}

export async function GET(request: NextRequest) {
  // Verify cron secret
  const authHeader = request.headers.get("authorization");
  const cronSecret = process.env.CRON_SECRET;

  // In development, allow without secret
  if (process.env.NODE_ENV === "production" && cronSecret) {
    if (authHeader !== `Bearer ${cronSecret}`) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
  }

  const startTime = Date.now();

  // Get all workspaces
  const workspaceList = await db
    .select({ id: workspaces.id, name: workspaces.name })
    .from(workspaces);

  const results: WorkspaceMaintenanceResult[] = [];

  for (const workspace of workspaceList) {
    try {
      const settings = await getWorkspaceMaintenanceSettings(workspace.id);
      const result: WorkspaceMaintenanceResult = {
        workspaceId: workspace.id,
      };

      // Orphan detection
      if (settings.flagOrphansEnabled) {
        const orphans = await findOrphanSignals(
          workspace.id,
          settings.orphanThresholdDays
        );
        result.orphanCount = orphans.total;

        // Notify if threshold exceeded
        if (
          settings.notifyOnOrphanThreshold &&
          orphans.total >= settings.notifyOnOrphanThreshold
        ) {
          await createThresholdAwareNotification(
            {
              workspaceId: workspace.id,
              type: "action_required",
              metadata: { orphanCount: orphans.total },
            },
            `${orphans.total} orphan signals need attention`,
            `${orphans.total} signals have been unlinked for ${settings.orphanThresholdDays}+ days and need review or archival.`,
            {
              priority: "medium",
              actionUrl: "/signals?status=orphan",
              actionLabel: "Review Orphans",
            }
          );
          result.notified = true;
        }
      }

      // Duplicate detection
      if (settings.duplicateDetectionEnabled) {
        const duplicates = await findDuplicateSignals(
          workspace.id,
          settings.duplicateSimilarityThreshold
        );
        result.duplicatePairs = duplicates.total;

        // Notify if enabled and duplicates found
        if (settings.notifyOnDuplicates && duplicates.total > 0) {
          await createThresholdAwareNotification(
            {
              workspaceId: workspace.id,
              type: "action_required",
              metadata: { duplicateCount: duplicates.total },
            },
            `${duplicates.total} potential duplicate signals found`,
            `Review and merge duplicate signals to keep your signal library clean.`,
            {
              priority: "low",
              actionUrl: "/signals?view=duplicates",
              actionLabel: "Review Duplicates",
            }
          );
          result.notified = true;
        }
      }

      // Auto-archival
      if (settings.autoArchiveEnabled) {
        const archived = await archiveSignals(workspace.id, {
          linkedOlderThanDays: settings.autoArchiveLinkedAfterDays,
          reviewedOlderThanDays: settings.autoArchiveReviewedAfterDays,
        });
        result.archivedCount = archived.archivedCount;
      }

      results.push(result);
    } catch (error) {
      console.error(
        `[Maintenance] Check failed for workspace ${workspace.id}:`,
        error
      );
      results.push({
        workspaceId: workspace.id,
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  const duration = Date.now() - startTime;

  return NextResponse.json({
    success: true,
    timestamp: new Date().toISOString(),
    durationMs: duration,
    workspacesChecked: workspaceList.length,
    results,
  });
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `grep -n "GET" src/app/api/cron/maintenance/route.ts`
  </verify>
  <done>Maintenance cron endpoint exists at /api/cron/maintenance</done>
</task>

<task type="auto">
  <name>Task 3: Create orphans, duplicates, archive, merge, and suggestions API endpoints</name>
  <files>
orchestrator/src/app/api/signals/orphans/route.ts
orchestrator/src/app/api/signals/duplicates/route.ts
orchestrator/src/app/api/signals/archive/route.ts
orchestrator/src/app/api/signals/merge/route.ts
orchestrator/src/app/api/signals/[id]/suggestions/route.ts
  </files>
  <action>
Create five API endpoints for maintenance operations.

**1. orchestrator/src/app/api/signals/orphans/route.ts:**
```typescript
/**
 * GET /api/signals/orphans
 *
 * Returns orphan signals for a workspace.
 * Query params: workspaceId, thresholdDays (optional), limit (optional)
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership, getWorkspaceMaintenanceSettings } from "@/lib/db/queries";
import { findOrphanSignals } from "@/lib/maintenance";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const workspaceId = searchParams.get("workspaceId");

  if (!workspaceId) {
    return NextResponse.json(
      { error: "workspaceId is required" },
      { status: 400 }
    );
  }

  // Check membership (viewer can read)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership) {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const settings = await getWorkspaceMaintenanceSettings(workspaceId);
  const thresholdDays = parseInt(searchParams.get("thresholdDays") || "") || settings.orphanThresholdDays;
  const limit = Math.min(parseInt(searchParams.get("limit") || "50"), 100);

  const result = await findOrphanSignals(workspaceId, thresholdDays, limit);

  return NextResponse.json(result);
}
```

**2. orchestrator/src/app/api/signals/duplicates/route.ts:**
```typescript
/**
 * GET /api/signals/duplicates
 *
 * Returns potential duplicate signal pairs for a workspace.
 * Query params: workspaceId, similarity (optional), limit (optional)
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership, getWorkspaceMaintenanceSettings } from "@/lib/db/queries";
import { findDuplicateSignals } from "@/lib/maintenance";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const workspaceId = searchParams.get("workspaceId");

  if (!workspaceId) {
    return NextResponse.json(
      { error: "workspaceId is required" },
      { status: 400 }
    );
  }

  // Check membership (viewer can read)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership) {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const settings = await getWorkspaceMaintenanceSettings(workspaceId);
  const similarity = parseFloat(searchParams.get("similarity") || "") || settings.duplicateSimilarityThreshold;
  const limit = Math.min(parseInt(searchParams.get("limit") || "20"), 50);

  const result = await findDuplicateSignals(workspaceId, similarity, limit);

  return NextResponse.json(result);
}
```

**3. orchestrator/src/app/api/signals/archive/route.ts:**
```typescript
/**
 * POST /api/signals/archive
 *
 * Archives signals based on criteria.
 * Body: { workspaceId, signalIds?: string[], linkedOlderThanDays?: number, reviewedOlderThanDays?: number }
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership } from "@/lib/db/queries";
import { archiveSignals, unarchiveSignals } from "@/lib/maintenance";

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await request.json();
  const { workspaceId, signalIds, linkedOlderThanDays, reviewedOlderThanDays } = body;

  if (!workspaceId) {
    return NextResponse.json(
      { error: "workspaceId is required" },
      { status: 400 }
    );
  }

  // Check membership (member required for write operations)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership || membership.role === "viewer") {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const result = await archiveSignals(
    workspaceId,
    {
      signalIds,
      linkedOlderThanDays,
      reviewedOlderThanDays,
    },
    session.user.id
  );

  return NextResponse.json(result);
}

/**
 * DELETE /api/signals/archive (unarchive)
 *
 * Restores archived signals.
 * Body: { workspaceId, signalIds: string[] }
 */
export async function DELETE(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await request.json();
  const { workspaceId, signalIds } = body;

  if (!workspaceId || !signalIds || !Array.isArray(signalIds)) {
    return NextResponse.json(
      { error: "workspaceId and signalIds array required" },
      { status: 400 }
    );
  }

  // Check membership (member required)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership || membership.role === "viewer") {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const result = await unarchiveSignals(workspaceId, signalIds, session.user.id);

  return NextResponse.json(result);
}
```

**4. orchestrator/src/app/api/signals/merge/route.ts:**
```typescript
/**
 * POST /api/signals/merge
 *
 * Merges duplicate signals.
 * Body: { workspaceId, primarySignalId, secondarySignalId }
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership } from "@/lib/db/queries";
import { mergeSignals, dismissDuplicatePair } from "@/lib/maintenance";

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await request.json();
  const { workspaceId, primarySignalId, secondarySignalId, action } = body;

  if (!workspaceId || !primarySignalId || !secondarySignalId) {
    return NextResponse.json(
      { error: "workspaceId, primarySignalId, and secondarySignalId required" },
      { status: 400 }
    );
  }

  // Check membership (member required for write operations)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership || membership.role === "viewer") {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  // Handle dismiss action
  if (action === "dismiss") {
    await dismissDuplicatePair(
      workspaceId,
      primarySignalId,
      secondarySignalId,
      session.user.id
    );
    return NextResponse.json({ success: true, action: "dismissed" });
  }

  // Default: merge signals
  const result = await mergeSignals(
    workspaceId,
    primarySignalId,
    secondarySignalId,
    session.user.id
  );

  return NextResponse.json(result);
}
```

**5. orchestrator/src/app/api/signals/[id]/suggestions/route.ts (NEW - MAINT-01):**
```typescript
/**
 * GET /api/signals/[id]/suggestions
 *
 * Returns project association suggestions for an orphan signal.
 * Uses Phase 17 classification to suggest relevant projects.
 *
 * MAINT-01: Cleanup agent suggests signal-to-project associations for unlinked signals.
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/db";
import { signals } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";
import {
  getWorkspaceMembership,
  getWorkspaceMaintenanceSettings,
  findBestProjectMatches,
} from "@/lib/db/queries";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id: signalId } = await params;
  const { searchParams } = new URL(request.url);
  const workspaceId = searchParams.get("workspaceId");

  if (!workspaceId) {
    return NextResponse.json(
      { error: "workspaceId is required" },
      { status: 400 }
    );
  }

  // Check membership
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership) {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  // Get the signal with its embedding
  const signal = await db.query.signals.findFirst({
    where: and(eq(signals.id, signalId), eq(signals.workspaceId, workspaceId)),
    columns: {
      id: true,
      verbatim: true,
      embeddingVector: true,
      status: true,
    },
  });

  if (!signal) {
    return NextResponse.json({ error: "Signal not found" }, { status: 404 });
  }

  if (!signal.embeddingVector) {
    return NextResponse.json({
      suggestions: [],
      reason: "Signal has no embedding - cannot compute similarity",
    });
  }

  // Get maintenance settings for confidence threshold
  const settings = await getWorkspaceMaintenanceSettings(workspaceId);
  const minConfidence = settings.minSuggestionConfidence || 0.6;

  // Find similar projects using Phase 17's classification infrastructure
  const matches = await findBestProjectMatches(
    workspaceId,
    signal.embeddingVector,
    5 // Return top 5 matches
  );

  // Filter by confidence threshold and format response
  const suggestions = matches
    .filter((match) => match.similarity >= minConfidence)
    .map((match) => ({
      projectId: match.id,
      projectName: match.name,
      projectDescription: match.description,
      projectStage: match.stage,
      confidence: match.similarity,
      reason: `${Math.round(match.similarity * 100)}% semantic similarity to "${match.name}"`,
    }));

  return NextResponse.json({
    signalId,
    suggestions,
    minConfidence,
    totalMatches: matches.length,
    filteredCount: suggestions.length,
  });
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `ls -la src/app/api/signals/{orphans,duplicates,archive,merge}/route.ts src/app/api/signals/*/suggestions/route.ts 2>/dev/null || ls -la src/app/api/signals/`
  </verify>
  <done>All five API endpoints exist with proper auth and functionality, including suggestions endpoint for MAINT-01</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors
- [ ] getWorkspaceMaintenanceSettings exists in queries.ts
- [ ] findBestProjectMatches exists in queries.ts
- [ ] /api/cron/maintenance endpoint handles GET requests
- [ ] /api/signals/orphans returns orphan signals
- [ ] /api/signals/duplicates returns duplicate pairs
- [ ] /api/signals/archive handles POST (archive) and DELETE (unarchive)
- [ ] /api/signals/merge handles POST for merge and dismiss
- [ ] /api/signals/[id]/suggestions returns project suggestions for orphan signals (MAINT-01)
- [ ] All endpoints check authentication and workspace membership
</verification>

<success_criteria>
1. Maintenance cron iterates workspaces and runs detection/archival based on settings
2. Orphans API returns signals meeting orphan criteria
3. Duplicates API returns high-similarity pairs
4. Archive API supports both manual and time-based archival
5. Merge API supports merge and dismiss actions
6. Suggestions API returns project associations for unlinked signals (MAINT-01)
7. All endpoints enforce proper access control
</success_criteria>

<output>
After completion, create `.planning/phases/20-maintenance-agents/20-04-SUMMARY.md`
</output>
