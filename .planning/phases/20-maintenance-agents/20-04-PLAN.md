---
phase: 20-maintenance-agents
plan: 04
type: execute
wave: 2
depends_on: ["20-01", "20-02"]
files_modified:
  - orchestrator/src/lib/db/queries.ts
  - orchestrator/src/app/api/cron/maintenance/route.ts
  - orchestrator/src/app/api/signals/orphans/route.ts
  - orchestrator/src/app/api/signals/duplicates/route.ts
  - orchestrator/src/app/api/signals/archive/route.ts
  - orchestrator/src/app/api/signals/merge/route.ts
autonomous: true

must_haves:
  truths:
    - "Maintenance cron runs periodically to detect orphans/duplicates"
    - "API endpoint returns orphan signals for a workspace"
    - "API endpoint returns duplicate signal pairs"
    - "API endpoint archives signals"
    - "API endpoint merges duplicate signals"
  artifacts:
    - path: "orchestrator/src/app/api/cron/maintenance/route.ts"
      provides: "GET cron handler for maintenance"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/orphans/route.ts"
      provides: "GET orphan signals"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/duplicates/route.ts"
      provides: "GET duplicate pairs"
      exports: ["GET"]
    - path: "orchestrator/src/app/api/signals/archive/route.ts"
      provides: "POST archive signals"
      exports: ["POST"]
    - path: "orchestrator/src/app/api/signals/merge/route.ts"
      provides: "POST merge signals"
      exports: ["POST"]
  key_links:
    - from: "orchestrator/src/app/api/cron/maintenance/route.ts"
      to: "orchestrator/src/lib/maintenance"
      via: "import and call detection/archival functions"
      pattern: "from \"@/lib/maintenance\""
    - from: "orchestrator/src/lib/db/queries.ts"
      to: "orchestrator/src/lib/db/schema.ts"
      via: "getWorkspaceMaintenanceSettings"
      pattern: "DEFAULT_MAINTENANCE_SETTINGS"
---

<objective>
Create maintenance cron job and API endpoints for signal hygiene operations

Purpose: Enable periodic automated maintenance checks and expose APIs for manual maintenance operations. Follows Phase 19 cron pattern for signal-automation.

Output: Cron endpoint for periodic maintenance, plus REST APIs for orphans, duplicates, archive, and merge
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-maintenance-agents/20-RESEARCH.md

# Required prior plans
@.planning/phases/20-maintenance-agents/20-01-SUMMARY.md (settings)
@.planning/phases/20-maintenance-agents/20-02-SUMMARY.md (detection)

# Pattern references
@orchestrator/src/app/api/cron/signal-automation/route.ts (cron pattern)
@orchestrator/src/lib/db/queries.ts (getWorkspaceAutomationSettings pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getWorkspaceMaintenanceSettings query function</name>
  <files>orchestrator/src/lib/db/queries.ts</files>
  <action>
Add query function to get workspace maintenance settings (follows getWorkspaceAutomationSettings pattern).

Add to imports at top of file:
```typescript
import {
  // ... existing imports ...
  type MaintenanceSettings,
  DEFAULT_MAINTENANCE_SETTINGS,
} from "./schema";
```

Add function after getWorkspaceAutomationSettings (around line 1450):

```typescript
/**
 * Get workspace maintenance settings, merging with defaults.
 */
export async function getWorkspaceMaintenanceSettings(
  workspaceId: string
): Promise<MaintenanceSettings> {
  const workspace = await db.query.workspaces.findFirst({
    where: eq(workspaces.id, workspaceId),
    columns: {
      settings: true,
    },
  });

  const workspaceSettings = workspace?.settings?.maintenance;

  // Merge with defaults (workspace settings override defaults)
  return {
    ...DEFAULT_MAINTENANCE_SETTINGS,
    ...workspaceSettings,
  };
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `grep -n "getWorkspaceMaintenanceSettings" src/lib/db/queries.ts`
  </verify>
  <done>getWorkspaceMaintenanceSettings function exists and returns merged settings</done>
</task>

<task type="auto">
  <name>Task 2: Create maintenance cron endpoint</name>
  <files>orchestrator/src/app/api/cron/maintenance/route.ts</files>
  <action>
Create directory and cron endpoint following signal-automation pattern:

```typescript
/**
 * GET /api/cron/maintenance
 *
 * Cron endpoint for periodic signal maintenance checks.
 * Runs daily to:
 * - Detect orphan signals
 * - Detect duplicate signals
 * - Auto-archive if enabled
 * - Send notifications if thresholds exceeded
 *
 * Protected by CRON_SECRET header (Vercel sets this automatically).
 *
 * Configure in vercel.json:
 * {
 *   "crons": [{
 *     "path": "/api/cron/maintenance",
 *     "schedule": "0 0 * * *"
 *   }]
 * }
 */

import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { workspaces } from "@/lib/db/schema";
import { getWorkspaceMaintenanceSettings } from "@/lib/db/queries";
import {
  findOrphanSignals,
  findDuplicateSignals,
  archiveSignals,
} from "@/lib/maintenance";
import { createThresholdAwareNotification } from "@/lib/notifications";

export const maxDuration = 300; // 5 minutes max
export const dynamic = "force-dynamic";

interface WorkspaceMaintenanceResult {
  workspaceId: string;
  orphanCount?: number;
  duplicatePairs?: number;
  archivedCount?: number;
  notified?: boolean;
  error?: string;
}

export async function GET(request: NextRequest) {
  // Verify cron secret
  const authHeader = request.headers.get("authorization");
  const cronSecret = process.env.CRON_SECRET;

  // In development, allow without secret
  if (process.env.NODE_ENV === "production" && cronSecret) {
    if (authHeader !== `Bearer ${cronSecret}`) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
  }

  const startTime = Date.now();

  // Get all workspaces
  const workspaceList = await db
    .select({ id: workspaces.id, name: workspaces.name })
    .from(workspaces);

  const results: WorkspaceMaintenanceResult[] = [];

  for (const workspace of workspaceList) {
    try {
      const settings = await getWorkspaceMaintenanceSettings(workspace.id);
      const result: WorkspaceMaintenanceResult = {
        workspaceId: workspace.id,
      };

      // Orphan detection
      if (settings.flagOrphansEnabled) {
        const orphans = await findOrphanSignals(
          workspace.id,
          settings.orphanThresholdDays
        );
        result.orphanCount = orphans.total;

        // Notify if threshold exceeded
        if (
          settings.notifyOnOrphanThreshold &&
          orphans.total >= settings.notifyOnOrphanThreshold
        ) {
          await createThresholdAwareNotification(
            {
              workspaceId: workspace.id,
              type: "action_required",
              metadata: { orphanCount: orphans.total },
            },
            `${orphans.total} orphan signals need attention`,
            `${orphans.total} signals have been unlinked for ${settings.orphanThresholdDays}+ days and need review or archival.`,
            {
              priority: "medium",
              actionUrl: "/signals?status=orphan",
              actionLabel: "Review Orphans",
            }
          );
          result.notified = true;
        }
      }

      // Duplicate detection
      if (settings.duplicateDetectionEnabled) {
        const duplicates = await findDuplicateSignals(
          workspace.id,
          settings.duplicateSimilarityThreshold
        );
        result.duplicatePairs = duplicates.total;

        // Notify if enabled and duplicates found
        if (settings.notifyOnDuplicates && duplicates.total > 0) {
          await createThresholdAwareNotification(
            {
              workspaceId: workspace.id,
              type: "action_required",
              metadata: { duplicateCount: duplicates.total },
            },
            `${duplicates.total} potential duplicate signals found`,
            `Review and merge duplicate signals to keep your signal library clean.`,
            {
              priority: "low",
              actionUrl: "/signals?view=duplicates",
              actionLabel: "Review Duplicates",
            }
          );
          result.notified = true;
        }
      }

      // Auto-archival
      if (settings.autoArchiveEnabled) {
        const archived = await archiveSignals(workspace.id, {
          linkedOlderThanDays: settings.autoArchiveLinkedAfterDays,
          reviewedOlderThanDays: settings.autoArchiveReviewedAfterDays,
        });
        result.archivedCount = archived.archivedCount;
      }

      results.push(result);
    } catch (error) {
      console.error(
        `[Maintenance] Check failed for workspace ${workspace.id}:`,
        error
      );
      results.push({
        workspaceId: workspace.id,
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  const duration = Date.now() - startTime;

  return NextResponse.json({
    success: true,
    timestamp: new Date().toISOString(),
    durationMs: duration,
    workspacesChecked: workspaceList.length,
    results,
  });
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `grep -n "GET" src/app/api/cron/maintenance/route.ts`
  </verify>
  <done>Maintenance cron endpoint exists at /api/cron/maintenance</done>
</task>

<task type="auto">
  <name>Task 3: Create orphans, duplicates, archive, and merge API endpoints</name>
  <files>
orchestrator/src/app/api/signals/orphans/route.ts
orchestrator/src/app/api/signals/duplicates/route.ts
orchestrator/src/app/api/signals/archive/route.ts
orchestrator/src/app/api/signals/merge/route.ts
  </files>
  <action>
Create four API endpoints for maintenance operations.

**1. orchestrator/src/app/api/signals/orphans/route.ts:**
```typescript
/**
 * GET /api/signals/orphans
 *
 * Returns orphan signals for a workspace.
 * Query params: workspaceId, thresholdDays (optional), limit (optional)
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership, getWorkspaceMaintenanceSettings } from "@/lib/db/queries";
import { findOrphanSignals } from "@/lib/maintenance";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const workspaceId = searchParams.get("workspaceId");

  if (!workspaceId) {
    return NextResponse.json(
      { error: "workspaceId is required" },
      { status: 400 }
    );
  }

  // Check membership (viewer can read)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership) {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const settings = await getWorkspaceMaintenanceSettings(workspaceId);
  const thresholdDays = parseInt(searchParams.get("thresholdDays") || "") || settings.orphanThresholdDays;
  const limit = Math.min(parseInt(searchParams.get("limit") || "50"), 100);

  const result = await findOrphanSignals(workspaceId, thresholdDays, limit);

  return NextResponse.json(result);
}
```

**2. orchestrator/src/app/api/signals/duplicates/route.ts:**
```typescript
/**
 * GET /api/signals/duplicates
 *
 * Returns potential duplicate signal pairs for a workspace.
 * Query params: workspaceId, similarity (optional), limit (optional)
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership, getWorkspaceMaintenanceSettings } from "@/lib/db/queries";
import { findDuplicateSignals } from "@/lib/maintenance";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const workspaceId = searchParams.get("workspaceId");

  if (!workspaceId) {
    return NextResponse.json(
      { error: "workspaceId is required" },
      { status: 400 }
    );
  }

  // Check membership (viewer can read)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership) {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const settings = await getWorkspaceMaintenanceSettings(workspaceId);
  const similarity = parseFloat(searchParams.get("similarity") || "") || settings.duplicateSimilarityThreshold;
  const limit = Math.min(parseInt(searchParams.get("limit") || "20"), 50);

  const result = await findDuplicateSignals(workspaceId, similarity, limit);

  return NextResponse.json(result);
}
```

**3. orchestrator/src/app/api/signals/archive/route.ts:**
```typescript
/**
 * POST /api/signals/archive
 *
 * Archives signals based on criteria.
 * Body: { workspaceId, signalIds?: string[], linkedOlderThanDays?: number, reviewedOlderThanDays?: number }
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership } from "@/lib/db/queries";
import { archiveSignals, unarchiveSignals } from "@/lib/maintenance";

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await request.json();
  const { workspaceId, signalIds, linkedOlderThanDays, reviewedOlderThanDays } = body;

  if (!workspaceId) {
    return NextResponse.json(
      { error: "workspaceId is required" },
      { status: 400 }
    );
  }

  // Check membership (member required for write operations)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership || membership.role === "viewer") {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const result = await archiveSignals(
    workspaceId,
    {
      signalIds,
      linkedOlderThanDays,
      reviewedOlderThanDays,
    },
    session.user.id
  );

  return NextResponse.json(result);
}

/**
 * DELETE /api/signals/archive (unarchive)
 *
 * Restores archived signals.
 * Body: { workspaceId, signalIds: string[] }
 */
export async function DELETE(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await request.json();
  const { workspaceId, signalIds } = body;

  if (!workspaceId || !signalIds || !Array.isArray(signalIds)) {
    return NextResponse.json(
      { error: "workspaceId and signalIds array required" },
      { status: 400 }
    );
  }

  // Check membership (member required)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership || membership.role === "viewer") {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  const result = await unarchiveSignals(workspaceId, signalIds, session.user.id);

  return NextResponse.json(result);
}
```

**4. orchestrator/src/app/api/signals/merge/route.ts:**
```typescript
/**
 * POST /api/signals/merge
 *
 * Merges duplicate signals.
 * Body: { workspaceId, primarySignalId, secondarySignalId }
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getWorkspaceMembership } from "@/lib/db/queries";
import { mergeSignals, dismissDuplicatePair } from "@/lib/maintenance";

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await request.json();
  const { workspaceId, primarySignalId, secondarySignalId, action } = body;

  if (!workspaceId || !primarySignalId || !secondarySignalId) {
    return NextResponse.json(
      { error: "workspaceId, primarySignalId, and secondarySignalId required" },
      { status: 400 }
    );
  }

  // Check membership (member required for write operations)
  const membership = await getWorkspaceMembership(workspaceId, session.user.id);
  if (!membership || membership.role === "viewer") {
    return NextResponse.json({ error: "Access denied" }, { status: 403 });
  }

  // Handle dismiss action
  if (action === "dismiss") {
    await dismissDuplicatePair(
      workspaceId,
      primarySignalId,
      secondarySignalId,
      session.user.id
    );
    return NextResponse.json({ success: true, action: "dismissed" });
  }

  // Default: merge signals
  const result = await mergeSignals(
    workspaceId,
    primarySignalId,
    secondarySignalId,
    session.user.id
  );

  return NextResponse.json(result);
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `ls -la src/app/api/signals/{orphans,duplicates,archive,merge}/route.ts`
  </verify>
  <done>All four API endpoints exist with proper auth and functionality</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors
- [ ] getWorkspaceMaintenanceSettings exists in queries.ts
- [ ] /api/cron/maintenance endpoint handles GET requests
- [ ] /api/signals/orphans returns orphan signals
- [ ] /api/signals/duplicates returns duplicate pairs
- [ ] /api/signals/archive handles POST (archive) and DELETE (unarchive)
- [ ] /api/signals/merge handles POST for merge and dismiss
- [ ] All endpoints check authentication and workspace membership
</verification>

<success_criteria>
1. Maintenance cron iterates workspaces and runs detection/archival based on settings
2. Orphans API returns signals meeting orphan criteria
3. Duplicates API returns high-similarity pairs
4. Archive API supports both manual and time-based archival
5. Merge API supports merge and dismiss actions
6. All endpoints enforce proper access control
</success_criteria>

<output>
After completion, create `.planning/phases/20-maintenance-agents/20-04-SUMMARY.md`
</output>
