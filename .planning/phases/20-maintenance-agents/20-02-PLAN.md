---
phase: 20-maintenance-agents
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/src/lib/maintenance/orphan-detector.ts
  - orchestrator/src/lib/maintenance/duplicate-detector.ts
  - orchestrator/src/lib/maintenance/index.ts
autonomous: true

must_haves:
  truths:
    - "System can identify signals unlinked after N days"
    - "System can detect semantically similar signals as potential duplicates"
    - "Orphan detection respects configurable threshold"
    - "Duplicate detection uses high similarity threshold (0.9+)"
  artifacts:
    - path: "orchestrator/src/lib/maintenance/orphan-detector.ts"
      provides: "findOrphanSignals function"
      exports: ["findOrphanSignals", "OrphanSignal", "OrphanDetectionResult"]
    - path: "orchestrator/src/lib/maintenance/duplicate-detector.ts"
      provides: "findDuplicateSignals function"
      exports: ["findDuplicateSignals", "DuplicatePair", "DuplicateDetectionResult"]
    - path: "orchestrator/src/lib/maintenance/index.ts"
      provides: "Module exports"
  key_links:
    - from: "orchestrator/src/lib/maintenance/orphan-detector.ts"
      to: "orchestrator/src/lib/db/schema.ts"
      via: "signals, signalProjects, signalPersonas tables"
      pattern: "from \"@/lib/db/schema\""
    - from: "orchestrator/src/lib/maintenance/duplicate-detector.ts"
      to: "orchestrator/src/lib/db/schema.ts"
      via: "signals table with embeddingVector"
      pattern: "embeddingVector.*<=>.*vector"
---

<objective>
Create orphan and duplicate detection modules using existing pgvector infrastructure

Purpose: Build the detection layer for signal hygiene. Orphan detection finds signals that have been unlinked for too long. Duplicate detection uses pgvector similarity to find potential duplicates with high confidence threshold.

Output: Two detection modules that can be called by maintenance cron and APIs
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-maintenance-agents/20-RESEARCH.md

# Pattern references
@orchestrator/src/lib/classification/clustering.ts (pgvector similarity pattern)
@orchestrator/src/lib/db/queries.ts (signal queries)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create orphan-detector module</name>
  <files>orchestrator/src/lib/maintenance/orphan-detector.ts</files>
  <action>
Create `orchestrator/src/lib/maintenance/` directory if needed.

Create `orphan-detector.ts` with:

```typescript
/**
 * Orphan Signal Detector
 *
 * Identifies signals that have been in "new" status for too long
 * and are not linked to any project or persona.
 *
 * Definition: A signal is orphaned when:
 * - Status is "new" (never reviewed, linked, or archived)
 * - Created more than N days ago (configurable)
 * - Not linked to any project
 * - Not linked to any persona
 */

import { db } from "@/lib/db";
import { signals, signalProjects, signalPersonas } from "@/lib/db/schema";
import { eq, and, lt, notExists, sql } from "drizzle-orm";

export interface OrphanSignal {
  id: string;
  verbatim: string;
  source: string;
  severity: string | null;
  createdAt: Date;
  daysOrphaned: number;
}

export interface OrphanDetectionResult {
  signals: OrphanSignal[];
  total: number;
  oldestDays: number;
}

/**
 * Find orphan signals - unlinked signals older than threshold.
 *
 * @param workspaceId - Workspace to check
 * @param thresholdDays - Days after which unlinked signal is orphaned (default: 14)
 * @param limit - Max signals to return (default: 50)
 */
export async function findOrphanSignals(
  workspaceId: string,
  thresholdDays = 14,
  limit = 50
): Promise<OrphanDetectionResult> {
  const thresholdDate = new Date();
  thresholdDate.setDate(thresholdDate.getDate() - thresholdDays);

  // Find signals that are:
  // 1. In "new" status
  // 2. Created before threshold date
  // 3. Not linked to any project
  // 4. Not linked to any persona
  const orphans = await db
    .select({
      id: signals.id,
      verbatim: signals.verbatim,
      source: signals.source,
      severity: signals.severity,
      createdAt: signals.createdAt,
    })
    .from(signals)
    .where(
      and(
        eq(signals.workspaceId, workspaceId),
        eq(signals.status, "new"),
        lt(signals.createdAt, thresholdDate),
        notExists(
          db
            .select({ id: signalProjects.id })
            .from(signalProjects)
            .where(eq(signalProjects.signalId, signals.id))
        ),
        notExists(
          db
            .select({ id: signalPersonas.id })
            .from(signalPersonas)
            .where(eq(signalPersonas.signalId, signals.id))
        )
      )
    )
    .orderBy(signals.createdAt)
    .limit(limit);

  const now = new Date();
  const results = orphans.map((s) => ({
    id: s.id,
    verbatim: s.verbatim,
    source: s.source || "unknown",
    severity: s.severity,
    createdAt: s.createdAt,
    daysOrphaned: Math.floor(
      (now.getTime() - s.createdAt.getTime()) / (1000 * 60 * 60 * 24)
    ),
  }));

  return {
    signals: results,
    total: results.length,
    oldestDays: results.length > 0 ? results[0].daysOrphaned : 0,
  };
}

/**
 * Get count of orphan signals for dashboard display.
 */
export async function getOrphanCount(
  workspaceId: string,
  thresholdDays = 14
): Promise<number> {
  const thresholdDate = new Date();
  thresholdDate.setDate(thresholdDate.getDate() - thresholdDays);

  const result = await db
    .select({ count: sql<number>`count(*)::int` })
    .from(signals)
    .where(
      and(
        eq(signals.workspaceId, workspaceId),
        eq(signals.status, "new"),
        lt(signals.createdAt, thresholdDate),
        notExists(
          db
            .select({ id: signalProjects.id })
            .from(signalProjects)
            .where(eq(signalProjects.signalId, signals.id))
        ),
        notExists(
          db
            .select({ id: signalPersonas.id })
            .from(signalPersonas)
            .where(eq(signalPersonas.signalId, signals.id))
        )
      )
    );

  return result[0]?.count ?? 0;
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `grep -n "findOrphanSignals" src/lib/maintenance/orphan-detector.ts`
  </verify>
  <done>orphan-detector.ts exists with findOrphanSignals and getOrphanCount functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Create duplicate-detector module</name>
  <files>orchestrator/src/lib/maintenance/duplicate-detector.ts</files>
  <action>
Create `duplicate-detector.ts` with pgvector similarity search:

```typescript
/**
 * Duplicate Signal Detector
 *
 * Identifies signals that are semantically very similar and may be duplicates.
 * Uses pgvector cosine similarity with high threshold (0.9+).
 *
 * Definition: Two signals are potential duplicates when:
 * - Cosine similarity > 0.9 (configurable)
 * - Neither is already archived
 * - Both have embeddings
 */

import { db } from "@/lib/db";
import { signals } from "@/lib/db/schema";
import { eq, and, ne, isNotNull, sql } from "drizzle-orm";

export interface DuplicatePair {
  id: string; // Unique pair ID (sorted signal IDs joined)
  signal1: {
    id: string;
    verbatim: string;
    source: string;
    createdAt: Date;
  };
  signal2: {
    id: string;
    verbatim: string;
    source: string;
    createdAt: Date;
  };
  similarity: number;
}

export interface DuplicateDetectionResult {
  pairs: DuplicatePair[];
  total: number;
}

// Default threshold - very high to minimize false positives
const DEFAULT_DISTANCE_THRESHOLD = 0.1; // cosine distance < 0.1 = similarity > 0.9

/**
 * Find potential duplicate signal pairs.
 *
 * Algorithm:
 * 1. Get signals with embeddings that are not archived
 * 2. For each signal, find very similar signals via pgvector
 * 3. Deduplicate pairs (A-B same as B-A)
 * 4. Return pairs sorted by similarity
 *
 * @param workspaceId - Workspace to search
 * @param similarityThreshold - Min similarity (0-1, default 0.9)
 * @param limit - Max pairs to return (default 20)
 */
export async function findDuplicateSignals(
  workspaceId: string,
  similarityThreshold = 0.9,
  limit = 20
): Promise<DuplicateDetectionResult> {
  // Convert similarity to distance threshold
  const distanceThreshold = 1 - similarityThreshold;

  // Get signals with embeddings that are not archived
  const candidates = await db
    .select({
      id: signals.id,
      verbatim: signals.verbatim,
      source: signals.source,
      createdAt: signals.createdAt,
      embeddingVector: signals.embeddingVector,
    })
    .from(signals)
    .where(
      and(
        eq(signals.workspaceId, workspaceId),
        ne(signals.status, "archived"),
        isNotNull(signals.embeddingVector)
      )
    )
    .limit(100); // Process up to 100 signals for performance

  const pairs: DuplicatePair[] = [];
  const seenPairs = new Set<string>();

  for (const signal of candidates) {
    if (!signal.embeddingVector) continue;

    // Find similar signals using pgvector cosine distance
    const similar = await db
      .select({
        id: signals.id,
        verbatim: signals.verbatim,
        source: signals.source,
        createdAt: signals.createdAt,
        distance: sql<number>`${signals.embeddingVector} <=> ${JSON.stringify(signal.embeddingVector)}::vector`,
      })
      .from(signals)
      .where(
        and(
          eq(signals.workspaceId, workspaceId),
          ne(signals.id, signal.id),
          ne(signals.status, "archived"),
          isNotNull(signals.embeddingVector)
        )
      )
      .orderBy(
        sql`${signals.embeddingVector} <=> ${JSON.stringify(signal.embeddingVector)}::vector`
      )
      .limit(5);

    for (const match of similar) {
      // Only include if within distance threshold
      if (match.distance > distanceThreshold) continue;

      // Create canonical pair ID to avoid A-B and B-A duplicates
      const pairId = [signal.id, match.id].sort().join("-");
      if (seenPairs.has(pairId)) continue;
      seenPairs.add(pairId);

      pairs.push({
        id: pairId,
        signal1: {
          id: signal.id,
          verbatim: signal.verbatim,
          source: signal.source || "unknown",
          createdAt: signal.createdAt,
        },
        signal2: {
          id: match.id,
          verbatim: match.verbatim,
          source: match.source || "unknown",
          createdAt: match.createdAt,
        },
        similarity: 1 - match.distance,
      });

      if (pairs.length >= limit) break;
    }

    if (pairs.length >= limit) break;
  }

  // Sort by similarity (highest first)
  pairs.sort((a, b) => b.similarity - a.similarity);

  return {
    pairs,
    total: pairs.length,
  };
}

/**
 * Get count of duplicate pairs for dashboard display.
 */
export async function getDuplicateCount(
  workspaceId: string,
  similarityThreshold = 0.9
): Promise<number> {
  const result = await findDuplicateSignals(workspaceId, similarityThreshold, 50);
  return result.total;
}
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `grep -n "findDuplicateSignals" src/lib/maintenance/duplicate-detector.ts`
  </verify>
  <done>duplicate-detector.ts exists with findDuplicateSignals and getDuplicateCount functions exported</done>
</task>

<task type="auto">
  <name>Task 3: Create maintenance module index</name>
  <files>orchestrator/src/lib/maintenance/index.ts</files>
  <action>
Create `index.ts` to re-export maintenance utilities:

```typescript
/**
 * Maintenance Module
 *
 * Signal hygiene utilities for orphan detection, duplicate detection,
 * archival workflows, and cleanup suggestions.
 *
 * Usage: import { findOrphanSignals } from "@/lib/maintenance";
 */

export {
  findOrphanSignals,
  getOrphanCount,
  type OrphanSignal,
  type OrphanDetectionResult,
} from "./orphan-detector";

export {
  findDuplicateSignals,
  getDuplicateCount,
  type DuplicatePair,
  type DuplicateDetectionResult,
} from "./duplicate-detector";
```
  </action>
  <verify>
Run: `cd /Users/tylersahagun/Source/elmer/orchestrator && npx tsc --noEmit`
Test: `grep -n "export" src/lib/maintenance/index.ts`
  </verify>
  <done>index.ts exists and re-exports all detection utilities</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors
- [ ] orchestrator/src/lib/maintenance/ directory exists
- [ ] orphan-detector.ts exports findOrphanSignals and getOrphanCount
- [ ] duplicate-detector.ts exports findDuplicateSignals and getDuplicateCount
- [ ] index.ts re-exports all utilities
- [ ] Orphan detection uses NOT EXISTS for project/persona links
- [ ] Duplicate detection uses pgvector cosine distance operator (<=>)
</verification>

<success_criteria>
1. findOrphanSignals returns signals in "new" status older than threshold with no project/persona links
2. findDuplicateSignals returns pairs with similarity above threshold
3. Both functions accept workspaceId and configurable thresholds
4. Both modules compile and type-check correctly
</success_criteria>

<output>
After completion, create `.planning/phases/20-maintenance-agents/20-02-SUMMARY.md`
</output>
